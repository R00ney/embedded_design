###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.30.5.50715 for RL78             23/Mar/2014  17:08:37 #
# Copyright 2011-2013 IAR Systems AB.                                         #
# Network license: ece-lic-19.ece.ncsu.edu (STD)                              #
#                                                                             #
#    Core         =  rl78_2                                                   #
#    Code model   =  Near                                                     #
#    Data model   =  Near                                                     #
#                 =                                                           #
#    Source file  =  C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\uC-LIB\lib_mem.c           #
#    Command line =  C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\uC-LIB\lib_mem.c --core    #
#                    rl78_2 --code_model near --data_model near               #
#                    --near_const_location rom0 -o                            #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\Debug\Obj\ --dlib_config            #
#                    "C:\Program Files\IAR Systems\Embedded Workbench         #
#                    6.5\rl78\LIB\dlrl78nn2n.h" -e -Ohz --no_scheduling       #
#                    --no_clustering --debug -lC                              #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\Debug\List\ -I                      #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\ -I C:\Users\Suddenlink\Dropbox\git #
#                    _files\embedded_design\Proj2_uCOS-III-LCD-G14\Software\E #
#                    valBoards\Renesas\YRDKRL78G14\IAR\Application\Source\    #
#                    -I C:\Users\Suddenlink\Dropbox\git_files\embedded_design #
#                    \Proj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDK #
#                    RL78G14\IAR\Application\..\uCOS-III\ -I                  #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\..\BSP\ -I                          #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\..\BSP\applilet3_src\ -I            #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\..\BSP\Glyph\Drivers\ -I            #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\..\BSP\Glyph\glyph\ -I              #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\..\..\..\..\..\uC-CPU\ -I           #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\..\..\..\..\..\uC-CPU\RL78\IAR\ -I  #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\..\..\..\..\..\uC-LIB\ -I           #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\..\..\..\..\..\uCOS-III\Ports\Renes #
#                    as\RL78\IAR\ -I C:\Users\Suddenlink\Dropbox\git_files\em #
#                    bedded_design\Proj2_uCOS-III-LCD-G14\Software\EvalBoards #
#                    \Renesas\YRDKRL78G14\IAR\Application\..\..\..\..\..\uCOS #
#                    -III\Source\ --relaxed_fp                                #
#    List file    =  C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\Debug\List\lib_mem.lst              #
#    Object file  =  C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\Debug\Obj\lib_mem.r87               #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Proj2_uCOS-III-LCD-G14\Software\uC-LIB\lib_mem.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/LIB
      4          *                                        CUSTOM LIBRARY MODULES
      5          *
      6          *                          (c) Copyright 2004-2011; Micrium, Inc.; Weston, FL
      7          *
      8          *               All rights reserved.  Protected by international copyright laws.
      9          *
     10          *               uC/LIB is provided in source form to registered licensees ONLY.  It is
     11          *               illegal to distribute this source code to any third party unless you receive
     12          *               written permission by an authorized Micrium representative.  Knowledge of
     13          *               the source code may NOT be used to develop a similar product.
     14          *
     15          *               Please help us continue to provide the Embedded community with the finest
     16          *               software available.  Your honesty is greatly appreciated.
     17          *
     18          *               You can contact us at www.micrium.com.
     19          *********************************************************************************************************
     20          */
     21          
     22          /*
     23          *********************************************************************************************************
     24          *
     25          *                                     STANDARD MEMORY OPERATIONS
     26          *
     27          * Filename      : lib_mem.c
     28          * Version       : V1.36.01
     29          * Programmer(s) : ITJ
     30          *                 FGK
     31          *                 JFD
     32          *********************************************************************************************************
     33          * Note(s)       : (1) NO compiler-supplied standard library functions are used in library or product software.
     34          *
     35          *                     (a) ALL standard library functions are implemented in the custom library modules :
     36          *
     37          *                         (1) \<Custom Library Directory>\lib_*.*
     38          *
     39          *                         (2) \<Custom Library Directory>\Ports\<cpu>\<compiler>\lib*_a.*
     40          *
     41          *                               where
     42          *                                       <Custom Library Directory>      directory path for custom library software
     43          *                                       <cpu>                           directory name for specific processor (CPU)
     44          *                                       <compiler>                      directory name for specific compiler
     45          *
     46          *                     (b) Product-specific library functions are implemented in individual products.
     47          *********************************************************************************************************
     48          */
     49          
     50          
     51          /*
     52          *********************************************************************************************************
     53          *                                            INCLUDE FILES
     54          *********************************************************************************************************
     55          */
     56          
     57          #define    LIB_MEM_MODULE
     58          #include  <lib_mem.h>
     59          
     60          
     61          /*$PAGE*/
     62          /*
     63          *********************************************************************************************************
     64          *                                            LOCAL DEFINES
     65          *********************************************************************************************************
     66          */
     67          
     68          
     69          /*
     70          *********************************************************************************************************
     71          *                                           LOCAL CONSTANTS
     72          *********************************************************************************************************
     73          */
     74          
     75          
     76          /*
     77          *********************************************************************************************************
     78          *                                          LOCAL DATA TYPES
     79          *********************************************************************************************************
     80          */
     81          
     82          
     83          /*
     84          *********************************************************************************************************
     85          *                                            LOCAL TABLES
     86          *********************************************************************************************************
     87          */
     88          
     89          
     90          /*
     91          *********************************************************************************************************
     92          *                                       LOCAL GLOBAL VARIABLES
     93          *********************************************************************************************************
     94          */
     95          
     96          #if     (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
     97          MEM_POOL    *Mem_PoolTbl;                                               /* Mem      pool/seg tbl.                       */
     98          MEM_POOL     Mem_PoolHeap;                                              /* Mem heap pool/seg.                           */
     99          
    100          #ifndef  LIB_MEM_CFG_HEAP_BASE_ADDR
    101          CPU_INT08U   Mem_Heap[LIB_MEM_CFG_HEAP_SIZE];                           /* Mem heap.                                    */
    102          #endif
    103          #endif
    104          
    105          
    106          /*
    107          *********************************************************************************************************
    108          *                                      LOCAL FUNCTION PROTOTYPES
    109          *********************************************************************************************************
    110          */
    111          
    112          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)                               /* -------------- MEM POOL FNCTS -------------- */
    113          
    114          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    115          static  CPU_BOOLEAN   Mem_PoolBlkIsValidAddr(MEM_POOL          *pmem_pool,
    116                                                       void              *pmem_blk);
    117          #endif
    118          
    119          
    120          static  CPU_SIZE_T    Mem_SegCalcTotSize    (void              *pmem_addr,
    121                                                       MEM_POOL_BLK_QTY   blk_nbr,
    122                                                       CPU_SIZE_T         blk_size,
    123                                                       CPU_SIZE_T         blk_align);
    124          
    125          static  void         *Mem_SegAlloc          (MEM_POOL          *pmem_pool,
    126                                                       CPU_SIZE_T         size,
    127                                                       CPU_SIZE_T         align);
    128          
    129          #endif
    130          
    131          
    132          /*
    133          *********************************************************************************************************
    134          *                                     LOCAL CONFIGURATION ERRORS
    135          *********************************************************************************************************
    136          */
    137          
    138          
    139          /*$PAGE*/
    140          /*
    141          *********************************************************************************************************
    142          *                                             Mem_Init()
    143          *
    144          * Description : (1) Initialize Memory Management Module :
    145          *
    146          *                   (a) Initialize heap memory pool
    147          *                   (b) Initialize      memory pool table
    148          *
    149          *
    150          * Argument(s) : none.
    151          *
    152          * Return(s)   : none.
    153          *
    154          * Caller(s)   : Application.
    155          *
    156          * Note(s)     : (2) Mem_Init() MUST be called ... :
    157          *
    158          *                   (a) ONLY ONCE from a product's application; ...
    159          *                   (b) BEFORE product's application calls any memory library module function(s)
    160          *********************************************************************************************************
    161          */
    162          

   \                                 In  segment CODE, align 1, keep-with-next
    163          void  Mem_Init (void)
   \                     Mem_Init:
    164          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000                       ; Auto size: 0
    165          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
    166              MEM_POOL  *pmem_pool;
    167          
    168                                                                                  /* --------- INIT MEM HEAP SEG / POOL --------- */
    169              pmem_pool                   = (MEM_POOL   *)&Mem_PoolHeap;
    170              pmem_pool->Type             = (LIB_MEM_TYPE) LIB_MEM_TYPE_HEAP;
    171              pmem_pool->SegHeadPtr       = (MEM_POOL   *)&Mem_PoolHeap;          /* Heap seg head = heap seg.                    */
    172              pmem_pool->SegPrevPtr       = (MEM_POOL   *) 0;
    173              pmem_pool->SegNextPtr       = (MEM_POOL   *) 0;
    174              pmem_pool->PoolPrevPtr      = (MEM_POOL   *) 0;
    175              pmem_pool->PoolNextPtr      = (MEM_POOL   *) 0;
    176              pmem_pool->PoolAddrStart    = (void       *) 0;
    177              pmem_pool->PoolAddrEnd      = (void       *) 0;
    178              pmem_pool->PoolPtrs         = (void      **) 0;
    179              pmem_pool->BlkSize          = (CPU_SIZE_T  ) 0u;
    180              pmem_pool->BlkNbr           = (CPU_SIZE_T  ) 0u;
    181              pmem_pool->BlkIx            = (MEM_POOL_IX ) 0u;
    182          
    183          #ifdef  LIB_MEM_CFG_HEAP_BASE_ADDR
    184              pmem_pool->SegAddr          = (void       *) LIB_MEM_CFG_HEAP_BASE_ADDR;
    185              pmem_pool->SegAddrNextAvail = (void       *) LIB_MEM_CFG_HEAP_BASE_ADDR;
    186          #else
    187              pmem_pool->SegAddr          = (void       *)&Mem_Heap[0];
    188              pmem_pool->SegAddrNextAvail = (void       *)&Mem_Heap[0];
    189          #endif
    190          
    191              pmem_pool->SegSizeTot       = (CPU_SIZE_T  ) LIB_MEM_CFG_HEAP_SIZE;
    192              pmem_pool->SegSizeRem       = (CPU_SIZE_T  ) LIB_MEM_CFG_HEAP_SIZE;
    193          
    194                                                                                  /* ------------ INIT MEM POOL TBL ------------- */
    195              Mem_PoolTbl = &Mem_PoolHeap;
    196          #endif
    197          }
   \   000000 D7                    RET                          ;; 6 cycles
   \   000001                       ; ------------------------------------- Block: 6 cycles
   \   000001                       ; ------------------------------------- Total: 6 cycles
   \   000001                       REQUIRE ?CLRL78_V1_0_L00
    198          
    199          
    200          /*$PAGE*/
    201          /*
    202          *********************************************************************************************************
    203          *                                              Mem_Clr()
    204          *
    205          * Description : Clear data buffer (see Note #2).
    206          *
    207          * Argument(s) : pmem        Pointer to memory buffer to clear.
    208          *
    209          *               size        Number of data buffer octets to clear (see Note #1).
    210          *
    211          * Return(s)   : none.
    212          *
    213          * Caller(s)   : Application.
    214          *
    215          * Note(s)     : (1) Null clears allowed (i.e. zero-length clears).
    216          *
    217          *                   See also 'Mem_Set()  Note #1'.
    218          *
    219          *               (2) Clear data by setting each data octet to 0.
    220          *********************************************************************************************************
    221          */
    222          

   \                                 In  segment CODE, align 1, keep-with-next
    223          void  Mem_Clr (void        *pmem,
   \                     Mem_Clr:
    224                         CPU_SIZE_T   size)
    225          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000 C5                    PUSH      DE                 ;; 1 cycle
   \   000001                       ; Auto size: 0
    226              Mem_Set(pmem,
    227                      0u,                                                 /* See Note #2.                                         */
    228                      size);
   \   000001 C3                    PUSH      BC                 ;; 1 cycle
   \   000002 C4                    POP       DE                 ;; 1 cycle
   \   000003 F3                    CLRB      B                  ;; 1 cycle
   \   000004 FD....                CALL      Mem_Set            ;; 3 cycles
    229          }
   \   000007 C4                    POP       DE                 ;; 1 cycle
   \   000008 D7                    RET                          ;; 6 cycles
   \   000009                       ; ------------------------------------- Block: 14 cycles
   \   000009                       ; ------------------------------------- Total: 14 cycles
   \   000009                       REQUIRE ?CLRL78_V1_0_L00
    230          
    231          
    232          /*$PAGE*/
    233          /*
    234          *********************************************************************************************************
    235          *                                              Mem_Set()
    236          *
    237          * Description : Fill data buffer with specified data octet.
    238          *
    239          * Argument(s) : pmem        Pointer to memory buffer to fill with specified data octet.
    240          *
    241          *               data_val    Data fill octet value.
    242          *
    243          *               size        Number of data buffer octets to fill (see Note #1).
    244          *
    245          * Return(s)   : none.
    246          *
    247          * Caller(s)   : Application.
    248          *
    249          * Note(s)     : (1) Null sets allowed (i.e. zero-length sets).
    250          *
    251          *               (2) For best CPU performance, optimized to fill data buffer using 'CPU_ALIGN'-sized data
    252          *                   words.
    253          *
    254          *                   (a) Since many word-aligned processors REQUIRE that multi-octet words be accessed on
    255          *                       word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on 'CPU_ALIGN'd
    256          *                       addresses.
    257          *
    258          *               (3) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
    259          *                   address boundary.
    260          *
    261          *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus
    262          *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
    263          *                  'mem_align_mod' arithmetic operation.
    264          *********************************************************************************************************
    265          */
    266          

   \                                 In  segment CODE, align 1, keep-with-next
    267          void  Mem_Set (void        *pmem,
   \                     Mem_Set:
    268                         CPU_INT08U   data_val,
    269                         CPU_SIZE_T   size)
    270          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000 C3                    PUSH      BC                 ;; 1 cycle
   \   000001 C1                    PUSH      AX                 ;; 1 cycle
   \   000002                       ; Auto size: 10
   \   000002 2008                  SUBW      SP, #0x8           ;; 1 cycle
    271              CPU_SIZE_T   size_rem;
    272              CPU_ALIGN    data_align;
    273              CPU_ALIGN   *pmem_align;
    274              CPU_INT08U  *pmem_08;
    275              CPU_DATA     mem_align_mod;
    276              CPU_DATA     i;
    277          
    278          
    279          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    280              if (size < 1) {                                             /* See Note #1.                                         */
   \   000004 35                    XCHW      AX, DE             ;; 1 cycle
   \   000005 440000                CMPW      AX, #0x0           ;; 1 cycle
   \   000008 35                    XCHW      AX, DE             ;; 1 cycle
   \   000009 DD75                  BZ        ??Mem_Cmp_0        ;; 4 cycles
   \   00000B                       ; ------------------------------------- Block: 10 cycles
    281                  return;
    282              }
    283              if (pmem == (void *)0) {
   \   00000B 440000                CMPW      AX, #0x0           ;; 1 cycle
   \   00000E DD70                  BZ        ??Mem_Cmp_0        ;; 4 cycles
   \   000010                       ; ------------------------------------- Block: 5 cycles
    284                  return;
    285              }
    286          #endif
    287          
    288          
    289              data_align = 0u;
   \   000010 F6                    CLRW      AX                 ;; 1 cycle
   \   000011 B804                  MOVW      [SP+0x04], AX      ;; 1 cycle
    290              for (i = 0u; i < sizeof(CPU_ALIGN); i++) {                  /* Fill each data_align octet with data val.            */
   \   000013 5202                  MOV       C, #0x2            ;; 1 cycle
   \   000015                       ; ------------------------------------- Block: 3 cycles
    291                  data_align <<=  DEF_OCTET_NBR_BITS;
    292                  data_align  |= (CPU_ALIGN)data_val;
   \                     ??Mem_Set_0:
   \   000015 63                    MOV       A, B               ;; 1 cycle
   \   000016 76                    MOV       L, A               ;; 1 cycle
   \   000017 A804                  MOVW      AX, [SP+0x04]      ;; 1 cycle
   \   000019 318D                  SHLW      AX, 0x8            ;; 1 cycle
   \   00001B 08                    XCH       A, X               ;; 1 cycle
   \   00001C 616E                  OR        A, L               ;; 1 cycle
   \   00001E 08                    XCH       A, X               ;; 1 cycle
   \   00001F B804                  MOVW      [SP+0x04], AX      ;; 1 cycle
    293              }
   \   000021 92                    DEC       C                  ;; 1 cycle
   \   000022 DFF1                  BNZ       ??Mem_Set_0        ;; 4 cycles
   \   000024                       ; ------------------------------------- Block: 13 cycles
    294          
    295              size_rem      =  size;
    296              mem_align_mod = (CPU_INT08U)((CPU_ADDR)pmem % sizeof(CPU_ALIGN));   /* See Note #3.                                 */
   \   000024 A808                  MOVW      AX, [SP+0x08]      ;; 1 cycle
   \   000026 60                    MOV       A, X               ;; 1 cycle
   \   000027 5C01                  AND       A, #0x1            ;; 1 cycle
   \   000029 70                    MOV       X, A               ;; 1 cycle
   \   00002A F1                    CLRB      A                  ;; 1 cycle
   \   00002B B806                  MOVW      [SP+0x06], AX      ;; 1 cycle
    297          
    298              pmem_08 = (CPU_INT08U *)pmem;
   \   00002D A808                  MOVW      AX, [SP+0x08]      ;; 1 cycle
   \   00002F B800                  MOVW      [SP], AX           ;; 1 cycle
    299              if (mem_align_mod != 0u) {                                  /* If leading octets avail,                   ...       */
   \   000031 AEF8                  MOVW      AX, SP             ;; 1 cycle
   \   000033 040600                ADDW      AX, #0x6           ;; 1 cycle
   \   000036 16                    MOVW      HL, AX             ;; 1 cycle
   \   000037 31851F                BF        [HL].0, ??Mem_Cmp_1  ;; 5 cycles
   \   00003A                       ; ------------------------------------- Block: 16 cycles
    300                  i = mem_align_mod;
   \   00003A A806                  MOVW      AX, [SP+0x06]      ;; 1 cycle
   \   00003C B802                  MOVW      [SP+0x02], AX      ;; 1 cycle
   \   00003E                       ; ------------------------------------- Block: 2 cycles
    301                  while ((size_rem > 0) &&                                /* ... start mem buf fill with leading octets ...       */
    302                         (i        < sizeof(CPU_ALIGN ))) {               /* ... until next CPU_ALIGN word boundary.              */
    303                     *pmem_08++ = data_val;
   \                     ??Mem_Set_1:
   \   00003E A800                  MOVW      AX, [SP]           ;; 1 cycle
   \   000040 16                    MOVW      HL, AX             ;; 1 cycle
   \   000041 63                    MOV       A, B               ;; 1 cycle
   \   000042 9B                    MOV       [HL], A            ;; 1 cycle
   \   000043 17                    MOVW      AX, HL             ;; 1 cycle
   \   000044 A1                    INCW      AX                 ;; 1 cycle
   \   000045 B800                  MOVW      [SP], AX           ;; 1 cycle
    304                      size_rem -= sizeof(CPU_INT08U);
   \   000047 B5                    DECW      DE                 ;; 1 cycle
    305                      i++;
   \   000048 A802                  MOVW      AX, [SP+0x02]      ;; 1 cycle
   \   00004A A1                    INCW      AX                 ;; 1 cycle
   \   00004B B802                  MOVW      [SP+0x02], AX      ;; 1 cycle
    306                  }
   \   00004D 35                    XCHW      AX, DE             ;; 1 cycle
   \   00004E 440000                CMPW      AX, #0x0           ;; 1 cycle
   \   000051 35                    XCHW      AX, DE             ;; 1 cycle
   \   000052 DD05                  BZ        ??Mem_Cmp_1        ;; 4 cycles
   \   000054                       ; ------------------------------------- Block: 18 cycles
   \   000054 440200                CMPW      AX, #0x2           ;; 1 cycle
   \   000057 DCE5                  BC        ??Mem_Set_1        ;; 4 cycles
   \   000059                       ; ------------------------------------- Block: 5 cycles
    307              }
    308          
    309              pmem_align = (CPU_ALIGN *)pmem_08;                          /* See Note #2a.                                        */
   \                     ??Mem_Cmp_1:
   \   000059 A800                  MOVW      AX, [SP]           ;; 1 cycle
   \   00005B 16                    MOVW      HL, AX             ;; 1 cycle
   \   00005C EF07                  BR        S:??Mem_Cmp_2      ;; 3 cycles
   \   00005E                       ; ------------------------------------- Block: 5 cycles
    310              while (size_rem >= sizeof(CPU_ALIGN)) {                     /* While mem buf aligned on CPU_ALIGN word boundaries,  */
    311                 *pmem_align++ = data_align;                              /* ... fill mem buf with    CPU_ALIGN-sized data.       */
   \                     ??Mem_Set_2:
   \   00005E A804                  MOVW      AX, [SP+0x04]      ;; 1 cycle
   \   000060 BB                    MOVW      [HL], AX           ;; 1 cycle
   \   000061 A7                    INCW      HL                 ;; 1 cycle
   \   000062 A7                    INCW      HL                 ;; 1 cycle
    312                  size_rem    -= sizeof(CPU_ALIGN);
   \   000063 B5                    DECW      DE                 ;; 1 cycle
   \   000064 B5                    DECW      DE                 ;; 1 cycle
   \   000065                       ; ------------------------------------- Block: 6 cycles
    313              }
   \                     ??Mem_Cmp_2:
   \   000065 15                    MOVW      AX, DE             ;; 1 cycle
   \   000066 440200                CMPW      AX, #0x2           ;; 1 cycle
   \   000069 DEF3                  BNC       ??Mem_Set_2        ;; 4 cycles
   \   00006B                       ; ------------------------------------- Block: 6 cycles
    314          
    315              pmem_08 = (CPU_INT08U *)pmem_align;
   \   00006B 17                    MOVW      AX, HL             ;; 1 cycle
   \   00006C B800                  MOVW      [SP], AX           ;; 1 cycle
   \   00006E EF0A                  BR        S:??Mem_Cmp_3      ;; 3 cycles
   \   000070                       ; ------------------------------------- Block: 5 cycles
    316              while (size_rem > 0) {                                      /* Finish mem buf fill with trailing octets.            */
    317                 *pmem_08++   = data_val;
   \                     ??Mem_Set_3:
   \   000070 A800                  MOVW      AX, [SP]           ;; 1 cycle
   \   000072 16                    MOVW      HL, AX             ;; 1 cycle
   \   000073 63                    MOV       A, B               ;; 1 cycle
   \   000074 9B                    MOV       [HL], A            ;; 1 cycle
   \   000075 17                    MOVW      AX, HL             ;; 1 cycle
   \   000076 A1                    INCW      AX                 ;; 1 cycle
   \   000077 B800                  MOVW      [SP], AX           ;; 1 cycle
    318                  size_rem   -= sizeof(CPU_INT08U);
   \   000079 B5                    DECW      DE                 ;; 1 cycle
   \   00007A                       ; ------------------------------------- Block: 8 cycles
    319              }
   \                     ??Mem_Cmp_3:
   \   00007A 15                    MOVW      AX, DE             ;; 1 cycle
   \   00007B 440000                CMPW      AX, #0x0           ;; 1 cycle
   \   00007E DFF0                  BNZ       ??Mem_Set_3        ;; 4 cycles
   \   000080                       ; ------------------------------------- Block: 6 cycles
    320          }
   \                     ??Mem_Cmp_0:
   \   000080 100A                  ADDW      SP, #0xA           ;; 1 cycle
   \   000082 C2                    POP       BC                 ;; 1 cycle
   \   000083 D7                    RET                          ;; 6 cycles
   \   000084                       ; ------------------------------------- Block: 8 cycles
   \   000084                       ; ------------------------------------- Total: 116 cycles
   \   000084                       REQUIRE ?CLRL78_V1_0_L00
    321          
    322          
    323          /*$PAGE*/
    324          /*
    325          *********************************************************************************************************
    326          *                                             Mem_Copy()
    327          *
    328          * Description : Copy data octets from one memory buffer to another memory buffer.
    329          *
    330          * Argument(s) : pdest       Pointer to destination memory buffer.
    331          *
    332          *               psrc        Pointer to source      memory buffer.
    333          *
    334          *               size        Number of data buffer octets to copy (see Note #1).
    335          *
    336          * Return(s)   : none.
    337          *
    338          * Caller(s)   : Application.
    339          *
    340          * Note(s)     : (1) Null copies allowed (i.e. zero-length copies).
    341          *
    342          *               (2) Memory buffers NOT checked for overlapping.
    343          *
    344          *                   (a) IEEE Std 1003.1, 2004 Edition, Section 'memcpy() : DESCRIPTION' states that "if
    345          *                       copying takes place between objects that overlap, the behavior is undefined".
    346          *
    347          *                   (b) However, data octets from a source memory buffer at a higher address value SHOULD
    348          *                       successfully copy to a destination memory buffer at a lower  address value even
    349          *                       if any octets of the memory buffers overlap as long as no individual, atomic CPU
    350          *                       word copy overlaps.
    351          *
    352          *                       Since Mem_Copy() performs the data octet copy via 'CPU_ALIGN'-sized words &/or
    353          *                       octets; & since 'CPU_ALIGN'-sized words MUST be accessed on word-aligned addresses
    354          *                       (see Note #3b), neither 'CPU_ALIGN'-sized words nor octets at unique addresses can
    355          *                       ever overlap.
    356          *
    357          *                       Therefore, Mem_Copy() SHOULD be able to successfully copy overlapping memory
    358          *                       buffers as long as the source memory buffer is at a higher address value than the
    359          *                       destination memory buffer.
    360          *
    361          *               (3) For best CPU performance, optimized to copy data buffer using 'CPU_ALIGN'-sized data
    362          *                   words.
    363          *
    364          *                   (a) Since many word-aligned processors REQUIRE that multi-octet words be accessed on
    365          *                       word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on 'CPU_ALIGN'd
    366          *                       addresses.
    367          *
    368          *               (4) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
    369          *                   address boundary.
    370          *
    371          *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus
    372          *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
    373          *                  'mem_align_mod' arithmetic operation.
    374          *********************************************************************************************************
    375          */
    376          /*$PAGE*/
    377          #if (LIB_MEM_CFG_OPTIMIZE_ASM_EN != DEF_ENABLED)
    378          void  Mem_Copy (       void        *pdest,
    379                          const  void        *psrc,
    380                                 CPU_SIZE_T   size)
    381          {
    382                     CPU_SIZE_T    size_rem;
    383                     CPU_ALIGN    *pmem_align_dest;
    384              const  CPU_ALIGN    *pmem_align_src;
    385                     CPU_INT08U   *pmem_08_dest;
    386              const  CPU_INT08U   *pmem_08_src;
    387                     CPU_DATA      i;
    388                     CPU_DATA      mem_align_mod_dest;
    389                     CPU_DATA      mem_align_mod_src;
    390                     CPU_BOOLEAN   mem_aligned;
    391          
    392          
    393          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    394              if (size < 1) {                                             /* See Note #1.                                         */
    395                  return;
    396              }
    397              if (pdest == (void *)0) {
    398                  return;
    399              }
    400              if (psrc  == (void *)0) {
    401                  return;
    402              }
    403          #endif
    404          
    405          
    406              size_rem           =  size;
    407          
    408              pmem_08_dest       = (      CPU_INT08U *)pdest;
    409              pmem_08_src        = (const CPU_INT08U *)psrc;
    410                                                                          /* See Note #4.                                         */
    411              mem_align_mod_dest = (CPU_INT08U)((CPU_ADDR)pmem_08_dest % sizeof(CPU_ALIGN));
    412              mem_align_mod_src  = (CPU_INT08U)((CPU_ADDR)pmem_08_src  % sizeof(CPU_ALIGN));
    413          
    414              mem_aligned        = (mem_align_mod_dest == mem_align_mod_src) ? DEF_YES : DEF_NO;
    415          
    416              if (mem_aligned == DEF_YES) {                               /* If mem bufs' alignment offset equal, ...             */
    417                                                                          /* ... optimize copy for mem buf alignment.             */
    418                  if (mem_align_mod_dest != 0u) {                         /* If leading octets avail,                   ...       */
    419                      i = mem_align_mod_dest;
    420                      while ((size_rem   >  0) &&                         /* ... start mem buf copy with leading octets ...       */
    421                             (i          <  sizeof(CPU_ALIGN ))) {        /* ... until next CPU_ALIGN word boundary.              */
    422                         *pmem_08_dest++ = *pmem_08_src++;
    423                          size_rem      -=  sizeof(CPU_INT08U);
    424                          i++;
    425                      }
    426                  }
    427          
    428                  pmem_align_dest = (      CPU_ALIGN *)pmem_08_dest;      /* See Note #3a.                                        */
    429                  pmem_align_src  = (const CPU_ALIGN *)pmem_08_src;
    430                  while (size_rem      >=  sizeof(CPU_ALIGN)) {           /* While mem bufs aligned on CPU_ALIGN word boundaries, */
    431                     *pmem_align_dest++ = *pmem_align_src++;              /* ... copy psrc to pdest with CPU_ALIGN-sized words.   */
    432                      size_rem         -=  sizeof(CPU_ALIGN);
    433                  }
    434          
    435                  pmem_08_dest = (      CPU_INT08U *)pmem_align_dest;
    436                  pmem_08_src  = (const CPU_INT08U *)pmem_align_src;
    437              }
    438          
    439              while (size_rem > 0) {                                      /* For unaligned mem bufs or trailing octets, ...       */
    440                 *pmem_08_dest++ = *pmem_08_src++;                        /* ... copy psrc to pdest by octets.                    */
    441                  size_rem      -=  sizeof(CPU_INT08U);
    442              }
    443          }
    444          #endif
    445          
    446          
    447          /*$PAGE*/
    448          /*
    449          *********************************************************************************************************
    450          *                                              Mem_Cmp()
    451          *
    452          * Description : Verify that ALL data octets in two memory buffers are identical in sequence.
    453          *
    454          * Argument(s) : p1_mem      Pointer to first  memory buffer.
    455          *
    456          *               p2_mem      Pointer to second memory buffer.
    457          *
    458          *               size        Number of data buffer octets to compare (see Note #1).
    459          *
    460          * Return(s)   : DEF_YES, if 'size' number of data octets are identical in both memory buffers.
    461          *
    462          *               DEF_NO,  otherwise.
    463          *
    464          * Caller(s)   : Application.
    465          *
    466          * Note(s)     : (1) Null compares allowed (i.e. zero-length compares); 'DEF_YES' returned to indicate
    467          *                   identical null compare.
    468          *
    469          *               (2) Many memory buffer comparisons vary ONLY in the least significant octets -- e.g.
    470          *                   network address buffers.  Consequently, memory buffer comparison is more efficient
    471          *                   if the comparison starts from the end of the memory buffers which will abort sooner
    472          *                   on dissimilar memory buffers that vary only in the least significant octets.
    473          *
    474          *               (3) For best CPU performance, optimized to compare data buffers using 'CPU_ALIGN'-sized
    475          *                   data words.
    476          *
    477          *                   (a) Since many word-aligned processors REQUIRE that multi-octet words be accessed on
    478          *                       word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on 'CPU_ALIGN'd
    479          *                       addresses.
    480          *
    481          *               (4) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
    482          *                   address boundary.
    483          *
    484          *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus
    485          *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
    486          *                  'mem_align_mod' arithmetic operation.
    487          *********************************************************************************************************
    488          */
    489          /*$PAGE*/

   \                                 In  segment CODE, align 1, keep-with-next
    490          CPU_BOOLEAN  Mem_Cmp (const  void        *p1_mem,
   \                     Mem_Cmp:
    491                                const  void        *p2_mem,
    492                                       CPU_SIZE_T   size)
    493          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000 C3                    PUSH      BC                 ;; 1 cycle
   \   000001                       ; Auto size: 10
   \   000001 2008                  SUBW      SP, #0x8           ;; 1 cycle
   \   000003 16                    MOVW      HL, AX             ;; 1 cycle
    494                     CPU_SIZE_T    size_rem;
    495                     CPU_ALIGN    *p1_mem_align;
    496                     CPU_ALIGN    *p2_mem_align;
    497              const  CPU_INT08U   *p1_mem_08;
    498              const  CPU_INT08U   *p2_mem_08;
    499                     CPU_DATA      i;
    500                     CPU_DATA      mem_align_mod_1;
    501                     CPU_DATA      mem_align_mod_2;
    502                     CPU_BOOLEAN   mem_aligned;
    503                     CPU_BOOLEAN   mem_cmp;
    504          
    505          
    506              if (size < 1) {                                             /* See Note #1.                                         */
   \   000004 35                    XCHW      AX, DE             ;; 1 cycle
   \   000005 F7                    CLRW      BC                 ;; 1 cycle
   \   000006 43                    CMPW      AX, BC             ;; 1 cycle
   \   000007 35                    XCHW      AX, DE             ;; 1 cycle
   \   000008 DF04                  BNZ       ??Mem_Cmp_4        ;; 4 cycles
   \   00000A                       ; ------------------------------------- Block: 11 cycles
    507                  return (DEF_YES);
   \   00000A E1                    ONEB      A                  ;; 1 cycle
   \   00000B ED....                BR        N:??Mem_Cmp_5      ;; 3 cycles
   \   00000E                       ; ------------------------------------- Block: 4 cycles
    508              }
    509              if (p1_mem == (void *)0) {
   \                     ??Mem_Cmp_4:
   \   00000E 440000                CMPW      AX, #0x0           ;; 1 cycle
   \   000011 DD07                  BZ        ??Mem_Cmp_6        ;; 4 cycles
   \   000013                       ; ------------------------------------- Block: 5 cycles
    510                  return (DEF_NO);
    511              }
    512              if (p2_mem == (void *)0) {
   \   000013 A808                  MOVW      AX, [SP+0x08]      ;; 1 cycle
   \   000015 440000                CMPW      AX, #0x0           ;; 1 cycle
   \   000018 DF04                  BNZ       ??Mem_Cmp_7        ;; 4 cycles
   \   00001A                       ; ------------------------------------- Block: 6 cycles
    513                  return (DEF_NO);
   \                     ??Mem_Cmp_6:
   \   00001A F1                    CLRB      A                  ;; 1 cycle
   \   00001B ED....                BR        N:??Mem_Cmp_5      ;; 3 cycles
   \   00001E                       ; ------------------------------------- Block: 4 cycles
    514              }
    515          
    516          
    517              mem_cmp         =  DEF_YES;                                 /* Assume mem bufs are identical until cmp fails.       */
   \                     ??Mem_Cmp_7:
   \   00001E E1                    ONEB      A                  ;; 1 cycle
   \   00001F 9800                  MOV       [SP], A            ;; 1 cycle
    518              size_rem        =  size;
   \   000021 C5                    PUSH      DE                 ;; 1 cycle
   \   000022 C2                    POP       BC                 ;; 1 cycle
    519                                                                          /* Start @ end of mem bufs (see Note #2).               */
    520              p1_mem_08       = (const CPU_INT08U *)p1_mem + size;
   \   000023 17                    MOVW      AX, HL             ;; 1 cycle
   \   000024 05                    ADDW      AX, DE             ;; 1 cycle
   \   000025 B802                  MOVW      [SP+0x02], AX      ;; 1 cycle
    521              p2_mem_08       = (const CPU_INT08U *)p2_mem + size;
   \   000027 C5                    PUSH      DE                 ;; 1 cycle
   \   000028 C6                    POP       HL                 ;; 1 cycle
   \   000029 A808                  MOVW      AX, [SP+0x08]      ;; 1 cycle
   \   00002B 07                    ADDW      AX, HL             ;; 1 cycle
   \   00002C 14                    MOVW      DE, AX             ;; 1 cycle
    522                                                                          /* See Note #4.                                         */
    523              mem_align_mod_1 = (CPU_INT08U)((CPU_ADDR)p1_mem_08 % sizeof(CPU_ALIGN));
   \   00002D A802                  MOVW      AX, [SP+0x02]      ;; 1 cycle
   \   00002F 60                    MOV       A, X               ;; 1 cycle
   \   000030 5C01                  AND       A, #0x1            ;; 1 cycle
   \   000032 70                    MOV       X, A               ;; 1 cycle
   \   000033 F1                    CLRB      A                  ;; 1 cycle
   \   000034 B806                  MOVW      [SP+0x06], AX      ;; 1 cycle
    524              mem_align_mod_2 = (CPU_INT08U)((CPU_ADDR)p2_mem_08 % sizeof(CPU_ALIGN));
    525          
    526              mem_aligned     = (mem_align_mod_1 == mem_align_mod_2) ? DEF_YES : DEF_NO;
   \   000036 AEF8                  MOVW      AX, SP             ;; 1 cycle
   \   000038 040600                ADDW      AX, #0x6           ;; 1 cycle
   \   00003B 16                    MOVW      HL, AX             ;; 1 cycle
   \   00003C 8806                  MOV       A, [SP+0x06]       ;; 1 cycle
   \   00003E 70                    MOV       X, A               ;; 1 cycle
   \   00003F 64                    MOV       A, E               ;; 1 cycle
   \   000040 5C01                  AND       A, #0x1            ;; 1 cycle
   \   000042 6140                  CMP       X, A               ;; 1 cycle
   \   000044 DF69                  BNZ       ??Mem_Cmp_8        ;; 4 cycles
   \   000046                       ; ------------------------------------- Block: 30 cycles
    527          
    528              if (mem_aligned == DEF_YES) {                               /* If mem bufs' alignment offset equal, ...             */
    529                                                                          /* ... optimize cmp for mem buf alignment.              */
    530                  if (mem_align_mod_1 != 0u) {                            /* If trailing octets avail,                  ...       */
   \   000046 31852B                BF        [HL].0, ??Mem_Cmp_9  ;; 5 cycles
   \   000049                       ; ------------------------------------- Block: 5 cycles
    531                      i = mem_align_mod_1;
   \   000049 A806                  MOVW      AX, [SP+0x06]      ;; 1 cycle
   \   00004B B804                  MOVW      [SP+0x04], AX      ;; 1 cycle
   \   00004D                       ; ------------------------------------- Block: 2 cycles
    532                      while ((mem_cmp == DEF_YES) &&                      /* ... cmp mem bufs while identical &         ...       */
    533                             (size_rem > 0)       &&                      /* ... start mem buf cmp with trailing octets ...       */
    534                             (i        > 0)) {                            /* ... until next CPU_ALIGN word boundary.              */
    535                          p1_mem_08--;
   \                     ??Mem_Cmp_10:
   \   00004D A802                  MOVW      AX, [SP+0x02]      ;; 1 cycle
   \   00004F B1                    DECW      AX                 ;; 1 cycle
   \   000050 B802                  MOVW      [SP+0x02], AX      ;; 1 cycle
    536                          p2_mem_08--;
   \   000052 B5                    DECW      DE                 ;; 1 cycle
    537                          if (*p1_mem_08 != *p2_mem_08) {                 /* If ANY data octet(s) NOT identical, cmp fails.       */
   \   000053 16                    MOVW      HL, AX             ;; 1 cycle
   \   000054 89                    MOV       A, [DE]            ;; 1 cycle
   \   000055 4D                    CMP       A, [HL]            ;; 1 cycle
   \   000056 DD03                  BZ        ??Mem_Cmp_11       ;; 4 cycles
   \   000058                       ; ------------------------------------- Block: 11 cycles
    538                               mem_cmp = DEF_NO;
   \   000058 F1                    CLRB      A                  ;; 1 cycle
   \   000059 9800                  MOV       [SP], A            ;; 1 cycle
   \   00005B                       ; ------------------------------------- Block: 2 cycles
    539                          }
    540                          size_rem -= sizeof(CPU_INT08U);
   \                     ??Mem_Cmp_11:
   \   00005B B3                    DECW      BC                 ;; 1 cycle
    541                          i--;
   \   00005C A804                  MOVW      AX, [SP+0x04]      ;; 1 cycle
   \   00005E B1                    DECW      AX                 ;; 1 cycle
   \   00005F B804                  MOVW      [SP+0x04], AX      ;; 1 cycle
    542                      }
   \   000061 AEF8                  MOVW      AX, SP             ;; 1 cycle
   \   000063 16                    MOVW      HL, AX             ;; 1 cycle
   \   000064 318556                BF        [HL].0, ??Mem_Cmp_12  ;; 5 cycles
   \   000067                       ; ------------------------------------- Block: 11 cycles
   \   000067 13                    MOVW      AX, BC             ;; 1 cycle
   \   000068 F7                    CLRW      BC                 ;; 1 cycle
   \   000069 43                    CMPW      AX, BC             ;; 1 cycle
   \   00006A 12                    MOVW      BC, AX             ;; 1 cycle
   \   00006B DD07                  BZ        ??Mem_Cmp_9        ;; 4 cycles
   \   00006D                       ; ------------------------------------- Block: 8 cycles
   \   00006D A804                  MOVW      AX, [SP+0x04]      ;; 1 cycle
   \   00006F 440000                CMPW      AX, #0x0           ;; 1 cycle
   \   000072 DFD9                  BNZ       ??Mem_Cmp_10       ;; 4 cycles
   \   000074                       ; ------------------------------------- Block: 6 cycles
    543                  }
    544          
    545                  if (mem_cmp == DEF_YES) {                               /* If cmp still identical, cmp aligned mem bufs.        */
    546                      p1_mem_align = (CPU_ALIGN *)p1_mem_08;              /* See Note #3a.                                        */
   \                     ??Mem_Cmp_9:
   \   000074 A802                  MOVW      AX, [SP+0x02]      ;; 1 cycle
   \   000076 B804                  MOVW      [SP+0x04], AX      ;; 1 cycle
    547                      p2_mem_align = (CPU_ALIGN *)p2_mem_08;
   \   000078 EF02                  BR        S:??Mem_Cmp_13     ;; 3 cycles
   \   00007A                       ; ------------------------------------- Block: 5 cycles
    548          
    549                      while ((mem_cmp  == DEF_YES) &&                     /* Cmp mem bufs while identical & ...                   */
    550                             (size_rem >= sizeof(CPU_ALIGN))) {           /* ... mem bufs aligned on CPU_ALIGN word boundaries.   */
    551                          p1_mem_align--;
    552                          p2_mem_align--;
    553                          if (*p1_mem_align != *p2_mem_align) {           /* If ANY data octet(s) NOT identical, cmp fails.       */
    554                               mem_cmp = DEF_NO;
    555                          }
    556                          size_rem -= sizeof(CPU_ALIGN);
   \                     ??Mem_Cmp_14:
   \   00007A B3                    DECW      BC                 ;; 1 cycle
   \   00007B B3                    DECW      BC                 ;; 1 cycle
   \   00007C                       ; ------------------------------------- Block: 2 cycles
   \                     ??Mem_Cmp_13:
   \   00007C AEF8                  MOVW      AX, SP             ;; 1 cycle
   \   00007E 16                    MOVW      HL, AX             ;; 1 cycle
   \   00007F 31851D                BF        [HL].0, ??Mem_Cmp_15  ;; 5 cycles
   \   000082                       ; ------------------------------------- Block: 7 cycles
   \   000082 13                    MOVW      AX, BC             ;; 1 cycle
   \   000083 440200                CMPW      AX, #0x2           ;; 1 cycle
   \   000086 DC17                  BC        ??Mem_Cmp_15       ;; 4 cycles
   \   000088                       ; ------------------------------------- Block: 6 cycles
   \   000088 A804                  MOVW      AX, [SP+0x04]      ;; 1 cycle
   \   00008A B1                    DECW      AX                 ;; 1 cycle
   \   00008B B1                    DECW      AX                 ;; 1 cycle
   \   00008C B804                  MOVW      [SP+0x04], AX      ;; 1 cycle
   \   00008E B5                    DECW      DE                 ;; 1 cycle
   \   00008F B5                    DECW      DE                 ;; 1 cycle
   \   000090 A9                    MOVW      AX, [DE]           ;; 1 cycle
   \   000091 C1                    PUSH      AX                 ;; 1 cycle
   \   000092 A806                  MOVW      AX, [SP+0x06]      ;; 1 cycle
   \   000094 16                    MOVW      HL, AX             ;; 1 cycle
   \   000095 AB                    MOVW      AX, [HL]           ;; 1 cycle
   \   000096 C6                    POP       HL                 ;; 1 cycle
   \   000097 47                    CMPW      AX, HL             ;; 1 cycle
   \   000098 DDE0                  BZ        ??Mem_Cmp_14       ;; 4 cycles
   \   00009A                       ; ------------------------------------- Block: 17 cycles
   \   00009A F1                    CLRB      A                  ;; 1 cycle
   \   00009B 9800                  MOV       [SP], A            ;; 1 cycle
   \   00009D B3                    DECW      BC                 ;; 1 cycle
   \   00009E B3                    DECW      BC                 ;; 1 cycle
   \   00009F                       ; ------------------------------------- Block: 4 cycles
    557                      }
    558          
    559                      p1_mem_08 = (CPU_INT08U *)p1_mem_align;
   \                     ??Mem_Cmp_15:
   \   00009F A804                  MOVW      AX, [SP+0x04]      ;; 1 cycle
   \   0000A1 B802                  MOVW      [SP+0x02], AX      ;; 1 cycle
    560                      p2_mem_08 = (CPU_INT08U *)p2_mem_align;
   \   0000A3                       ; ------------------------------------- Block: 2 cycles
    561                  }
    562              }
    563          
    564              while ((mem_cmp == DEF_YES) &&                              /* Cmp mem bufs while identical ...                     */
    565                     (size_rem > 0)) {                                    /* ... for unaligned mem bufs or trailing octets.       */
   \                     ??Mem_Cmp_16:
   \   0000A3 AEF8                  MOVW      AX, SP             ;; 1 cycle
   \   0000A5 16                    MOVW      HL, AX             ;; 1 cycle
   \   0000A6 318514                BF        [HL].0, ??Mem_Cmp_12  ;; 5 cycles
   \   0000A9                       ; ------------------------------------- Block: 7 cycles
   \   0000A9 13                    MOVW      AX, BC             ;; 1 cycle
   \   0000AA F7                    CLRW      BC                 ;; 1 cycle
   \   0000AB 43                    CMPW      AX, BC             ;; 1 cycle
   \   0000AC 12                    MOVW      BC, AX             ;; 1 cycle
   \   0000AD DD0E                  BZ        ??Mem_Cmp_12       ;; 4 cycles
   \   0000AF                       ; ------------------------------------- Block: 8 cycles
    566                  p1_mem_08--;
   \                     ??Mem_Cmp_8:
   \   0000AF A802                  MOVW      AX, [SP+0x02]      ;; 1 cycle
   \   0000B1 B1                    DECW      AX                 ;; 1 cycle
   \   0000B2 B802                  MOVW      [SP+0x02], AX      ;; 1 cycle
    567                  p2_mem_08--;
   \   0000B4 B5                    DECW      DE                 ;; 1 cycle
    568                  if (*p1_mem_08 != *p2_mem_08) {                         /* If ANY data octet(s) NOT identical, cmp fails.       */
   \   0000B5 16                    MOVW      HL, AX             ;; 1 cycle
   \   0000B6 89                    MOV       A, [DE]            ;; 1 cycle
   \   0000B7 4D                    CMP       A, [HL]            ;; 1 cycle
   \   0000B8 DD08                  BZ        ??Mem_Cmp_17       ;; 4 cycles
   \   0000BA                       ; ------------------------------------- Block: 11 cycles
    569                       mem_cmp = DEF_NO;
   \   0000BA F1                    CLRB      A                  ;; 1 cycle
   \   0000BB 9800                  MOV       [SP], A            ;; 1 cycle
   \   0000BD                       ; ------------------------------------- Block: 2 cycles
    570                  }
    571                  size_rem -= sizeof(CPU_INT08U);
    572              }
    573          
    574              return (mem_cmp);
   \                     ??Mem_Cmp_12:
   \   0000BD 8800                  MOV       A, [SP]            ;; 1 cycle
   \   0000BF                       ; ------------------------------------- Block: 1 cycles
   \                     ??Mem_Cmp_5:
   \   0000BF 100A                  ADDW      SP, #0xA           ;; 1 cycle
   \   0000C1 D7                    RET                          ;; 6 cycles
   \   0000C2                       ; ------------------------------------- Block: 7 cycles
   \                     ??Mem_Cmp_17:
   \   0000C2 B3                    DECW      BC                 ;; 1 cycle
   \   0000C3 EFDE                  BR        S:??Mem_Cmp_16     ;; 3 cycles
   \   0000C5                       ; ------------------------------------- Block: 4 cycles
   \   0000C5                       ; ------------------------------------- Total: 188 cycles
   \   0000C5                       REQUIRE ?CLRL78_V1_0_L00
    575          }
    576          
    577          
    578          /*$PAGE*/
    579          /*
    580          *********************************************************************************************************
    581          *                                           Mem_HeapAlloc()
    582          *
    583          * Description : Allocate a memory block from the heap memory pool.
    584          *
    585          * Argument(s) : size            Size      of memory block to allocate (in octets).
    586          *
    587          *               align           Alignment of memory block to specific word boundary (in octets).
    588          *
    589          *               poctets_reqd    Optional pointer to a variable to ... :
    590          *
    591          *                                   (a) Return the number of octets required to successfully
    592          *                                           allocate the memory block, if any error(s);
    593          *                                   (b) Return 0, otherwise.
    594          *
    595          *               perr        Pointer to variable that will receive the return error code from this function :
    596          *
    597          *                               LIB_MEM_ERR_NONE                Memory block successfully returned.
    598          *                               LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory size.
    599          *                               LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory alignment.
    600          *                               LIB_MEM_ERR_HEAP_EMPTY          Heap segment empty; NOT enough available
    601          *                                                                   memory from heap.
    602          *                               LIB_MEM_ERR_HEAP_OVF            Requested memory overflows heap memory.
    603          *
    604          * Return(s)   : Pointer to memory block, if NO error(s).
    605          *
    606          *               Pointer to NULL,         otherwise.
    607          *
    608          * Caller(s)   : Application.
    609          *
    610          * Note(s)     : (1) Pointers to variables that return values MUST be initialized PRIOR to all other
    611          *                   validation or function handling in case of any error(s).
    612          *
    613          *               (2) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
    614          *********************************************************************************************************
    615          */
    616          /*$PAGE*/
    617          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
    618          void  *Mem_HeapAlloc (CPU_SIZE_T   size,
    619                                CPU_SIZE_T   align,
    620                                CPU_SIZE_T  *poctets_reqd,
    621                                LIB_ERR     *perr)
    622          {
    623              MEM_POOL    *pmem_pool_heap;
    624              void        *pmem_addr;
    625              void        *pmem_blk;
    626              CPU_SIZE_T   octets_reqd_unused;
    627              CPU_SIZE_T   size_rem;
    628              CPU_SIZE_T   size_req;
    629              CPU_SR_ALLOC();
    630          
    631          
    632          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
    633              if (perr == (LIB_ERR *)0) {
    634                  CPU_SW_EXCEPTION((void *)0);
    635              }
    636          #endif
    637          
    638                                                                              /* ------------ VALIDATE RTN OCTETS PTR ----------- */
    639              if (poctets_reqd == (CPU_SIZE_T *) 0) {                         /* If NOT avail, ...                                */
    640                  poctets_reqd  = (CPU_SIZE_T *)&octets_reqd_unused;          /* ... re-cfg NULL rtn ptr to unused local var.     */
    641                 (void)&octets_reqd_unused;                                   /* Prevent possible 'variable unused' warning.      */
    642              }
    643             *poctets_reqd = 0u;                                              /* Init octets req'd for err (see Note #1).         */
    644          
    645          
    646          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------ VALIDATE HEAP MEM ALLOC ----------- */
    647              if (size < 1) {
    648                 *perr = LIB_MEM_ERR_INVALID_MEM_SIZE;
    649                  return ((void *)0);
    650              }
    651          
    652              if (align < 1) {
    653                 *perr = LIB_MEM_ERR_INVALID_MEM_ALIGN;
    654                  return ((void *)0);
    655              }
    656          #endif
    657          
    658                                                                              /* -------------- ALLOC HEAP MEM BLK -------------- */
    659              pmem_pool_heap = &Mem_PoolHeap;
    660          
    661              CPU_CRITICAL_ENTER();
    662          
    663              pmem_addr = pmem_pool_heap->SegAddrNextAvail;
    664              size_rem  = pmem_pool_heap->SegSizeRem;
    665              size_req  = Mem_SegCalcTotSize(pmem_addr,
    666                                             1u,                              /* Calc alloc for single mem blk from heap.         */
    667                                             size,
    668                                             align);
    669          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    670              if (size_req < 1) {                                             /* If req'd size ovf, ...                           */
    671                  CPU_CRITICAL_EXIT();
    672                 *poctets_reqd = size;                                        /* ... rtn add'l heap size needed.                  */
    673                 *perr         = LIB_MEM_ERR_HEAP_OVF;
    674                  return ((void *)0);
    675              }
    676          #endif
    677          
    678              if (size_req > size_rem) {                                      /* If req'd size > rem heap size, ...               */
    679                  CPU_CRITICAL_EXIT();
    680                 *poctets_reqd = size_req - size_rem;                         /* ... rtn add'l heap size needed.                  */
    681                 *perr         = LIB_MEM_ERR_HEAP_EMPTY;
    682                  return ((void *)0);
    683              }
    684          
    685              pmem_blk = Mem_SegAlloc(pmem_pool_heap, size, align);
    686              if (pmem_blk == (void *)0) {                                    /* If mem blk NOT avail from heap, ...              */
    687                  CPU_CRITICAL_EXIT();
    688                 *poctets_reqd = size_req;                                    /* ... rtn add'l heap size needed.                  */
    689                 *perr         = LIB_MEM_ERR_HEAP_EMPTY;
    690                  return ((void *)0);
    691              }
    692          
    693              CPU_CRITICAL_EXIT();
    694          
    695             *perr =  LIB_MEM_ERR_NONE;
    696          
    697              return (pmem_blk);
    698          }
    699          #endif
    700          
    701          
    702          /*$PAGE*/
    703          /*
    704          *********************************************************************************************************
    705          *                                        Mem_HeapGetSizeRem()
    706          *
    707          * Description : Get remaining heap memory size available to allocate.
    708          *
    709          * Argument(s) : align       Desired word boundary alignment (in octets) to return remaining memory size from.
    710          *
    711          *               perr        Pointer to variable that will receive the return error code from this function :
    712          *
    713          *                                                               ---- RETURNED BY Mem_PoolGetSizeRem() : ----
    714          *                               LIB_MEM_ERR_NONE                Heap memory pool remaining size successfully
    715          *                                                                   returned.
    716          *                               LIB_MEM_ERR_NULL_PTR            Argument 'pmem_pool' passed a NULL pointer.
    717          *                               LIB_MEM_ERR_INVALID_POOL        Invalid memory pool type.
    718          *                               LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory alignment.
    719          *
    720          * Return(s)   : Remaining heap memory size (in octets), if NO error(s).
    721          *
    722          *               0,                                      otherwise.
    723          *
    724          * Caller(s)   : Application.
    725          *
    726          * Note(s)     : none.
    727          *********************************************************************************************************
    728          */
    729          
    730          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
    731          CPU_SIZE_T  Mem_HeapGetSizeRem (CPU_SIZE_T   align,
    732                                          LIB_ERR     *perr)
    733          {
    734              CPU_SIZE_T  size_rem;
    735          
    736          
    737              size_rem = Mem_SegGetSizeRem(&Mem_PoolHeap, align, perr);
    738          
    739              return (size_rem);
    740          }
    741          #endif
    742          
    743          
    744          /*$PAGE*/
    745          /*
    746          *********************************************************************************************************
    747          *                                         Mem_SegGetSizeRem()
    748          *
    749          * Description : Get memory pool's remaining segment size available to allocate.
    750          *
    751          * Argument(s) : pmem_pool   Pointer to a memory pool structure.
    752          *
    753          *               align       Desired word boundary alignment (in octets) to return remaining memory size from.
    754          *
    755          *               perr        Pointer to variable that will receive the return error code from this function :
    756          *
    757          *                               LIB_MEM_ERR_NONE                Memory segment remaining size successfully
    758          *                                                                   returned.
    759          *                               LIB_MEM_ERR_NULL_PTR            Argument 'pmem_pool' passed a NULL pointer.
    760          *                               LIB_MEM_ERR_INVALID_POOL        Invalid memory pool type.
    761          *                               LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory alignment.
    762          *
    763          * Return(s)   : Remaining memory segment size (in octets) [see Note #1], if NO error(s).
    764          *
    765          *               0,                                                       otherwise.
    766          *
    767          * Caller(s)   : Application.
    768          *
    769          * Note(s)     : (1) Remaining size of memory segment returned from either :
    770          *
    771          *                   (a) Segment's configured dedicated memory, if any
    772          *                   (b) Heap memory pool,                      otherwise
    773          *
    774          *               (2) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
    775          *********************************************************************************************************
    776          */
    777          /*$PAGE*/
    778          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
    779          CPU_SIZE_T  Mem_SegGetSizeRem (MEM_POOL    *pmem_pool,
    780                                         CPU_SIZE_T   align,
    781                                         LIB_ERR     *perr)
    782          {
    783              MEM_POOL    *pmem_seg;
    784              MEM_POOL    *pmem_seg_size;
    785              CPU_SIZE_T   size_rem;
    786              CPU_SIZE_T   size_rem_mod;
    787              CPU_SIZE_T   seg_addr_mod;
    788              CPU_ADDR     seg_addr;
    789              CPU_SR_ALLOC();
    790          
    791          
    792          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    793                                                                          /* --------------- VALIDATE RTN ERR PTR --------------- */
    794              if (perr == (LIB_ERR *)0) {
    795                  CPU_SW_EXCEPTION(0u);
    796              }
    797                                                                          /* ---------------- VALIDATE MEM ALIGN ---------------- */
    798              if (align < 1) {
    799                 *perr =  LIB_MEM_ERR_INVALID_MEM_ALIGN;
    800                  return (0u);
    801              }
    802                                                                          /* ---------------- VALIDATE MEM POOL ----------------- */
    803              if (pmem_pool == (MEM_POOL *)0) {                           /* Validate mem ptr.                                    */
    804                 *perr =  LIB_MEM_ERR_NULL_PTR;
    805                  return (0u);
    806              }
    807          #endif
    808          
    809              CPU_CRITICAL_ENTER();
    810          
    811          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    812              switch (pmem_pool->Type) {                                  /* Validate mem pool type.                              */
    813                  case LIB_MEM_TYPE_HEAP:
    814                  case LIB_MEM_TYPE_POOL:
    815                       break;
    816          
    817          
    818                  case LIB_MEM_TYPE_NONE:
    819                  default:
    820                       CPU_CRITICAL_EXIT();
    821                      *perr =  LIB_MEM_ERR_INVALID_POOL;
    822                       return (0u);                                       /* Prevent 'break NOT reachable' compiler warning.      */
    823              }
    824          #endif
    825          
    826                                                                          /* ------------- GET REM'ING MEM SEG SIZE ------------- */
    827              pmem_seg      =  pmem_pool->SegHeadPtr;                     /* Get mem pool's head seg.                             */
    828              pmem_seg_size = (pmem_seg->SegAddr != (void *)0)
    829                            ?  pmem_seg : &Mem_PoolHeap;                  /* See Note #1.                                         */
    830              size_rem      =  pmem_seg_size->SegSizeRem;                 /* Get mem seg's rem'ing mem size.                      */
    831              seg_addr      = (CPU_ADDR)pmem_seg_size->SegAddrNextAvail;
    832          
    833              CPU_CRITICAL_EXIT();
    834          
    835              if (align > 1) {                                            /* If align > 1 octet, ...                              */
    836                  seg_addr_mod  =  seg_addr % align;
    837                  size_rem_mod  = (seg_addr_mod > 0u) ? (align - seg_addr_mod) : 0u;
    838                  size_rem     -=  size_rem_mod;                          /* ... adj rem'ing size by offset to align'd seg addr.  */
    839              }
    840          
    841          
    842             *perr =  LIB_MEM_ERR_NONE;
    843          
    844              return (size_rem);
    845          }
    846          #endif
    847          
    848          
    849          /*$PAGE*/
    850          /*
    851          *********************************************************************************************************
    852          *                                            Mem_PoolClr()
    853          *
    854          * Description : Clear a memory pool (see Note #1).
    855          *
    856          * Argument(s) : pmem_pool   Pointer to a memory pool structure to clear (see Note #2).
    857          *
    858          *               perr        Pointer to variable that will receive the return error code from this function :
    859          *
    860          *                               LIB_MEM_ERR_NONE                Memory pool successfully cleared.
    861          *                               LIB_MEM_ERR_NULL_PTR            Argument 'pmem_pool' passed a NULL pointer.
    862          *
    863          * Return(s)   : none.
    864          *
    865          * Caller(s)   : Application,
    866          *               Mem_PoolCreate().
    867          *
    868          * Note(s)     : (1) (a) Mem_PoolClr() ONLY clears a memory pool structure's variables & should ONLY be
    869          *                       called to initialize a memory pool structure prior to calling Mem_PoolCreate().
    870          *
    871          *                   (b) Mem_PoolClr() does NOT deallocate memory from the memory pool or deallocate the
    872          *                       memory pool itself & MUST NOT be called after calling Mem_PoolCreate() since
    873          *                       this will likely corrupt the memory pool management.
    874          *
    875          *               (2) Assumes 'pmem_pool' points to a valid memory pool (if non-NULL).
    876          *********************************************************************************************************
    877          */
    878          
    879          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
    880          void  Mem_PoolClr (MEM_POOL  *pmem_pool,
    881                             LIB_ERR   *perr)
    882          {
    883          
    884          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* -------------- VALIDATE RTN ERR  PTR --------------- */
    885              if (perr == (LIB_ERR *)0) {
    886                  CPU_SW_EXCEPTION(;);
    887              }
    888          #endif
    889          
    890                                                                          /* -------------- VALIDATE MEM POOL PTR --------------- */
    891              if (pmem_pool == (MEM_POOL *)0) {
    892                 *perr = LIB_MEM_ERR_NULL_PTR;
    893                  return;
    894              }
    895          
    896          
    897              pmem_pool->Type             = (LIB_MEM_TYPE)LIB_MEM_TYPE_NONE;
    898              pmem_pool->SegHeadPtr       = (MEM_POOL   *)0;
    899              pmem_pool->SegPrevPtr       = (MEM_POOL   *)0;
    900              pmem_pool->SegNextPtr       = (MEM_POOL   *)0;
    901              pmem_pool->PoolPrevPtr      = (MEM_POOL   *)0;
    902              pmem_pool->PoolNextPtr      = (MEM_POOL   *)0;
    903              pmem_pool->PoolAddrStart    = (void       *)0;
    904              pmem_pool->PoolAddrEnd      = (void       *)0;
    905              pmem_pool->PoolPtrs         = (void      **)0;
    906              pmem_pool->PoolSize         = (CPU_SIZE_T  )0u;
    907              pmem_pool->BlkAlign         = (CPU_SIZE_T  )0u;
    908              pmem_pool->BlkSize          = (CPU_SIZE_T  )0u;
    909              pmem_pool->BlkNbr           = (CPU_SIZE_T  )0u;
    910              pmem_pool->BlkIx            = (MEM_POOL_IX )0u;
    911              pmem_pool->SegAddr          = (void       *)0;
    912              pmem_pool->SegAddrNextAvail = (void       *)0;
    913              pmem_pool->SegSizeTot       = (CPU_SIZE_T  )0u;
    914              pmem_pool->SegSizeRem       = (CPU_SIZE_T  )0u;
    915          
    916          
    917             *perr = LIB_MEM_ERR_NONE;
    918          }
    919          #endif
    920          
    921          
    922          /*$PAGE*/
    923          /*
    924          *********************************************************************************************************
    925          *                                          Mem_PoolCreate()
    926          *
    927          * Description : (1) Create a memory pool :
    928          *
    929          *                   (a) Create    memory pool from heap or dedicated memory
    930          *                   (b) Allocate  memory pool memory blocks
    931          *                   (c) Update    memory pool table
    932          *                   (d) Configure memory pool
    933          *
    934          *
    935          *               (2) Memory pools are indexed by the Memory Segments they use.
    936          *
    937          *                   (a) The memory pool table is composed by a two-dimensional list :
    938          *
    939          *                       (1) Memory segments manage the following memory segment/pool information :
    940          *
    941          *                           (A) Memory segment base           address
    942          *                           (B) Memory segment next available address
    943          *                           (C) Memory segment total     size
    944          *                           (D) Memory segment remaining size
    945          *
    946          *                       (2) Memory pools share memory from memory segments but do NOT manage any memory
    947          *                           segment information.  To access the memory segment information, the head
    948          *                           memory segment must be accessed via each memory pool's 'SegHeadPtr'.
    949          *
    950          *                   (b) In the diagram below, memory pools in vertical columns represent they share the same
    951          *                       memory segment for the memory blocks they have.  The heads of the memory pool are
    952          *                       linked horizontally to form a memory pool table.
    953          *
    954          *                       (1) 'Mem_PoolTbl' points to the head of the Memory Pool table.
    955          *
    956          *                       (2) Memory Pools' 'SegPrevPtr'  & 'SegNextPtr'  doubly-link each memory segment to
    957          *                           form the list of memory segments.
    958          *
    959          *                       (3) Memory Pools' 'PoolPrevPtr' & 'PoolNextPtr' doubly-link the  memory pools of
    960          *                           each memory segment.
    961          *
    962          *                   (c) New memory pools, which do not share a memory segment, are inserted in the Memory
    963          *                       Segments Primary List.  The point of insertion is such to keep ascended order by
    964          *                       memory segment base address.
    965          *
    966          *                   (d) Memory pool pointers to memory blocks 'PoolPtrs' must be allocated for each created
    967          *                       memory pool.  These pointers are stored in the memory pool heap segment 'Mem_PoolHeap'.
    968          *
    969          *                       (1) A memory pool can also have its memory blocks allocated from the memory pool heap.
    970          *                           'pmem_base_addr' must be set to NULL & 'mem_size' must be set to (0) to create the
    971          *                           memory pool.
    972          *
    973          *
    974          *                                        |                                                                 |
    975          *                                        |<----------------------- Memory Segments ----------------------->|
    976          *                                        |                         (see Note #2a1)                         |
    977          *
    978          *                                 Lowest Memory Segment                                      Highest Memory Segment
    979          *                                     Base Address                                                Base Address
    980          *                                    (see Note #2c)                                              (see Note #2c)
    981          *
    982          *                                           |             SegNextPtr             Heap Memory Pool       |
    983          *                                           |          (see Note #2b2)            (see Note #2d)        |
    984          *                                           |                     |                                     |
    985          *                                           v                     |                      |              v
    986          *                                                                 |                      v
    987          *        ---          Head of Memory     -------        -------   v    -------        -------        -------
    988          *         ^             Pool Table   --->|     |------->|     |------->|     |------->|     |------->|     |
    989          *         |          (see Note #2b1)     |     |        |     |        |     |        |  H  |        |     |
    990          *         |                              |     |<-------|     |<-------|     |<-------|  E  |<-------|     |
    991          *         |                              |     |        |     |   ^    |     |        |  A  |        |     |
    992          *         |                              |     |        |     |   |    |     |        |  P  |        |     |
    993          *         |                              |     |        |     |   |    |     |        |     |        |     |
    994          *         |                              -------        -------   |    -------        -------        -------
    995          *         |                                | ^                    |      | ^
    996          *         |                                | |            SegPrevPtr     | |
    997          *         |                                v |         (see Note #2b2)   v |
    998          *         |                              -------                       -------
    999          *                                        |     |                       |     |
   1000          *    Memory Pools                        |     |                       |     |
   1001          *  (see Note #2a2)                       |     |                       |     |
   1002          *                                        |     |                       |     |
   1003          *         |                              |     |                       |     |
   1004          *         |                              -------                       -------
   1005          *         |                                | ^
   1006          *         |               PoolNextPtr ---> | | <--- PoolPrevPtr
   1007          *         |             (see Note #2b3)    v |    (see Note #2b3)
   1008          *         |                              -------
   1009          *         |                              |     |
   1010          *         |                              |     |
   1011          *         |                              |     |
   1012          *         |                              |     |
   1013          *         v                              |     |
   1014          *        ---                             -------
   1015          *
   1016          *$PAGE*
   1017          * Argument(s) : pmem_pool           Pointer to a memory pool structure to create (see Note #3).
   1018          *
   1019          *               pmem_base_addr      Memory pool base address :
   1020          *
   1021          *                                       (a)     Null address    Memory pool allocated from general-purpose heap.
   1022          *                                       (b) Non-null address    Memory pool allocated from dedicated memory
   1023          *                                                                   specified by its base address.
   1024          *
   1025          *               mem_size            Size      of memory pool segment          (in octets).
   1026          *
   1027          *               blk_nbr             Number    of memory pool blocks to create.
   1028          *
   1029          *               blk_size            Size      of memory pool blocks to create (in octets).
   1030          *
   1031          *               blk_align           Alignment of memory pool blocks to specific word boundary (in octets).
   1032          *
   1033          *               poctets_reqd        Optional pointer to a variable to ... :
   1034          *
   1035          *                                       (a) Return the number of octets required to successfully
   1036          *                                               allocate the memory pool, if any error(s);
   1037          *                                       (b) Return 0, otherwise.
   1038          *
   1039          *               perr        Pointer to variable that will receive the return error code from this function :
   1040          *
   1041          *                               LIB_MEM_ERR_NONE                    Memory pool successfully created.
   1042          *
   1043          *                               LIB_MEM_ERR_HEAP_NOT_FOUND          Heap   segment NOT found.
   1044          *                               LIB_MEM_ERR_HEAP_EMPTY              Heap   segment empty; NOT enough available
   1045          *                                                                       memory from heap.
   1046          *                               LIB_MEM_ERR_HEAP_OVF                Requested memory overflows heap    memory.
   1047          *                               LIB_MEM_ERR_SEG_EMPTY               Memory segment empty; NOT enough available
   1048          *                                                                       memory from segment for memory pools.
   1049          *                               LIB_MEM_ERR_SEG_OVF                 Requested memory overflows segment memory.
   1050          *
   1051          *                               LIB_MEM_ERR_INVALID_SEG_SIZE        Invalid memory segment size.
   1052          *                               LIB_MEM_ERR_INVALID_SEG_OVERLAP     Memory segment overlaps other memory
   1053          *                                                                       segment(s) in memory pool table.
   1054          *                               LIB_MEM_ERR_INVALID_BLK_NBR         Invalid memory pool number of blocks.
   1055          *                               LIB_MEM_ERR_INVALID_BLK_SIZE        Invalid memory pool block size.
   1056          *                               LIB_MEM_ERR_INVALID_BLK_ALIGN       Invalid memory pool block alignment.
   1057          *
   1058          *                                                                   ------- RETURNED BY Mem_PoolClr() : -------
   1059          *                               LIB_MEM_ERR_NULL_PTR                Argument 'pmem_pool' passed a NULL pointer.
   1060          *
   1061          * Return(s)   : none.
   1062          *
   1063          * Caller(s)   : Application.
   1064          *
   1065          * Note(s)     : (3) Assumes 'pmem_pool' points to a valid memory pool (if non-NULL).
   1066          *
   1067          *               (4) Pointers to variables that return values MUST be initialized PRIOR to all other
   1068          *                   validation or function handling in case of any error(s).
   1069          *
   1070          *               (5) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
   1071          *********************************************************************************************************
   1072          */
   1073          /*$PAGE*/
   1074          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
   1075          void  Mem_PoolCreate (MEM_POOL          *pmem_pool,
   1076                                void              *pmem_base_addr,
   1077                                CPU_SIZE_T         mem_size,
   1078                                MEM_POOL_BLK_QTY   blk_nbr,
   1079                                CPU_SIZE_T         blk_size,
   1080                                CPU_SIZE_T         blk_align,
   1081                                CPU_SIZE_T        *poctets_reqd,
   1082                                LIB_ERR           *perr)
   1083          {
   1084              MEM_POOL           *pmem_pool_heap;
   1085              MEM_POOL           *pmem_pool_next;
   1086              MEM_POOL           *pmem_seg;
   1087              MEM_POOL           *pmem_seg_prev;
   1088              MEM_POOL           *pmem_seg_next;
   1089              void              **ppool_ptr;
   1090              void               *pmem_blk;
   1091              CPU_INT08U         *pmem_addr_ptrs;
   1092              CPU_INT08U         *pmem_addr_pool;
   1093              CPU_INT08U         *pmem_base_addr_start;
   1094              CPU_INT08U         *pmem_base_addr_end;
   1095              CPU_INT08U         *pmem_seg_addr_start;
   1096              CPU_INT08U         *pmem_seg_addr_end;
   1097              MEM_POOL_BLK_QTY    blk_rem;
   1098              CPU_SIZE_T          octets_reqd_unused;
   1099              CPU_SIZE_T          size_tot;
   1100              CPU_SIZE_T          size_tot_ptrs;
   1101              CPU_SIZE_T          size_tot_pool;
   1102              CPU_SIZE_T          size_rem;
   1103              CPU_SIZE_T          size_pool_ptrs;
   1104              CPU_SIZE_T          i;
   1105              CPU_SR_ALLOC();
   1106          
   1107          
   1108          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
   1109              if (perr == (LIB_ERR *)0) {
   1110                  CPU_SW_EXCEPTION(;);
   1111              }
   1112          #endif
   1113          
   1114                                                                              /* ------------ VALIDATE RTN OCTETS PTR ----------- */
   1115              if (poctets_reqd == (CPU_SIZE_T *) 0) {                         /* If NOT avail, ...                                */
   1116                  poctets_reqd  = (CPU_SIZE_T *)&octets_reqd_unused;          /* ... re-cfg NULL rtn ptr to unused local var.     */
   1117                 (void)&octets_reqd_unused;                                   /* Prevent possible 'variable unused' warning.      */
   1118              }
   1119             *poctets_reqd = 0u;                                              /* Init octets req'd for err (see Note #4).         */
   1120          
   1121          
   1122          
   1123              Mem_PoolClr(pmem_pool, perr);                                   /* Init mem pool     for err (see Note #4).         */
   1124              if (*perr != LIB_MEM_ERR_NONE) {
   1125                   return;
   1126              }
   1127          
   1128          
   1129                                                                              /* ----------- VALIDATE MEM POOL CREATE ----------- */
   1130          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1131              if (pmem_base_addr != (void *)0) {
   1132                  if (mem_size < 1) {
   1133                     *perr = LIB_MEM_ERR_INVALID_SEG_SIZE;
   1134                      return;
   1135                  }
   1136              }
   1137          
   1138              if (blk_nbr < 1) {
   1139                 *perr = LIB_MEM_ERR_INVALID_BLK_NBR;
   1140                  return;
   1141              }
   1142          
   1143              if (blk_size < 1) {
   1144                 *perr = LIB_MEM_ERR_INVALID_BLK_SIZE;
   1145                  return;
   1146              }
   1147          
   1148              if (blk_align < 1) {
   1149                 *perr = LIB_MEM_ERR_INVALID_BLK_ALIGN;
   1150                  return;
   1151              }
   1152          #endif
   1153          
   1154          
   1155                                                                              /* ------------ VALIDATE MEM POOL TBL ------------- */
   1156              if (Mem_PoolTbl == (MEM_POOL *)0) {
   1157                 *perr = LIB_MEM_ERR_HEAP_NOT_FOUND;
   1158                  return;
   1159              }
   1160          
   1161          
   1162          
   1163          /*$PAGE*/
   1164                                                                              /* ---------------- CREATE MEM POOL --------------- */
   1165              pmem_pool_heap = (MEM_POOL *)&Mem_PoolHeap;
   1166              size_tot       = (CPU_SIZE_T) 0u;
   1167          
   1168              CPU_CRITICAL_ENTER();
   1169          
   1170              if (pmem_base_addr == (void *)0) {                              /* If no base addr, cfg mem pool from heap.         */
   1171                  pmem_seg        =  pmem_pool_heap;
   1172                  pmem_seg_prev   =  pmem_pool_heap;
   1173                  pmem_seg_next   =  pmem_pool_heap;
   1174          
   1175                                                                              /* --------------- VALIDATE MEM SEG --------------- */
   1176                                                                              /* Calc tot mem   size for mem pool ptrs.           */
   1177                  pmem_addr_ptrs  = (CPU_INT08U *)pmem_pool_heap->SegAddrNextAvail;
   1178                  size_tot_ptrs   =  Mem_SegCalcTotSize((void     *)pmem_addr_ptrs,
   1179                                                        (CPU_SIZE_T)blk_nbr,
   1180                                                        (CPU_SIZE_T)sizeof(void *),
   1181                                                        (CPU_SIZE_T)sizeof(void *));
   1182          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1183                  if (size_tot_ptrs < 1) {                                    /* If heap ovf, ...                                 */
   1184                      CPU_CRITICAL_EXIT();
   1185                     *perr = LIB_MEM_ERR_HEAP_OVF;                            /* ... rtn err but add'l heap size NOT avail.       */
   1186                      return;
   1187                  }
   1188          #endif
   1189                                                                              /* Calc tot mem   size for mem blks.                */
   1190                  pmem_addr_pool  =  pmem_addr_ptrs + size_tot_ptrs;          /* Adj next avail addr for mem pool blks.           */
   1191                  size_tot_pool   =  Mem_SegCalcTotSize((void     *)pmem_addr_pool,
   1192                                                        (CPU_SIZE_T)blk_nbr,
   1193                                                        (CPU_SIZE_T)blk_size,
   1194                                                        (CPU_SIZE_T)blk_align);
   1195          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1196                  if (size_tot_pool < 1) {                                    /* If heap ovf, ...                                 */
   1197                      CPU_CRITICAL_EXIT();
   1198                     *perr = LIB_MEM_ERR_HEAP_OVF;                            /* ... rtn err but add'l heap size NOT avail.       */
   1199                      return;
   1200                  }
   1201          #endif
   1202          
   1203                  size_tot = size_tot_ptrs + size_tot_pool;
   1204          
   1205          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1206                  if ((size_tot < size_tot_ptrs) ||                           /* If heap ovf, ...                                 */
   1207                      (size_tot < size_tot_pool)) {
   1208                      CPU_CRITICAL_EXIT();
   1209                     *perr = LIB_MEM_ERR_HEAP_OVF;                            /* ... rtn err but add'l heap size NOT avail.       */
   1210                      return;
   1211                  }
   1212          #endif
   1213          
   1214                  size_rem = pmem_pool_heap->SegSizeRem;
   1215                  if (size_tot > size_rem) {                                  /* If tot size > rem  size, ...                     */
   1216                      CPU_CRITICAL_EXIT();
   1217                     *poctets_reqd = size_tot - size_rem;                     /* ... rtn add'l heap size needed.                  */
   1218                     *perr         = LIB_MEM_ERR_HEAP_EMPTY;
   1219                      return;
   1220                  }
   1221          
   1222          /*$PAGE*/
   1223              } else {                                                        /* Else cfg mem pool from dedicated mem.            */
   1224                                                                              /* -------- SRCH ALL MEM SEGS FOR MEM POOL -------- */
   1225                  pmem_base_addr_start = (CPU_INT08U *)pmem_base_addr;
   1226                  pmem_base_addr_end   = (CPU_INT08U *)pmem_base_addr + mem_size - 1;
   1227          
   1228          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1229                  if (pmem_base_addr_end < pmem_base_addr_start) {            /* Chk ovf of end addr.                             */
   1230                      CPU_CRITICAL_EXIT();
   1231                     *perr = LIB_MEM_ERR_INVALID_BLK_ADDR;
   1232                      return;
   1233                  }
   1234          #endif
   1235          
   1236                  pmem_seg      = (MEM_POOL *)0;
   1237                  pmem_seg_prev = (MEM_POOL *)0;
   1238                  pmem_seg_next =  Mem_PoolTbl;
   1239          
   1240                  while (pmem_seg_next != (MEM_POOL *)0) {                    /* Srch tbl for mem seg with same base addr/size.   */
   1241          
   1242                      if ((pmem_base_addr == pmem_seg_next->SegAddr) &&       /* If same base addr/size found, ...                */
   1243                          (mem_size       == pmem_seg_next->SegSizeTot)) {
   1244          
   1245                           pmem_seg        = pmem_seg_next;                   /* ... mem seg already avail in tbl.                */
   1246                           break;
   1247          
   1248                      } else {
   1249                          pmem_seg_addr_start = (CPU_INT08U *)pmem_seg_next->SegAddr;
   1250                          pmem_seg_addr_end   = (CPU_INT08U *)pmem_seg_next->SegAddr + pmem_seg_next->SegSizeTot - 1;
   1251          
   1252          
   1253                          if (pmem_base_addr_end < pmem_seg_addr_start) {     /* If mem seg addr/size prior to next mem seg, ...  */
   1254                              break;                                          /* ... new mem seg NOT avail in tbl.                */
   1255          
   1256                                                                              /* If mem seg overlaps prev mem seg(s) in tbl, ...  */
   1257                          } else if (((pmem_base_addr_start <= pmem_seg_addr_start)  &&
   1258                                      (pmem_base_addr_end   >= pmem_seg_addr_start)) ||
   1259                                     ((pmem_base_addr_start >= pmem_seg_addr_start)  &&
   1260                                      (pmem_base_addr_end   <= pmem_seg_addr_end  )) ||
   1261                                     ((pmem_base_addr_start <= pmem_seg_addr_end  )  &&
   1262                                      (pmem_base_addr_end   >= pmem_seg_addr_end  ))) {
   1263                              CPU_CRITICAL_EXIT();
   1264                             *perr = LIB_MEM_ERR_INVALID_SEG_OVERLAP;         /* ... rtn err.                                     */
   1265                              return;
   1266                          }
   1267                      }
   1268                                                                              /* If mem seg NOT found, adv to next mem seg.       */
   1269                      pmem_seg_prev = pmem_seg_next;
   1270                      pmem_seg_next = pmem_seg_next->SegNextPtr;
   1271                  }
   1272          
   1273                  if (pmem_seg == (MEM_POOL *)0) {                            /* If mem seg NOT found, add    new  mem seg.       */
   1274                      pmem_seg                    = pmem_pool;
   1275                      pmem_pool->SegAddr          = pmem_base_addr;
   1276                      pmem_pool->SegAddrNextAvail = pmem_base_addr;
   1277                      pmem_pool->SegSizeTot       = mem_size;
   1278                      pmem_pool->SegSizeRem       = mem_size;
   1279                  }
   1280          
   1281          /*$PAGE*/
   1282                                                                              /* --------------- VALIDATE MEM SEG --------------- */
   1283                                                                              /* Calc tot mem size for mem pool ptrs.             */
   1284                  pmem_addr_ptrs = (CPU_INT08U *)pmem_pool_heap->SegAddrNextAvail;
   1285                  size_tot_ptrs  =  Mem_SegCalcTotSize((void     *)pmem_addr_ptrs,
   1286                                                       (CPU_SIZE_T)blk_nbr,
   1287                                                       (CPU_SIZE_T)sizeof(void *),
   1288                                                       (CPU_SIZE_T)sizeof(void *));
   1289          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1290                  if (size_tot_ptrs < 1) {                                    /* If heap ovf, ...                                 */
   1291                      CPU_CRITICAL_EXIT();
   1292                     *perr = LIB_MEM_ERR_HEAP_OVF;                            /* ... rtn err but add'l heap size NOT avail.       */
   1293                      return;
   1294                  }
   1295          #endif
   1296          
   1297                  size_rem = pmem_pool_heap->SegSizeRem;
   1298                  if (size_tot_ptrs > size_rem) {                             /* If ptr size > rem  size, ...                     */
   1299                      CPU_CRITICAL_EXIT();
   1300                     *poctets_reqd = size_tot_ptrs - size_rem;                /* ... rtn add'l heap size needed.                  */
   1301                     *perr         = LIB_MEM_ERR_HEAP_EMPTY;
   1302                      return;
   1303                  }
   1304          
   1305                                                                              /* Calc tot mem size for mem blks.                  */
   1306                  pmem_addr_pool = (CPU_INT08U *)pmem_seg->SegAddrNextAvail;
   1307                  size_tot_pool  =  Mem_SegCalcTotSize((void     *)pmem_addr_pool,
   1308                                                       (CPU_SIZE_T)blk_nbr,
   1309                                                       (CPU_SIZE_T)blk_size,
   1310                                                       (CPU_SIZE_T)blk_align);
   1311          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1312                  if (size_tot_pool < 1) {                                    /* If seg  ovf, ...                                 */
   1313                      CPU_CRITICAL_EXIT();
   1314                     *perr = LIB_MEM_ERR_SEG_OVF;                             /* ... rtn err but add'l seg  size NOT avail.       */
   1315                      return;
   1316                  }
   1317          #endif
   1318          
   1319                  size_rem = pmem_seg->SegSizeRem;
   1320                  if (size_tot_pool > size_rem) {                             /* If tot size > rem  size, ...                     */
   1321                      CPU_CRITICAL_EXIT();
   1322                     *poctets_reqd = size_tot_pool - size_rem;                /* ... rtn add'l seg  size needed.                  */
   1323                     *perr         = LIB_MEM_ERR_SEG_EMPTY;
   1324                      return;
   1325                  }
   1326              }
   1327          
   1328          
   1329          /*$PAGE*/
   1330                                                                              /* ---------------- ALLOC MEM BLKs ---------------- */
   1331              size_pool_ptrs = (CPU_SIZE_T)(blk_nbr * sizeof(void *));
   1332                                                                              /* Alloc stk of ptrs for mem blks from heap.        */
   1333              ppool_ptr      = (void **)Mem_SegAlloc((MEM_POOL *)pmem_pool_heap,
   1334                                                     (CPU_SIZE_T)size_pool_ptrs,
   1335                                                     (CPU_SIZE_T)sizeof(void *));
   1336              if (ppool_ptr == (void **)0) {                                  /* If mem pool ptrs alloc failed, ...               */
   1337                  size_rem = pmem_pool_heap->SegSizeRem;
   1338                  CPU_CRITICAL_EXIT();
   1339                                                                              /* ... rtn add'l heap size needed.                  */
   1340                  if (pmem_base_addr == (void *)0) {
   1341                      if (size_tot > size_rem) {
   1342                         *poctets_reqd = size_tot - size_rem;
   1343                      } else {
   1344                         *poctets_reqd = size_tot;
   1345                      }
   1346                  } else {
   1347                      if (size_pool_ptrs > size_rem) {
   1348                         *poctets_reqd = size_pool_ptrs - size_rem;
   1349                      } else {
   1350                         *poctets_reqd = size_pool_ptrs;
   1351                      }
   1352                  }
   1353                 *perr = LIB_MEM_ERR_HEAP_EMPTY;
   1354                  return;
   1355              }
   1356          
   1357              for (i = 0u; i < (CPU_SIZE_T)blk_nbr; i++) {                    /* Alloc mem blks from mem seg.                     */
   1358                  pmem_blk = (void *)Mem_SegAlloc(pmem_seg, blk_size, blk_align);
   1359                  if (pmem_blk == (void *)0) {                                /* If    mem blks alloc failed, ...                 */
   1360                      pmem_addr_pool = (CPU_INT08U *)pmem_seg->SegAddrNextAvail;
   1361                      size_rem       = (CPU_SIZE_T  )pmem_seg->SegSizeRem;
   1362                      CPU_CRITICAL_EXIT();
   1363                      blk_rem        =  blk_nbr - (MEM_POOL_BLK_QTY)i;
   1364                      size_tot       =  Mem_SegCalcTotSize((void           *)pmem_addr_pool,
   1365                                                           (MEM_POOL_BLK_QTY)blk_rem,
   1366                                                           (CPU_SIZE_T      )blk_size,
   1367                                                           (CPU_SIZE_T      )blk_align);
   1368                                                                              /* ... rtn add'l seg  size needed.                  */
   1369                      if (size_tot > size_rem) {
   1370                         *poctets_reqd = size_tot - size_rem;
   1371                      } else {
   1372                         *poctets_reqd = size_tot;
   1373                      }
   1374                     *perr = LIB_MEM_ERR_SEG_EMPTY;
   1375                      return;
   1376                  }
   1377                  ppool_ptr[i] = pmem_blk;
   1378              }
   1379          
   1380          
   1381          /*$PAGE*/
   1382                                                                              /* ------------- UPDATE MEM POOL TBL -------------- */
   1383              if (pmem_seg == pmem_pool) {                                    /* Add mem pool as new  mem pool tbl seg.           */
   1384                                                                              /* Update cur  mem seg  links.                      */
   1385                  pmem_pool->SegPrevPtr = pmem_seg_prev;
   1386                  pmem_pool->SegNextPtr = pmem_seg_next;
   1387          
   1388                  if (pmem_seg_prev != (MEM_POOL *)0) {                       /* Update prev mem seg  link.                       */
   1389                      pmem_seg_prev->SegNextPtr = pmem_pool;
   1390                  } else {
   1391                      Mem_PoolTbl               = pmem_pool;                  /* Update      mem tbl.                             */
   1392                  }
   1393          
   1394                  if (pmem_seg_next != (MEM_POOL *)0) {                       /* Update next mem seg  link.                       */
   1395                      pmem_seg_next->SegPrevPtr = pmem_pool;
   1396                  }
   1397          
   1398              } else {                                                        /* Add mem pool into mem seg.                       */
   1399                                                                              /* Update cur  mem pool links.                      */
   1400                  pmem_pool_next         = pmem_seg->PoolNextPtr;
   1401                  pmem_pool->PoolPrevPtr = pmem_seg;
   1402                  pmem_pool->PoolNextPtr = pmem_pool_next;
   1403          
   1404                  pmem_seg->PoolNextPtr  = pmem_pool;                         /* Update prev mem pool link.                       */
   1405          
   1406                  if (pmem_pool_next != (MEM_POOL *)0) {                      /* Update next mem pool link.                       */
   1407                      pmem_pool_next->PoolPrevPtr = pmem_pool;
   1408                  }
   1409              }
   1410          
   1411          
   1412          
   1413                                                                              /* ----------------- CFG MEM POOL ----------------- */
   1414              pmem_pool->Type          = (LIB_MEM_TYPE    ) LIB_MEM_TYPE_POOL;
   1415              pmem_pool->SegHeadPtr    = (MEM_POOL       *) pmem_seg;
   1416              pmem_pool->PoolAddrStart = (void           *) pmem_addr_pool;
   1417              pmem_pool->PoolAddrEnd   = (void           *)(pmem_addr_pool + size_tot_pool - 1);
   1418              pmem_pool->PoolPtrs      = (void          **) ppool_ptr;
   1419              pmem_pool->PoolSize      = (CPU_SIZE_T      ) size_tot_pool;
   1420              pmem_pool->BlkAlign      = (CPU_SIZE_T      ) blk_align;
   1421              pmem_pool->BlkSize       = (CPU_SIZE_T      ) blk_size;
   1422              pmem_pool->BlkNbr        = (MEM_POOL_BLK_QTY) blk_nbr;
   1423              pmem_pool->BlkIx         = (MEM_POOL_IX     ) blk_nbr;
   1424          
   1425          
   1426              CPU_CRITICAL_EXIT();
   1427          
   1428             *perr = LIB_MEM_ERR_NONE;
   1429          }
   1430          #endif
   1431          
   1432          
   1433          /*$PAGE*/
   1434          /*
   1435          *********************************************************************************************************
   1436          *                                      Mem_PoolBlkGetNbrAvail()
   1437          *
   1438          * Description : Get memory pools remaining number of blocks available to allocate.
   1439          *
   1440          * Argument(s) : pmem_pool   Pointer to a memory pool structure.
   1441          *
   1442          *               perr        Pointer to variable that will receive the return error code from this function :
   1443          *
   1444          *                               LIB_MEM_ERR_NONE                Memory pool available number of blocks 
   1445          *                                                                   successfully returned.
   1446          *                               LIB_MEM_ERR_NULL_PTR            Argument 'pmem_pool' passed a NULL pointer.
   1447          *                               LIB_MEM_ERR_INVALID_POOL        Invalid memory pool type.
   1448          *
   1449          * Return(s)   : Remaining memory pool blocks (see Note #1), if NO error(s).
   1450          *
   1451          *               0,                                          otherwise.
   1452          *
   1453          * Caller(s)   : Application.
   1454          *
   1455          * Note(s)     : (1) (a) Mem_PoolBlkGetNbrAvail() ONLY supports non-heap memory pools.
   1456          *                   (b) Mem_HeapGetSizeRem()/Mem_SegGetSizeRem() should be used for heap memory pool/segment.
   1457          *
   1458          *               (2) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
   1459          *********************************************************************************************************
   1460          */
   1461          /*$PAGE*/
   1462          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
   1463          MEM_POOL_BLK_QTY  Mem_PoolBlkGetNbrAvail (MEM_POOL  *pmem_pool,
   1464                                                    LIB_ERR   *perr)
   1465          {
   1466              MEM_POOL_BLK_QTY  nbr_blk_rem;
   1467              CPU_SR_ALLOC();
   1468          
   1469          
   1470          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1471                                                                          /* --------------- VALIDATE RTN ERR PTR --------------- */
   1472              if (perr == (LIB_ERR *)0) {
   1473                  CPU_SW_EXCEPTION(0u);
   1474              }
   1475                                                                          /* ---------------- VALIDATE MEM POOL ----------------- */
   1476              if (pmem_pool == (MEM_POOL *)0) {                           /* Validate mem ptr.                                    */
   1477                 *perr =  LIB_MEM_ERR_NULL_PTR;
   1478                  return (0u);
   1479              }
   1480          #endif
   1481          
   1482              CPU_CRITICAL_ENTER();
   1483          
   1484          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1485              switch (pmem_pool->Type) {                                  /* Validate mem pool type.                              */
   1486                  case LIB_MEM_TYPE_POOL:
   1487                       break;
   1488          
   1489          
   1490                  case LIB_MEM_TYPE_NONE:
   1491                  case LIB_MEM_TYPE_HEAP:
   1492                  default:
   1493                       CPU_CRITICAL_EXIT();
   1494                      *perr =  LIB_MEM_ERR_INVALID_POOL;
   1495                       return (0u);                                       /* Prevent 'break NOT reachable' compiler warning.      */
   1496              }
   1497          #endif
   1498          
   1499                                                                          /* --------- GET REM'ING MEM POOL NBR BLK(S) ---------- */
   1500              nbr_blk_rem = pmem_pool->BlkIx;
   1501          
   1502              CPU_CRITICAL_EXIT();
   1503          
   1504          
   1505             *perr =  LIB_MEM_ERR_NONE;
   1506          
   1507              return (nbr_blk_rem);
   1508          }
   1509          #endif
   1510          
   1511          
   1512          /*$PAGE*/
   1513          /*
   1514          *********************************************************************************************************
   1515          *                                          Mem_PoolBlkGet()
   1516          *
   1517          * Description : Get a memory block from memory pool.
   1518          *
   1519          * Argument(s) : pmem_pool   Pointer to  memory pool to get memory block from.
   1520          *
   1521          *               size        Size of requested memory (in octets).
   1522          *
   1523          *               perr        Pointer to variable that will receive the return error code from this function :
   1524          *
   1525          *                               LIB_MEM_ERR_NONE                   Memory block successfully returned.
   1526          *                               LIB_MEM_ERR_POOL_EMPTY          NO memory blocks available in memory pool.
   1527          *
   1528          *                               LIB_MEM_ERR_NULL_PTR            Argument 'pmem_pool' passed a NULL pointer.
   1529          *                               LIB_MEM_ERR_INVALID_POOL        Invalid memory pool type.
   1530          *                               LIB_MEM_ERR_INVALID_BLK_SIZE    Invalid memory pool block size requested.
   1531          *                               LIB_MEM_ERR_INVALID_BLK_IX      Invalid memory pool block index.
   1532          *
   1533          * Return(s)   : Pointer to memory block, if NO error(s).
   1534          *
   1535          *               Pointer to NULL,         otherwise.
   1536          *
   1537          * Caller(s)   : Application.
   1538          *
   1539          * Note(s)     : (1) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
   1540          *********************************************************************************************************
   1541          */
   1542          /*$PAGE*/
   1543          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
   1544          void  *Mem_PoolBlkGet (MEM_POOL    *pmem_pool,
   1545                                 CPU_SIZE_T   size,
   1546                                 LIB_ERR     *perr)
   1547          {
   1548              void  *pmem_blk;
   1549              CPU_SR_ALLOC();
   1550          
   1551          
   1552          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
   1553              if (perr == (LIB_ERR *)0) {
   1554                  CPU_SW_EXCEPTION((void *)0);
   1555              }
   1556          #endif
   1557          
   1558                                                                              /* ------------ VALIDATE MEM POOL GET ------------- */
   1559          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1560              if (pmem_pool == (MEM_POOL *)0) {                               /* Validate mem ptr.                                */
   1561                 *perr = LIB_MEM_ERR_NULL_PTR;
   1562                  return ((void *)0);
   1563              }
   1564          
   1565              if (size < 1) {                                                 /* Validate req'd size as non-NULL.                 */
   1566                 *perr = LIB_MEM_ERR_INVALID_BLK_SIZE;
   1567                  return ((void *)0);
   1568              }
   1569          #endif
   1570          
   1571              CPU_CRITICAL_ENTER();
   1572          
   1573          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1574              if (pmem_pool->Type != LIB_MEM_TYPE_POOL) {                     /* Validate mem pool type.                          */
   1575                  CPU_CRITICAL_EXIT();
   1576                 *perr = LIB_MEM_ERR_INVALID_POOL;
   1577                  return ((void *)0);
   1578              }
   1579          
   1580              if (size > pmem_pool->BlkSize) {                                /* Validate req'd size <= mem pool blk size.        */
   1581                  CPU_CRITICAL_EXIT();
   1582                 *perr = LIB_MEM_ERR_INVALID_BLK_SIZE;
   1583                  return ((void *)0);
   1584              }
   1585          #endif
   1586          
   1587             (void)&size;                                                     /* Prevent possible 'variable unused' warning.      */
   1588          
   1589              if (pmem_pool->BlkIx < 1) {                                     /* Validate mem pool as NOT empty.                  */
   1590                  CPU_CRITICAL_EXIT();
   1591                 *perr = LIB_MEM_ERR_POOL_EMPTY;
   1592                  return ((void *)0);
   1593              }
   1594          
   1595              if (pmem_pool->BlkIx > pmem_pool->BlkNbr) {                     /* Validate mem pool ix NOT corrupt.                */
   1596                  CPU_CRITICAL_EXIT();
   1597                 *perr = LIB_MEM_ERR_INVALID_BLK_IX;
   1598                  return ((void *)0);
   1599              }
   1600          
   1601                                                                              /* ------------ GET MEM BLK FROM POOL ------------- */
   1602              pmem_pool->BlkIx--;
   1603              pmem_blk = pmem_pool->PoolPtrs[pmem_pool->BlkIx];
   1604          
   1605              CPU_CRITICAL_EXIT();
   1606          
   1607             *perr =  LIB_MEM_ERR_NONE;
   1608          
   1609              return (pmem_blk);
   1610          }
   1611          #endif
   1612          
   1613          
   1614          /*$PAGE*/
   1615          /*
   1616          *********************************************************************************************************
   1617          *                                          Mem_PoolBlkFree()
   1618          *
   1619          * Description : Free a memory block to memory pool.
   1620          *
   1621          * Argument(s) : pmem_pool   Pointer to memory pool to free memory block.
   1622          *
   1623          *               pmem_blk    Pointer to memory block address to free.
   1624          *
   1625          *               perr        Pointer to variable that will receive the return error code from this function :
   1626          *
   1627          *                               LIB_MEM_ERR_NONE                            Memory block successfully freed.
   1628          *                               LIB_MEM_ERR_POOL_FULL                   ALL memory blocks already available in
   1629          *                                                                           memory pool.
   1630          *
   1631          *                               LIB_MEM_ERR_NULL_PTR                    Argument 'pmem_pool'/'pmem_blk' passed
   1632          *                                                                           a NULL pointer.
   1633          *                               LIB_MEM_ERR_INVALID_POOL                Invalid memory pool  type.
   1634          *                               LIB_MEM_ERR_INVALID_BLK_ADDR            Invalid memory block address.
   1635          *                               LIB_MEM_ERR_INVALID_BLK_ADDR_IN_POOL            Memory block address already
   1636          *                                                                            in memory pool.
   1637          *
   1638          * Return(s)   : none.
   1639          *
   1640          * Caller(s)   : Application.
   1641          *
   1642          * Note(s)     : (1) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
   1643          *********************************************************************************************************
   1644          */
   1645          /*$PAGE*/
   1646          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
   1647          void  Mem_PoolBlkFree (MEM_POOL  *pmem_pool,
   1648                                 void      *pmem_blk,
   1649                                 LIB_ERR   *perr)
   1650          {
   1651          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1652              CPU_BOOLEAN  addr_valid;
   1653              MEM_POOL_IX  i;
   1654          #endif
   1655              CPU_SR_ALLOC();
   1656          
   1657          
   1658          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
   1659              if (perr == (LIB_ERR *)0) {
   1660                  CPU_SW_EXCEPTION(;);
   1661              }
   1662          #endif
   1663          
   1664                                                                              /* ------------ VALIDATE MEM POOL FREE ------------ */
   1665          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* Validate mem ptrs.                               */
   1666              if (pmem_pool == (MEM_POOL *)0) {
   1667                 *perr = LIB_MEM_ERR_NULL_PTR;
   1668                  return;
   1669              }
   1670          
   1671              if (pmem_blk == (void *)0) {
   1672                 *perr = LIB_MEM_ERR_NULL_PTR;
   1673                  return;
   1674              }
   1675          #endif
   1676          
   1677              CPU_CRITICAL_ENTER();
   1678          
   1679          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1680              if (pmem_pool->Type != LIB_MEM_TYPE_POOL) {                     /* Validate mem pool type.                          */
   1681                  CPU_CRITICAL_EXIT();
   1682                 *perr = LIB_MEM_ERR_INVALID_POOL;
   1683                  return;
   1684              }
   1685          
   1686              addr_valid = Mem_PoolBlkIsValidAddr(pmem_pool, pmem_blk);       /* Validate mem blk as valid pool blk addr.         */
   1687              if (addr_valid != DEF_OK) {
   1688                  CPU_CRITICAL_EXIT();
   1689                 *perr = LIB_MEM_ERR_INVALID_BLK_ADDR;
   1690                  return;
   1691              }
   1692          
   1693              for (i = 0u; i < pmem_pool->BlkIx; i++) {                       /* Validate mem blk  NOT already in pool.           */
   1694                  if (pmem_blk == pmem_pool->PoolPtrs[i]) {
   1695                      CPU_CRITICAL_EXIT();
   1696                     *perr = LIB_MEM_ERR_INVALID_BLK_ADDR_IN_POOL;
   1697                      return;
   1698                  }
   1699              }
   1700          #endif
   1701          
   1702              if (pmem_pool->BlkIx >= pmem_pool->BlkNbr) {                    /* Validate mem pool NOT already full.              */
   1703                  CPU_CRITICAL_EXIT();
   1704                 *perr = LIB_MEM_ERR_POOL_FULL;
   1705                  return;
   1706              }
   1707          
   1708                                                                              /* ------------- FREE MEM BLK TO POOL ------------- */
   1709              pmem_pool->PoolPtrs[pmem_pool->BlkIx] = pmem_blk;
   1710              pmem_pool->BlkIx++;
   1711          
   1712              CPU_CRITICAL_EXIT();
   1713          
   1714             *perr = LIB_MEM_ERR_NONE;
   1715          }
   1716          #endif
   1717          
   1718          
   1719          /*$PAGE*/
   1720          /*
   1721          *********************************************************************************************************
   1722          *********************************************************************************************************
   1723          *                                           LOCAL FUNCTIONS
   1724          *********************************************************************************************************
   1725          *********************************************************************************************************
   1726          */
   1727          
   1728          /*
   1729          *********************************************************************************************************
   1730          *                                      Mem_PoolBlkIsValidAddr()
   1731          *
   1732          * Description : Calculates if a given memory block address is valid for the memory pool.
   1733          *
   1734          * Argument(s) : pmem_pool   Pointer to memory pool structure to validate memory block address.
   1735          *               ---------   Argument validated in Mem_PoolBlkFree().
   1736          *
   1737          *               pmem_blk    Pointer to memory block address to validate.
   1738          *               --------    Argument validated in Mem_PoolBlkFree().
   1739          *
   1740          * Return(s)   : DEF_YES, if valid memory pool block address.
   1741          *
   1742          *               DEF_NO,  otherwise.
   1743          *
   1744          * Caller(s)   : Mem_PoolBlkFree().
   1745          *
   1746          * Note(s)     : none.
   1747          *********************************************************************************************************
   1748          */
   1749          
   1750          #if ((LIB_MEM_CFG_ALLOC_EN       == DEF_ENABLED) && \
   1751               (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED))
   1752          static  CPU_BOOLEAN  Mem_PoolBlkIsValidAddr (MEM_POOL  *pmem_pool,
   1753                                                       void      *pmem_blk)
   1754          {
   1755              CPU_INT08U   *ppool_addr_first;
   1756              void         *ppool_addr_start;
   1757              void         *ppool_addr_end;
   1758              CPU_SIZE_T    align_offset;
   1759              CPU_SIZE_T    blk_align;
   1760              CPU_SIZE_T    blk_align_offset;
   1761              CPU_SIZE_T    blk_size;
   1762              CPU_SIZE_T    mem_align;
   1763              CPU_SIZE_T    mem_align_offset;
   1764              CPU_SIZE_T    mem_diff;
   1765              CPU_BOOLEAN   addr_valid;
   1766          
   1767          
   1768              ppool_addr_start = pmem_pool->PoolAddrStart;
   1769              ppool_addr_end   = pmem_pool->PoolAddrEnd;
   1770          
   1771              if ((pmem_blk < ppool_addr_start) ||
   1772                  (pmem_blk > ppool_addr_end)) {
   1773                  return (DEF_NO);
   1774              }
   1775          
   1776              blk_align      = (CPU_SIZE_T)pmem_pool->BlkAlign;
   1777              align_offset   = (CPU_SIZE_T)((CPU_ADDR)ppool_addr_start % blk_align);
   1778              if (align_offset != 0u) {
   1779                  mem_align_offset = blk_align - align_offset;
   1780              } else {
   1781                  mem_align_offset = 0u;
   1782              }
   1783          
   1784              blk_size     = pmem_pool->BlkSize;
   1785              align_offset = blk_size % blk_align;
   1786              if (align_offset != 0u) {
   1787                  blk_align_offset = blk_align - align_offset;
   1788              } else {
   1789                  blk_align_offset = 0u;
   1790              }
   1791          
   1792              ppool_addr_first = (CPU_INT08U *)((CPU_INT08U *)ppool_addr_start + mem_align_offset);
   1793              mem_diff         = (CPU_SIZE_T  )((CPU_INT08U *)pmem_blk         - ppool_addr_first);
   1794              mem_align        = (CPU_SIZE_T  )(              blk_size         + blk_align_offset);
   1795          
   1796              addr_valid       = ((mem_diff % mem_align) == 0u) ? DEF_YES : DEF_NO;
   1797          
   1798              return (addr_valid);
   1799          }
   1800          #endif
   1801          
   1802          
   1803          /*$PAGE*/
   1804          /*
   1805          *********************************************************************************************************
   1806          *                                        Mem_SegCalcTotSize()
   1807          *
   1808          * Description : (1) Calculates total memory segment size for number of blocks with specific size & alignment :
   1809          *
   1810          *
   1811          *                       -----                     ======================  ---
   1812          *                         ^       Mem Addr  --->  |  /  /  /  /  /  /  |   ^
   1813          *                         |    (see Note #1a)     | /  /  /  /  /  /  /|   |    Mem Align Offset
   1814          *                         |                       |/  /  /  /  /  /  / |   |  (see Notes #1e & #2a)
   1815          *                         |                       |  /  /  /  /  /  /  |   v
   1816          *                         |                       ======================  ---
   1817          *                         |                       |                    |   ^
   1818          *                         |                       |                    |   |
   1819          *                         |                       |     Mem Blk #1     |   |        Blk Size
   1820          *                         |                       |                    |   |     (see Note #1c)
   1821          *                         |                       |                    |   v
   1822          *                         |                       ----------------------  ---
   1823          *                         |                       |  /  /  /  /  /  /  |   ^
   1824          *                         |                       | /  /  /  /  /  /  /|   |    Blk Align Offset
   1825          *                         |                       |/  /  /  /  /  /  / |   |  (see Notes #1f & #2b)
   1826          *                         |                       |  /  /  /  /  /  /  |   v
   1827          *                         |                       ======================  ---
   1828          *                                                 |         .          |
   1829          *                     Total Size                  |         .          |
   1830          *                   (see Note #2c)                |         .          |
   1831          *                                                 ======================  ---
   1832          *                         |                       |                    |   ^
   1833          *                         |                       |                    |   |
   1834          *                         |                       |   Mem Blk #N - 1   |   |        Blk Size
   1835          *                         |                       |                    |   |     (see Note #1c)
   1836          *                         |                       |                    |   v
   1837          *                         |                       ----------------------  ---
   1838          *                         |                       |  /  /  /  /  /  /  |   ^
   1839          *                         |                       | /  /  /  /  /  /  /|   |    Blk Align Offset
   1840          *                         |                       |/  /  /  /  /  /  / |   |  (see Notes #1f & #2b)
   1841          *                         |                       |  /  /  /  /  /  /  |   v
   1842          *                         |                       ======================  ---
   1843          *                         |                       |                    |   ^
   1844          *                         |                       |                    |   |
   1845          *                         |                       |     Mem Blk #N     |   |        Blk Size
   1846          *                         |                       |                    |   |     (see Note #1c)
   1847          *                         v                       |                    |   v
   1848          *                       -----                     ======================  ---
   1849          *
   1850          *               where
   1851          *
   1852          *                   (a) Mem Addr            Memory address of the beginning of the memory block ('pmem_addr')
   1853          *
   1854          *                   (b) N                   Number of memory blocks to allocate ('blk_nbr')
   1855          *
   1856          *                   (c) Blk Size            Size   of memory block  to allocate ('blk_size')
   1857          *
   1858          *                   (d) Align               Required block memory alignment     ('blk_align')
   1859          *
   1860          *                   (e) Mem Align Offset    Offset required to align first memory block
   1861          *
   1862          *                   (f) Blk Align Offset    Offset required to align every memory block
   1863          *
   1864          *
   1865          *               (2) The total size is calculated based on the following equations :
   1866          *
   1867          *                                            { (1) Align - (Mem Addr % Align) , if memory address is not aligned
   1868          *                   (a) Mem Align Offset  =  {
   1869          *                                            { (2) 0                          , if memory address is     aligned
   1870          *
   1871          *
   1872          *                                            { (1) Align - (Size     % Align) , if memory block   is not aligned
   1873          *                   (b) Blk Align Offset  =  {
   1874          *                                            { (2) 0                          , if memory block   is     aligned
   1875          *
   1876          *
   1877          *                   (c) Total Size        =   Mem Align Offset
   1878          *                                         + ((Blk Size + Blk Align Offset) * (N - 1))
   1879          *                                         +   Blk Size
   1880          *
   1881          *
   1882          * Argument(s) : pmem_addr   Memory address of the beginning of the memory block.
   1883          *
   1884          *               blk_nbr     Number of memory blocks to allocate.
   1885          *               -------     Argument checked in Mem_HeapAlloc(),
   1886          *                                               Mem_PoolCreate().
   1887          *
   1888          *               blk_size    Size   of memory block  to allocate.
   1889          *               --------    Argument checked in Mem_HeapAlloc(),
   1890          *                                               Mem_PoolCreate().
   1891          *
   1892          *               blk_align   Required block word-boundary memory alignment (in octets).
   1893          *               ---------   Argument checked in Mem_HeapAlloc(),
   1894          *                                               Mem_PoolCreate().
   1895          *
   1896          * Return(s)   : Total size of memory segment used to allocate the number of blocks, if NO error(s).
   1897          *
   1898          *               0,                                                                  otherwise.
   1899          *$PAGE*
   1900          * Caller(s)   : Mem_HeapAlloc(),
   1901          *               Mem_PoolCreate().
   1902          *
   1903          * Note(s)     : none.
   1904          *********************************************************************************************************
   1905          */
   1906          
   1907          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
   1908          static  CPU_SIZE_T  Mem_SegCalcTotSize (void              *pmem_addr,
   1909                                                  MEM_POOL_BLK_QTY   blk_nbr,
   1910                                                  CPU_SIZE_T         blk_size,
   1911                                                  CPU_SIZE_T         blk_align)
   1912          {
   1913          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1914              CPU_SIZE_T  blk_size_mem_aligned;
   1915              CPU_SIZE_T  blk_size_aligned;
   1916              CPU_SIZE_T  blk_size_aligned_nbr;
   1917              CPU_SIZE_T  blk_size_tot;
   1918          #endif
   1919              CPU_SIZE_T  align_offset;
   1920              CPU_SIZE_T  mem_align_offset;
   1921              CPU_SIZE_T  blk_align_offset;
   1922              CPU_SIZE_T  size_tot;
   1923          
   1924                                                                              /* Calc mem align (see Note #2a).                   */
   1925              align_offset = (CPU_ADDR)pmem_addr % blk_align;
   1926              if (align_offset != 0u) {
   1927                  mem_align_offset = blk_align - align_offset;
   1928              } else {
   1929                  mem_align_offset = 0u;
   1930              }
   1931                                                                              /* Calc blk align (see Note #2b).                   */
   1932              align_offset = blk_size % blk_align;
   1933              if (align_offset != 0u) {
   1934                  blk_align_offset = blk_align - align_offset;
   1935              } else {
   1936                  blk_align_offset = 0u;
   1937              }
   1938                                                                              /* Calc tot size  (see Note #2c).                   */
   1939              size_tot = mem_align_offset + ((blk_size + blk_align_offset) * ((CPU_SIZE_T)blk_nbr - 1)) + blk_size;
   1940          
   1941          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* Chk ovf of tot size = A + [(B + C) * D] + E      */
   1942              blk_size_mem_aligned = mem_align_offset + blk_size;             /* Chk ovf of A + E :                               */
   1943              if ((blk_size_mem_aligned < mem_align_offset) ||
   1944                  (blk_size_mem_aligned < blk_size)) {
   1945                  return (0u);
   1946              }
   1947          
   1948              if (blk_nbr > 1) {
   1949                  blk_size_aligned = blk_size + blk_align_offset;
   1950                  if ((blk_size_aligned < blk_align_offset) ||                /* Chk ovf of      (B + C) :                        */
   1951                      (blk_size_aligned < blk_size)) {
   1952                      return (0u);
   1953                  }
   1954          
   1955                  blk_size_aligned_nbr = blk_size_aligned * ((CPU_SIZE_T)blk_nbr - 1);
   1956                  if ((blk_size_aligned_nbr < blk_size_aligned) ||            /* Chk ovf of     [(B + C) * D] :                   */
   1957                      (blk_size_aligned_nbr < blk_align_offset) ||
   1958                      (blk_size_aligned_nbr < blk_size)) {
   1959                      return (0u);
   1960                  }
   1961          
   1962                  blk_size_tot = blk_size_aligned_nbr + blk_size;
   1963                  if ((blk_size_tot < blk_size_aligned_nbr) ||                /* Chk ovf of     [(B + C) * D] + E :               */
   1964                      (blk_size_tot < blk_size)) {
   1965                      return (0u);
   1966                  }
   1967          
   1968                  if ((size_tot < blk_size_mem_aligned) ||                    /* Chk ovf of A + [(B + C) * D] + E :               */
   1969                      (size_tot < blk_size_aligned_nbr) ||
   1970                      (size_tot < blk_size_tot)) {
   1971                      return (0u);
   1972                  }
   1973              }
   1974          #endif
   1975          
   1976              return (size_tot);
   1977          }
   1978          #endif
   1979          
   1980          
   1981          /*$PAGE*/
   1982          /*
   1983          *********************************************************************************************************
   1984          *                                           Mem_SegAlloc()
   1985          *
   1986          * Description : Allocates memory from specific segment.
   1987          *
   1988          * Argument(s) : pmem_pool   Pointer to memory pool structure containing segment information.
   1989          *               ---------   Argument validated in Mem_HeapAlloc(),
   1990          *                                                 Mem_PoolCreate().
   1991          *
   1992          *               size        Size of memory to allocate.
   1993          *               ----        Argument validated in Mem_HeapAlloc(),
   1994          *                                                 Mem_PoolCreate().
   1995          *
   1996          *               align       Required starting word-boundary memory alignment (in octets).
   1997          *               -----       Argument validated in Mem_HeapAlloc(),
   1998          *                                                 Mem_PoolCreate().
   1999          *
   2000          * Return(s)   : Pointer to allocated memory, if NO error(s).
   2001          *
   2002          *               Pointer to NULL,             otherwise.
   2003          *
   2004          * Caller(s)   : Mem_HeapAlloc(),
   2005          *               Mem_PoolCreate().
   2006          *
   2007          * Note(s)     : (1) Allocated memory from the specific segment is NEVER freed after allocation.
   2008          *
   2009          *               (2) 'pmem_pool' variables MUST ALWAYS be accessed exclusively in critical sections.
   2010          *
   2011          *                   (a) However, this function is already called within critical sections.
   2012          *********************************************************************************************************
   2013          */
   2014          
   2015          #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
   2016          static  void  *Mem_SegAlloc (MEM_POOL    *pmem_pool,
   2017                                       CPU_SIZE_T   size,
   2018                                       CPU_SIZE_T   align)
   2019          {
   2020              CPU_INT08U  *pmem_addr;
   2021              CPU_INT08U  *pmem_addr_next;
   2022              CPU_SIZE_T   mem_align;
   2023              CPU_SIZE_T   align_offset;
   2024              CPU_SIZE_T   size_tot;
   2025          
   2026          
   2027              pmem_addr = (CPU_INT08U *)pmem_pool->SegAddrNextAvail;
   2028          
   2029              mem_align = (CPU_SIZE_T)((CPU_ADDR)pmem_addr % align);          /* Calc mem align.                                  */
   2030          
   2031              if (mem_align != 0u) {
   2032                  align_offset = align - mem_align;
   2033              } else {
   2034                  align_offset = 0u;
   2035              }
   2036          
   2037              size_tot = align_offset + size;
   2038              if (size_tot > pmem_pool->SegSizeRem) {                         /* If insufficient mem seg size rem, ...            */
   2039                  return ((void *)0);                                         /* ... rtn NULL.                                    */
   2040              }
   2041          
   2042          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   2043              if ((size_tot < align_offset) ||                                /* If size ovf, ...                                 */
   2044                  (size_tot < size)) {
   2045                  return ((void *)0);                                         /* ... rtn NULL.                                    */
   2046              }
   2047          #endif
   2048          
   2049              pmem_addr_next = pmem_addr + size_tot;
   2050          
   2051          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   2052              if (pmem_addr_next < pmem_addr) {                               /* If addr ovf, ...                                 */
   2053                  return ((void *)0);                                         /* ... rtn NULL.                                    */
   2054              }
   2055          #endif
   2056          
   2057              pmem_addr += align_offset;                                      /* Align mem addr.                                  */
   2058          
   2059              pmem_pool->SegAddrNextAvail  = (void     *)pmem_addr_next;      /* Adv next avail addr.                             */
   2060              pmem_pool->SegSizeRem       -= (CPU_SIZE_T)size_tot;            /* Adj rem mem seg size.                            */
   2061          
   2062              return ((void *)pmem_addr);
   2063          }
   2064          #endif
   2065          

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      2   Mem_Clr
        2   -> Mem_Set
     12   Mem_Cmp
      0   Mem_Init
     12   Mem_Set


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       9  Mem_Clr
     197  Mem_Cmp
       1  Mem_Init
     132  Mem_Set

 
 339 bytes in segment CODE
 
 339 bytes of CODE memory

Errors: none
Warnings: none

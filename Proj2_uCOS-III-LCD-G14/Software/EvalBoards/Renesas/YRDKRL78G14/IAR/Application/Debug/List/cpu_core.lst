###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.30.5.50715 for RL78             23/Mar/2014  17:08:35 #
# Copyright 2011-2013 IAR Systems AB.                                         #
# Network license: ece-lic-19.ece.ncsu.edu (STD)                              #
#                                                                             #
#    Core         =  rl78_2                                                   #
#    Code model   =  Near                                                     #
#    Data model   =  Near                                                     #
#                 =                                                           #
#    Source file  =  C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\uC-CPU\cpu_core.c          #
#    Command line =  C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\uC-CPU\cpu_core.c --core   #
#                    rl78_2 --code_model near --data_model near               #
#                    --near_const_location rom0 -o                            #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\Debug\Obj\ --dlib_config            #
#                    "C:\Program Files\IAR Systems\Embedded Workbench         #
#                    6.5\rl78\LIB\dlrl78nn2n.h" -e -Ohz --no_scheduling       #
#                    --no_clustering --debug -lC                              #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\Debug\List\ -I                      #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\ -I C:\Users\Suddenlink\Dropbox\git #
#                    _files\embedded_design\Proj2_uCOS-III-LCD-G14\Software\E #
#                    valBoards\Renesas\YRDKRL78G14\IAR\Application\Source\    #
#                    -I C:\Users\Suddenlink\Dropbox\git_files\embedded_design #
#                    \Proj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDK #
#                    RL78G14\IAR\Application\..\uCOS-III\ -I                  #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\..\BSP\ -I                          #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\..\BSP\applilet3_src\ -I            #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\..\BSP\Glyph\Drivers\ -I            #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\..\BSP\Glyph\glyph\ -I              #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\..\..\..\..\..\uC-CPU\ -I           #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\..\..\..\..\..\uC-CPU\RL78\IAR\ -I  #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\..\..\..\..\..\uC-LIB\ -I           #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\..\..\..\..\..\uCOS-III\Ports\Renes #
#                    as\RL78\IAR\ -I C:\Users\Suddenlink\Dropbox\git_files\em #
#                    bedded_design\Proj2_uCOS-III-LCD-G14\Software\EvalBoards #
#                    \Renesas\YRDKRL78G14\IAR\Application\..\..\..\..\..\uCOS #
#                    -III\Source\ --relaxed_fp                                #
#    List file    =  C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\Debug\List\cpu_core.lst             #
#    Object file  =  C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\Debug\Obj\cpu_core.r87              #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Proj2_uCOS-III-LCD-G14\Software\uC-CPU\cpu_core.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/CPU
      4          *                                    CPU CONFIGURATION & PORT LAYER
      5          *
      6          *                          (c) Copyright 2004-2011; Micrium, Inc.; Weston, FL
      7          *
      8          *               All rights reserved.  Protected by international copyright laws.
      9          *
     10          *               uC/CPU is provided in source form to registered licensees ONLY.  It is
     11          *               illegal to distribute this source code to any third party unless you receive
     12          *               written permission by an authorized Micrium representative.  Knowledge of
     13          *               the source code may NOT be used to develop a similar product.
     14          *
     15          *               Please help us continue to provide the Embedded community with the finest
     16          *               software available.  Your honesty is greatly appreciated.
     17          *
     18          *               You can contact us at www.micrium.com.
     19          *********************************************************************************************************
     20          */
     21          
     22          /*
     23          *********************************************************************************************************
     24          *
     25          *                                           CORE CPU MODULE
     26          *
     27          * Filename      : cpu_core.c
     28          * Version       : V1.29.01
     29          * Programmer(s) : SR
     30          *                 ITJ
     31          *********************************************************************************************************
     32          */
     33          
     34          
     35          /*
     36          *********************************************************************************************************
     37          *                                            INCLUDE FILES
     38          *********************************************************************************************************
     39          */
     40          
     41          #define    CPU_CORE_MODULE
     42          #include  <cpu_core.h>

   \                                 In  segment NEAR_Z, align 2, align-sorted
   \   char CPU_Name[16U]
   \                     CPU_Name:
   \   000000                       DS 16
   \   000010                       REQUIRE __INIT_NEAR_Z

   \                                 In  segment NEAR_Z, align 2, align-sorted
   \   CPU_INT32U CPU_TS_TmrFreq_Hz
   \                     CPU_TS_TmrFreq_Hz:
   \   000000                       DS 4
   \   000004                       REQUIRE __INIT_NEAR_Z

   \                                 In  segment NEAR_Z, align 2, align-sorted
   \   CPU_INT16U CPU_IntDisMeasCtr
   \                     CPU_IntDisMeasCtr:
   \   000000                       DS 2
   \   000002                       REQUIRE __INIT_NEAR_Z

   \                                 In  segment NEAR_Z, align 2, align-sorted
   \   CPU_INT16U CPU_IntDisNestCtr
   \                     CPU_IntDisNestCtr:
   \   000000                       DS 2
   \   000002                       REQUIRE __INIT_NEAR_Z

   \                                 In  segment NEAR_Z, align 2, align-sorted
   \   CPU_TS_TMR CPU_IntDisMeasStart_cnts
   \                     CPU_IntDisMeasStart_cnts:
   \   000000                       DS 4
   \   000004                       REQUIRE __INIT_NEAR_Z

   \                                 In  segment NEAR_Z, align 2, align-sorted
   \   CPU_TS_TMR CPU_IntDisMeasStop_cnts
   \                     CPU_IntDisMeasStop_cnts:
   \   000000                       DS 4
   \   000004                       REQUIRE __INIT_NEAR_Z

   \                                 In  segment NEAR_Z, align 2, align-sorted
   \   CPU_TS_TMR CPU_IntDisMeasOvrhd_cnts
   \                     CPU_IntDisMeasOvrhd_cnts:
   \   000000                       DS 4
   \   000004                       REQUIRE __INIT_NEAR_Z

   \                                 In  segment NEAR_Z, align 2, align-sorted
   \   CPU_TS_TMR CPU_IntDisMeasMaxCur_cnts
   \                     CPU_IntDisMeasMaxCur_cnts:
   \   000000                       DS 4
   \   000004                       REQUIRE __INIT_NEAR_Z

   \                                 In  segment NEAR_Z, align 2, align-sorted
   \   CPU_TS_TMR CPU_IntDisMeasMax_cnts
   \                     CPU_IntDisMeasMax_cnts:
   \   000000                       DS 4
   \   000004                       REQUIRE __INIT_NEAR_Z
     43          
     44          
     45          /*$PAGE*/
     46          /*
     47          *********************************************************************************************************
     48          *                                            LOCAL DEFINES
     49          *********************************************************************************************************
     50          */
     51          
     52          
     53          /*
     54          *********************************************************************************************************
     55          *                                           LOCAL CONSTANTS
     56          *********************************************************************************************************
     57          */
     58          
     59          
     60          /*
     61          *********************************************************************************************************
     62          *                                          LOCAL DATA TYPES
     63          *********************************************************************************************************
     64          */
     65          
     66          
     67          /*
     68          *********************************************************************************************************
     69          *                                            LOCAL TABLES
     70          *********************************************************************************************************
     71          */
     72          
     73          /*
     74          *********************************************************************************************************
     75          *                                  CPU COUNT LEAD ZEROs LOOKUP TABLE
     76          *
     77          * Note(s) : (1) Index into bit pattern table determines the number of leading zeros in an 8-bit value :
     78          *
     79          *                         b07  b06  b05  b04  b03  b02  b01  b00    # Leading Zeros
     80          *                         ---  ---  ---  ---  ---  ---  ---  ---    ---------------
     81          *                          1    x    x    x    x    x    x    x            0
     82          *                          0    1    x    x    x    x    x    x            1
     83          *                          0    0    1    x    x    x    x    x            2
     84          *                          0    0    0    1    x    x    x    x            3
     85          *                          0    0    0    0    1    x    x    x            4
     86          *                          0    0    0    0    0    1    x    x            5
     87          *                          0    0    0    0    0    0    1    x            6
     88          *                          0    0    0    0    0    0    0    1            7
     89          *                          0    0    0    0    0    0    0    0            8
     90          *********************************************************************************************************
     91          */
     92          
     93          #if (!(defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) || \
     94                (CPU_CFG_DATA_SIZE_MAX > CPU_CFG_DATA_SIZE))

   \                                 In  segment NEAR_CONST, align 2
     95          static  const  CPU_INT08U  CPU_CntLeadZerosTbl[256] = {                             /* Data vals :                      */
   \                     CPU_CntLeadZerosTbl:
   \   000000 080706060505          DB 8, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3
   \   000017 030303030303          DB 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2
   \   00002E 020202020202          DB 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1
   \   000045 010101010101          DB 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
   \   00005C 010101010101          DB 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
   \   000073 010101010101          DB 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \   00008A 000000000000          DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \   0000A1 000000000000          DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \   0000B8 000000000000          DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \   0000CF 000000000000          DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \   0000E6 000000000000          DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \   0000FD 000000                DB 0, 0, 0
     96          /*   0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F   */
     97              8u,  7u,  6u,  6u,  5u,  5u,  5u,  5u,  4u,  4u,  4u,  4u,  4u,  4u,  4u,  4u,  /*   0x00 to 0x0F                   */
     98              3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  3u,  /*   0x10 to 0x1F                   */
     99              2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  /*   0x20 to 0x2F                   */
    100              2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  2u,  /*   0x30 to 0x3F                   */
    101              1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  /*   0x40 to 0x4F                   */
    102              1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  /*   0x50 to 0x5F                   */
    103              1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  /*   0x60 to 0x6F                   */
    104              1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  1u,  /*   0x70 to 0x7F                   */
    105              0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  /*   0x80 to 0x8F                   */
    106              0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  /*   0x90 to 0x9F                   */
    107              0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  /*   0xA0 to 0xAF                   */
    108              0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  /*   0xB0 to 0xBF                   */
    109              0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  /*   0xC0 to 0xCF                   */
    110              0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  /*   0xD0 to 0xDF                   */
    111              0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  /*   0xE0 to 0xEF                   */
    112              0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u,  0u   /*   0xF0 to 0xFF                   */
    113          };
    114          #endif
    115          
    116          
    117          /*$PAGE*/
    118          /*
    119          *********************************************************************************************************
    120          *                                       LOCAL GLOBAL VARIABLES
    121          *********************************************************************************************************
    122          */
    123          
    124          
    125          /*
    126          *********************************************************************************************************
    127          *                                      LOCAL FUNCTION PROTOTYPES
    128          *********************************************************************************************************
    129          */
    130          
    131          #if    (CPU_CFG_NAME_EN   == DEF_ENABLED)                           /* ---------------- CPU NAME FNCTS ---------------- */
    132          static  void        CPU_NameInit         (void);
    133          #endif
    134          
    135          
    136                                                                              /* ----------------- CPU TS FNCTS ----------------- */
    137          #if   ((CPU_CFG_TS_EN     == DEF_ENABLED) || \
    138                 (CPU_CFG_TS_TMR_EN == DEF_ENABLED))
    139          static  void        CPU_TS_Init          (void);
    140          #endif
    141          
    142          
    143          #ifdef  CPU_CFG_INT_DIS_MEAS_EN                                     /* ---------- CPU INT DIS TIME MEAS FNCTS --------- */
    144          static  void        CPU_IntDisMeasInit   (void);
    145          
    146          static  CPU_TS_TMR  CPU_IntDisMeasMaxCalc(CPU_TS_TMR  time_tot_cnts);
    147          #endif
    148          
    149          
    150          /*
    151          *********************************************************************************************************
    152          *                                     LOCAL CONFIGURATION ERRORS
    153          *********************************************************************************************************
    154          */
    155          
    156          
    157          /*$PAGE*/
    158          /*
    159          *********************************************************************************************************
    160          *                                             CPU_Init()
    161          *
    162          * Description : (1) Initialize CPU module :
    163          *
    164          *                   (a) Initialize CPU timestamps
    165          *                   (b) Initialize CPU interrupts disabled time measurements
    166          *                   (c) Initialize CPU host name
    167          *
    168          *
    169          * Argument(s) : none.
    170          *
    171          * Return(s)   : none.
    172          *
    173          * Caller(s)   : Your Product's Application.
    174          *
    175          *               This function is a CPU initialization function & MAY be called by application/
    176          *               initialization function(s).
    177          *
    178          * Note(s)     : (2) CPU_Init() MUST be called ... :
    179          *
    180          *                   (a) ONLY ONCE from a product's application; ...
    181          *                   (b) BEFORE product's application calls any core CPU module function(s)
    182          *
    183          *               (3) The following initialization functions MUST be sequenced as follows :
    184          *
    185          *                   (a) CPU_TS_Init()           SHOULD precede ALL calls to other CPU timestamp functions
    186          *
    187          *                   (b) CPU_IntDisMeasInit()    SHOULD precede ALL calls to CPU_CRITICAL_ENTER()/CPU_CRITICAL_EXIT()
    188          *                                                   & other CPU interrupts disabled time measurement functions
    189          *********************************************************************************************************
    190          */
    191          

   \                                 In  segment CODE, align 1, keep-with-next
    192          void  CPU_Init (void)
   \                     CPU_Init:
    193          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000                       ; Auto size: 0
    194                                                                          /* --------------------- INIT TS ---------------------- */
    195          #if ((CPU_CFG_TS_EN     == DEF_ENABLED) || \
    196               (CPU_CFG_TS_TMR_EN == DEF_ENABLED))
    197              CPU_TS_Init();                                              /* See Note #3a.                                        */
   \   000000 36....                MOVW      HL, #CPU_TS_TmrFreq_Hz  ;; 1 cycle
   \   000003 F6                    CLRW      AX                 ;; 1 cycle
   \   000004 BB                    MOVW      [HL], AX           ;; 1 cycle
   \   000005 BC02                  MOVW      [HL+0x02], AX      ;; 1 cycle
   \   000007 FD....                CALL      CPU_TS_TmrInit     ;; 3 cycles
    198          #endif
    199                                                                          /* -------------- INIT INT DIS TIME MEAS -------------- */
    200          #ifdef  CPU_CFG_INT_DIS_MEAS_EN
    201              CPU_IntDisMeasInit();                                       /* See Note #3b.                                        */
   \   00000A FD....                CALL      CPU_IntDisMeasInit  ;; 3 cycles
    202          #endif
    203          
    204                                                                          /* ------------------ INIT CPU NAME ------------------- */
    205          #if (CPU_CFG_NAME_EN == DEF_ENABLED)
    206               CPU_NameInit();
   \   00000D ED....                BR        N:CPU_NameClr      ;; 3 cycles
   \   000010                       ; ------------------------------------- Block: 13 cycles
   \   000010                       ; ------------------------------------- Total: 13 cycles
   \   000010                       REQUIRE ?CLRL78_V1_0_L00
    207          #endif
    208          }
    209          
    210          
    211          /*$PAGE*/
    212          /*
    213          *********************************************************************************************************
    214          *                                         CPU_SW_Exception()
    215          *
    216          * Description : Trap unrecoverable software exception.
    217          *
    218          * Argument(s) : none.
    219          *
    220          * Return(s)   : none.
    221          *
    222          * Caller(s)   : various.
    223          *
    224          * Note(s)     : (1) CPU_SW_Exception() deadlocks the current code execution -- whether multi-tasked/
    225          *                   -processed/-threaded or single-threaded -- when the current code execution cannot
    226          *                   gracefully recover or report a fault or exception condition.
    227          *
    228          *                   See also 'cpu_core.h  CPU_SW_EXCEPTION()  Note #1'.
    229          *********************************************************************************************************
    230          */
    231          

   \                                 In  segment CODE, align 1, keep-with-next
    232          void  CPU_SW_Exception (void)
   \                     CPU_SW_Exception:
    233          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000                       ; Auto size: 0
    234              while (DEF_ON) {
   \                     ??CPU_SW_Exception_0:
   \   000000 EFFE                  BR        S:??CPU_SW_Exception_0  ;; 3 cycles
   \   000002                       ; ------------------------------------- Block: 3 cycles
   \   000002                       ; ------------------------------------- Total: 3 cycles
   \   000002                       REQUIRE ?CLRL78_V1_0_L00
    235                  ;
    236              }
    237          }
    238          
    239          
    240          /*$PAGE*/
    241          /*
    242          *********************************************************************************************************
    243          *                                            CPU_NameClr()
    244          *
    245          * Description : Clear CPU Name.
    246          *
    247          * Argument(s) : none.
    248          *
    249          * Return(s)   : none.
    250          *
    251          * Caller(s)   : CPU_NameInit(),
    252          *               Application.
    253          *
    254          *               This function is a CPU module application programming interface (API) function & MAY be
    255          *               called by application function(s).
    256          *
    257          * Note(s)     : none.
    258          *********************************************************************************************************
    259          */
    260          
    261          #if (CPU_CFG_NAME_EN == DEF_ENABLED)

   \                                 In  segment CODE, align 1, keep-with-next
    262          void  CPU_NameClr (void)
   \                     CPU_NameClr:
    263          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000 C3                    PUSH      BC                 ;; 1 cycle
   \   000001 C5                    PUSH      DE                 ;; 1 cycle
   \   000002                       ; Auto size: 0
    264              CPU_SR_ALLOC();
    265          
    266          
    267              CPU_CRITICAL_ENTER();
   \   000002 FD....                CALL      N:?Subroutine6     ;; 3 cycles
   \   000005                       ; ------------------------------------- Block: 5 cycles
   \                     ??CrossCallReturnLabel_7:
   \   000005 FD....                CALL      CPU_IntDisMeasStart  ;; 3 cycles
    268              Mem_Clr((void     *)&CPU_Name[0],
    269                      (CPU_SIZE_T) CPU_CFG_NAME_SIZE);
   \   000008 321000                MOVW      BC, #0x10          ;; 1 cycle
   \   00000B 30....                MOVW      AX, #CPU_Name      ;; 1 cycle
   \   00000E FD....                CALL      Mem_Clr            ;; 3 cycles
    270              CPU_CRITICAL_EXIT();
   \   000011 FD....                CALL      CPU_IntDisMeasStop  ;; 3 cycles
   \   000014 65                    MOV       A, D               ;; 1 cycle
   \   000015                       ; ------------------------------------- Block: 12 cycles
   \   000015                       ; ------------------------------------- Total: 17 cycles
   \   000015                       REQUIRE ?CLRL78_V1_0_L00
   \   000015                       REQUIRE ?Subroutine1
   \   000015                       ; // Fall through to label ?Subroutine1
    271          }

   \                                 In  segment CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000 FD....                CALL      N:?Subroutine4     ;; 3 cycles
   \   000003                       ; ------------------------------------- Block: 3 cycles
   \                     ??CrossCallReturnLabel_4:
   \   000003 C4                    POP       DE                 ;; 1 cycle
   \   000004 C2                    POP       BC                 ;; 1 cycle
   \   000005 D7                    RET                          ;; 6 cycles
   \   000006                       ; ------------------------------------- Block: 8 cycles
   \   000006                       ; ------------------------------------- Total: 11 cycles
   \   000006                       REQUIRE ?CLRL78_V1_0_L00

   \                                 In  segment CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000 71FC                  MOV1      CY, A.7            ;; 1 cycle
   \   000002 7179FA                MOV1      PSW.7, CY          ;; 4 cycles
   \   000005 D7                    RET                          ;; 6 cycles
   \   000006                       ; ------------------------------------- Block: 11 cycles
   \   000006                       ; ------------------------------------- Total: 11 cycles
   \   000006                       REQUIRE ?CLRL78_V1_0_L00

   \                                 In  segment CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000 8EFA                  MOV       A, PSW             ;; 1 cycle
   \   000002 75                    MOV       D, A               ;; 1 cycle
   \   000003 717BFA                DI                           ;; 2 cycles
   \   000006 D7                    RET                          ;; 6 cycles
   \   000007                       ; ------------------------------------- Block: 10 cycles
   \   000007                       ; ------------------------------------- Total: 10 cycles
   \   000007                       REQUIRE ?CLRL78_V1_0_L00
    272          #endif
    273          
    274          
    275          /*$PAGE*/
    276          /*
    277          *********************************************************************************************************
    278          *                                            CPU_NameGet()
    279          *
    280          * Description : Get CPU host name.
    281          *
    282          * Argument(s) : p_name      Pointer to an ASCII character array that will receive the return CPU host
    283          *                               name ASCII string from this function (see Note #1).
    284          *
    285          *               p_err       Pointer to variable that will receive the return error code from this function :
    286          *
    287          *                               CPU_ERR_NONE                    CPU host name successfully returned.
    288          *                               CPU_ERR_NULL_PTR                Argument 'p_name' passed a NULL pointer.
    289          *
    290          * Return(s)   : none.
    291          *
    292          * Caller(s)   : Application.
    293          *
    294          *               This function is a CPU module application programming interface (API) function & MAY
    295          *               be called by application function(s).
    296          *
    297          * Note(s)     : (1) The size of the ASCII character array that will receive the return CPU host name
    298          *                   ASCII string :
    299          *
    300          *                   (a) MUST   be greater than or equal to the current CPU host name's ASCII string
    301          *                           size including the terminating NULL character;
    302          *                   (b) SHOULD be greater than or equal to CPU_CFG_NAME_SIZE
    303          *********************************************************************************************************
    304          */
    305          
    306          #if (CPU_CFG_NAME_EN == DEF_ENABLED)

   \                                 In  segment CODE, align 1, keep-with-next
    307          void  CPU_NameGet (CPU_CHAR  *p_name,
   \                     CPU_NameGet:
    308                             CPU_ERR   *p_err)
    309          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000 C5                    PUSH      DE                 ;; 1 cycle
   \   000001 C1                    PUSH      AX                 ;; 1 cycle
   \   000002 C3                    PUSH      BC                 ;; 1 cycle
   \   000003                       ; Auto size: 6
   \   000003 C1                    PUSH      AX                 ;; 1 cycle
    310              CPU_SR_ALLOC();
    311          
    312          
    313              if (p_err == (CPU_ERR *)0) {
   \   000004 13                    MOVW      AX, BC             ;; 1 cycle
   \   000005 440000                CMPW      AX, #0x0           ;; 1 cycle
   \   000008 61F8                  SKNZ                         ;; 4 cycles
   \   00000A                       ; ------------------------------------- Block: 10 cycles
   \                     ??CPU_NameGet_0:
   \   00000A EFFE                  BR        S:??CPU_NameGet_0  ;; 3 cycles
   \   00000C                       ; ------------------------------------- Block: 3 cycles
    314                  CPU_SW_EXCEPTION(;);
    315              }
    316          
    317              if (p_name == (CPU_CHAR *)0) {
   \                     ??CPU_NameGet_1:
   \   00000C A804                  MOVW      AX, [SP+0x04]      ;; 1 cycle
   \   00000E 440000                CMPW      AX, #0x0           ;; 1 cycle
   \   000011 DF07                  BNZ       ??CPU_IntDisMeasMaxCalc_0  ;; 4 cycles
   \   000013                       ; ------------------------------------- Block: 6 cycles
    318                 *p_err = CPU_ERR_NULL_PTR;
   \   000013 C3                    PUSH      BC                 ;; 1 cycle
   \   000014 C6                    POP       HL                 ;; 1 cycle
   \   000015 300A00                MOVW      AX, #0xA           ;; 1 cycle
   \   000018 EF21                  BR        S:??CPU_IntDisMeasMaxCalc_1  ;; 3 cycles
   \   00001A                       ; ------------------------------------- Block: 6 cycles
    319                  return;
    320              }
    321          
    322              CPU_CRITICAL_ENTER();
   \                     ??CPU_IntDisMeasMaxCalc_0:
   \   00001A 8EFA                  MOV       A, PSW             ;; 1 cycle
   \   00001C 9800                  MOV       [SP], A            ;; 1 cycle
   \   00001E 717BFA                DI                           ;; 2 cycles
   \   000021 FD....                CALL      CPU_IntDisMeasStart  ;; 3 cycles
    323             (void)Str_Copy_N(p_name,
    324                             &CPU_Name[0],
    325                              CPU_CFG_NAME_SIZE);
   \   000024 341000                MOVW      DE, #0x10          ;; 1 cycle
   \   000027 32....                MOVW      BC, #CPU_Name      ;; 1 cycle
   \   00002A A804                  MOVW      AX, [SP+0x04]      ;; 1 cycle
   \   00002C FD....                CALL      Str_Copy_N         ;; 3 cycles
    326              CPU_CRITICAL_EXIT();
   \   00002F FD....                CALL      CPU_IntDisMeasStop  ;; 3 cycles
   \   000032 8800                  MOV       A, [SP]            ;; 1 cycle
   \   000034 FD....                CALL      N:?Subroutine4     ;; 3 cycles
   \   000037                       ; ------------------------------------- Block: 20 cycles
    327          
    328             *p_err = CPU_ERR_NONE;
   \                     ??CrossCallReturnLabel_0:
   \   000037 A802                  MOVW      AX, [SP+0x02]      ;; 1 cycle
   \   000039 16                    MOVW      HL, AX             ;; 1 cycle
   \   00003A F6                    CLRW      AX                 ;; 1 cycle
   \   00003B                       ; ------------------------------------- Block: 3 cycles
   \                     ??CPU_IntDisMeasMaxCalc_1:
   \   00003B                       REQUIRE ?CLRL78_V1_0_L00
   \   00003B                       REQUIRE ?Subroutine3
   \   00003B                       ; // Fall through to label ?Subroutine3
    329          }

   \                                 In  segment CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000 BB                    MOVW      [HL], AX           ;; 1 cycle
   \   000001 1006                  ADDW      SP, #0x6           ;; 1 cycle
   \   000003 C4                    POP       DE                 ;; 1 cycle
   \   000004 D7                    RET                          ;; 6 cycles
   \   000005                       ; ------------------------------------- Block: 9 cycles
   \   000005                       ; ------------------------------------- Total: 9 cycles
   \   000005                       REQUIRE ?CLRL78_V1_0_L00
    330          #endif
    331          
    332          
    333          /*$PAGE*/
    334          /*
    335          *********************************************************************************************************
    336          *                                            CPU_NameSet()
    337          *
    338          * Description : Set CPU host name.
    339          *
    340          * Argument(s) : p_name      Pointer to CPU host name to set.
    341          *
    342          *               p_err       Pointer to variable that will receive the return error code from this function :
    343          *
    344          *                               CPU_ERR_NONE                    CPU host name successfully set.
    345          *                               CPU_ERR_NULL_PTR                Argument 'p_name' passed a NULL pointer.
    346          *                               CPU_ERR_NAME_SIZE               Invalid CPU host name size (see Note #1).
    347          *
    348          * Return(s)   : none.
    349          *
    350          * Caller(s)   : Application.
    351          *
    352          *               This function is a CPU module application programming interface (API) function & MAY be
    353          *               called by application function(s).
    354          *
    355          * Note(s)     : (1) 'p_name' ASCII string size, including the terminating NULL character, MUST be less
    356          *                    than or equal to CPU_CFG_NAME_SIZE.
    357          *********************************************************************************************************
    358          */
    359          
    360          #if (CPU_CFG_NAME_EN == DEF_ENABLED)

   \                                 In  segment CODE, align 1, keep-with-next
    361          void  CPU_NameSet (const  CPU_CHAR  *p_name,
   \                     CPU_NameSet:
    362                                    CPU_ERR   *p_err)
    363          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000 C5                    PUSH      DE                 ;; 1 cycle
   \   000001 C1                    PUSH      AX                 ;; 1 cycle
   \   000002 C3                    PUSH      BC                 ;; 1 cycle
   \   000003                       ; Auto size: 6
   \   000003 C1                    PUSH      AX                 ;; 1 cycle
    364              CPU_SIZE_T  len;
    365              CPU_SR_ALLOC();
    366          
    367          
    368              if (p_err == (CPU_ERR *)0) {
   \   000004 13                    MOVW      AX, BC             ;; 1 cycle
   \   000005 440000                CMPW      AX, #0x0           ;; 1 cycle
   \   000008 61F8                  SKNZ                         ;; 4 cycles
   \   00000A                       ; ------------------------------------- Block: 10 cycles
   \                     ??CPU_NameSet_0:
   \   00000A EFFE                  BR        S:??CPU_NameSet_0  ;; 3 cycles
   \   00000C                       ; ------------------------------------- Block: 3 cycles
    369                  CPU_SW_EXCEPTION(;);
    370              }
    371          
    372              if (p_name == (const CPU_CHAR *)0) {
   \                     ??CPU_NameSet_1:
   \   00000C A804                  MOVW      AX, [SP+0x04]      ;; 1 cycle
   \   00000E 440000                CMPW      AX, #0x0           ;; 1 cycle
   \   000011 DF07                  BNZ       ??CPU_IntDisMeasMaxCalc_2  ;; 4 cycles
   \   000013                       ; ------------------------------------- Block: 6 cycles
    373                 *p_err = CPU_ERR_NULL_PTR;
   \   000013 C3                    PUSH      BC                 ;; 1 cycle
   \   000014 C6                    POP       HL                 ;; 1 cycle
   \   000015 300A00                MOVW      AX, #0xA           ;; 1 cycle
   \   000018 EF35                  BR        S:??CPU_IntDisMeasMaxCalc_3  ;; 3 cycles
   \   00001A                       ; ------------------------------------- Block: 6 cycles
    374                  return;
    375              }
    376          
    377              len = Str_Len_N(p_name,
    378                              CPU_CFG_NAME_SIZE);
    379              if (len < CPU_CFG_NAME_SIZE) {                              /* If       cfg name len < max name size, ...           */
   \                     ??CPU_IntDisMeasMaxCalc_2:
   \   00001A 321000                MOVW      BC, #0x10          ;; 1 cycle
   \   00001D FD....                CALL      Str_Len_N          ;; 3 cycles
   \   000020 441000                CMPW      AX, #0x10          ;; 1 cycle
   \   000023 DE24                  BNC       ??CPU_IntDisMeasMaxCalc_4  ;; 4 cycles
   \   000025                       ; ------------------------------------- Block: 9 cycles
    380                  CPU_CRITICAL_ENTER();
   \   000025 8EFA                  MOV       A, PSW             ;; 1 cycle
   \   000027 9800                  MOV       [SP], A            ;; 1 cycle
   \   000029 717BFA                DI                           ;; 2 cycles
   \   00002C FD....                CALL      CPU_IntDisMeasStart  ;; 3 cycles
    381                 (void)Str_Copy_N(&CPU_Name[0],                           /* ... copy cfg name to CPU host name.                  */
    382                                   p_name,
    383                                   CPU_CFG_NAME_SIZE);
   \   00002F 341000                MOVW      DE, #0x10          ;; 1 cycle
   \   000032 A804                  MOVW      AX, [SP+0x04]      ;; 1 cycle
   \   000034 12                    MOVW      BC, AX             ;; 1 cycle
   \   000035 30....                MOVW      AX, #CPU_Name      ;; 1 cycle
   \   000038 FD....                CALL      Str_Copy_N         ;; 3 cycles
    384                  CPU_CRITICAL_EXIT();
   \   00003B FD....                CALL      CPU_IntDisMeasStop  ;; 3 cycles
   \   00003E 8800                  MOV       A, [SP]            ;; 1 cycle
   \   000040 FD....                CALL      N:?Subroutine4     ;; 3 cycles
   \   000043                       ; ------------------------------------- Block: 21 cycles
    385                 *p_err = CPU_ERR_NONE;
   \                     ??CrossCallReturnLabel_1:
   \   000043 A802                  MOVW      AX, [SP+0x02]      ;; 1 cycle
   \   000045 16                    MOVW      HL, AX             ;; 1 cycle
   \   000046 F6                    CLRW      AX                 ;; 1 cycle
   \   000047 EF06                  BR        S:??CPU_IntDisMeasMaxCalc_3  ;; 3 cycles
   \   000049                       ; ------------------------------------- Block: 6 cycles
    386          
    387              } else {
    388                 *p_err = CPU_ERR_NAME_SIZE;
   \                     ??CPU_IntDisMeasMaxCalc_4:
   \   000049 A802                  MOVW      AX, [SP+0x02]      ;; 1 cycle
   \   00004B 16                    MOVW      HL, AX             ;; 1 cycle
   \   00004C 30E803                MOVW      AX, #0x3E8         ;; 1 cycle
   \   00004F                       ; ------------------------------------- Block: 3 cycles
    389              }
   \                     ??CPU_IntDisMeasMaxCalc_3:
   \   00004F ED....                BR        N:?Subroutine3     ;; 3 cycles
   \   000052                       ; ------------------------------------- Block: 3 cycles
   \   000052                       ; ------------------------------------- Total: 67 cycles
   \   000052                       REQUIRE ?CLRL78_V1_0_L00
    390          }
    391          #endif
    392          
    393          
    394          /*$PAGE*/
    395          /*
    396          *********************************************************************************************************
    397          *                                           CPU_TS_Get32()
    398          *
    399          * Description : Get current 32-bit CPU timestamp.
    400          *
    401          * Argument(s) : none.
    402          *
    403          * Return(s)   : Current 32-bit CPU timestamp (in timestamp timer counts).
    404          *
    405          * Caller(s)   : Application.
    406          *
    407          *               This function is a CPU module application programming interface (API) function & MAY
    408          *               be called by application function(s).
    409          *
    410          * Note(s)     : (1) When applicable, the amount of time measured by CPU timestamps is calculated by
    411          *                   either of the following equations :
    412          *
    413          *                       (a) Time measured  =  Number timer counts  *  Timer period
    414          *
    415          *                               where
    416          *
    417          *                                   Number timer counts     Number of timer counts measured
    418          *                                   Timer period            Timer's period in some units of
    419          *                                                               (fractional) seconds
    420          *                                   Time measured           Amount of time measured, in same
    421          *                                                               units of (fractional) seconds
    422          *                                                               as the Timer period
    423          *
    424          *                                              Number timer counts
    425          *                       (b) Time measured  =  ---------------------
    426          *                                                Timer frequency
    427          *
    428          *                               where
    429          *
    430          *                                   Number timer counts     Number of timer counts measured
    431          *                                   Timer frequency         Timer's frequency in some units
    432          *                                                               of counts per second
    433          *                                   Time measured           Amount of time measured, in seconds
    434          *
    435          *                   See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()  Note #2c1'.
    436          *
    437          *               (2) In case the CPU timestamp timer has lower precision than the 32-bit CPU timestamp;
    438          *                   its precision is extended via periodic updates by accumulating the deltas of the
    439          *                   timestamp timer count values into the higher-precision 32-bit CPU timestamp.
    440          *
    441          *               (3) After initialization, 'CPU_TS_32_Accum' & 'CPU_TS_32_TmrPrev' MUST ALWAYS
    442          *                   be accessed AND updated exclusively with interrupts disabled -- but NOT
    443          *                   with critical sections.
    444          *********************************************************************************************************
    445          */
    446          
    447          #if (CPU_CFG_TS_32_EN == DEF_ENABLED)

   \                                 In  segment CODE, align 1, keep-with-next
    448          CPU_TS32  CPU_TS_Get32 (void)
   \                     CPU_TS_Get32:
    449          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000                       ; Auto size: 0
    450              CPU_TS32    ts;
    451          #if (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_32)
    452              CPU_TS_TMR  tmr_cur;
    453              CPU_TS_TMR  tmr_delta;
    454              CPU_SR_ALLOC();
    455          #endif
    456          
    457          
    458          #if (CPU_CFG_TS_TMR_SIZE >= CPU_WORD_SIZE_32)
    459              ts = (CPU_TS32)CPU_TS_TmrRd();                                  /* Get cur ts tmr val (in 32-bit ts cnts).          */
    460          
    461          #else
    462              CPU_INT_DIS();
    463              tmr_cur            = (CPU_TS_TMR) CPU_TS_TmrRd();               /* Get cur ts tmr val (in ts tmr cnts).             */
    464              tmr_delta          = (CPU_TS_TMR)(tmr_cur - CPU_TS_32_TmrPrev); /* Calc      delta ts tmr cnts.                     */
    465              CPU_TS_32_Accum   += (CPU_TS32  ) tmr_delta;                    /* Inc ts by delta ts tmr cnts (see Note #2).       */
    466              CPU_TS_32_TmrPrev  = (CPU_TS_TMR) tmr_cur;                      /* Save cur ts tmr cnts for next update.            */
    467              ts                 = (CPU_TS32  ) CPU_TS_32_Accum;
    468              CPU_INT_EN();
    469          #endif
    470          
    471              return (ts);
   \   000000 ED....                BR        N:CPU_TS_TmrRd     ;; 3 cycles
   \   000003                       ; ------------------------------------- Block: 3 cycles
   \   000003                       ; ------------------------------------- Total: 3 cycles
   \   000003                       REQUIRE ?CLRL78_V1_0_L00
    472          }
    473          #endif
    474          
    475          
    476          /*$PAGE*/
    477          /*
    478          *********************************************************************************************************
    479          *                                           CPU_TS_Get64()
    480          *
    481          * Description : Get current 64-bit CPU timestamp.
    482          *
    483          * Argument(s) : none.
    484          *
    485          * Return(s)   : Current 64-bit CPU timestamp (in timestamp timer counts).
    486          *
    487          * Caller(s)   : Application.
    488          *
    489          *               This function is a CPU module application programming interface (API) function & MAY
    490          *               be called by application function(s).
    491          *
    492          * Note(s)     : (1) When applicable, the amount of time measured by CPU timestamps is calculated by
    493          *                   either of the following equations :
    494          *
    495          *                       (a) Time measured  =  Number timer counts  *  Timer period
    496          *
    497          *                               where
    498          *
    499          *                                   Number timer counts     Number of timer counts measured
    500          *                                   Timer period            Timer's period in some units of
    501          *                                                               (fractional) seconds
    502          *                                   Time measured           Amount of time measured, in same
    503          *                                                               units of (fractional) seconds
    504          *                                                               as the Timer period
    505          *
    506          *                                              Number timer counts
    507          *                       (b) Time measured  =  ---------------------
    508          *                                                Timer frequency
    509          *
    510          *                               where
    511          *
    512          *                                   Number timer counts     Number of timer counts measured
    513          *                                   Timer frequency         Timer's frequency in some units
    514          *                                                               of counts per second
    515          *                                   Time measured           Amount of time measured, in seconds
    516          *
    517          *                   See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()  Note #2c1'.
    518          *
    519          *               (2) In case the CPU timestamp timer has lower precision than the 64-bit CPU timestamp;
    520          *                   its precision is extended via periodic updates by accumulating the deltas of the
    521          *                   timestamp timer count values into the higher-precision 64-bit CPU timestamp.
    522          *
    523          *               (3) After initialization, 'CPU_TS_64_Accum' & 'CPU_TS_64_TmrPrev' MUST ALWAYS
    524          *                   be accessed AND updated exclusively with interrupts disabled -- but NOT
    525          *                   with critical sections.
    526          *********************************************************************************************************
    527          */
    528          
    529          #if (CPU_CFG_TS_64_EN == DEF_ENABLED)
    530          CPU_TS64  CPU_TS_Get64 (void)
    531          {
    532              CPU_TS64    ts;
    533          #if (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_64)
    534              CPU_TS_TMR  tmr_cur;
    535              CPU_TS_TMR  tmr_delta;
    536              CPU_SR_ALLOC();
    537          #endif
    538          
    539          
    540          #if (CPU_CFG_TS_TMR_SIZE >= CPU_WORD_SIZE_64)
    541              ts = (CPU_TS64)CPU_TS_TmrRd();                                  /* Get cur ts tmr val (in 64-bit ts cnts).          */
    542          
    543          #else
    544              CPU_INT_DIS();
    545              tmr_cur            = (CPU_TS_TMR) CPU_TS_TmrRd();               /* Get cur ts tmr val (in ts tmr cnts).             */
    546              tmr_delta          = (CPU_TS_TMR)(tmr_cur - CPU_TS_64_TmrPrev); /* Calc      delta ts tmr cnts.                     */
    547              CPU_TS_64_Accum   += (CPU_TS64  ) tmr_delta;                    /* Inc ts by delta ts tmr cnts (see Note #2).       */
    548              CPU_TS_64_TmrPrev  = (CPU_TS_TMR) tmr_cur;                      /* Save cur ts tmr cnts for next update.            */
    549              ts                 = (CPU_TS64  ) CPU_TS_64_Accum;
    550              CPU_INT_EN();
    551          #endif
    552          
    553              return (ts);
    554          }
    555          #endif
    556          
    557          
    558          /*$PAGE*/
    559          /*
    560          *********************************************************************************************************
    561          *                                           CPU_TS_Update()
    562          *
    563          * Description : Update current CPU timestamp(s).
    564          *
    565          * Argument(s) : none.
    566          *
    567          * Return(s)   : none.
    568          *
    569          * Caller(s)   : Application/BSP periodic time handler (see Note #1).
    570          *
    571          *               This function is a CPU timestamp BSP function & SHOULD be called only by appropriate
    572          *               application/BSP function(s).
    573          *
    574          * Note(s)     : (1) (a) CPU timestamp(s) MUST be updated periodically by some application (or BSP) time
    575          *                       handler in order to (adequately) maintain CPU timestamp(s)' time.
    576          *
    577          *                   (b) CPU timestamp(s) MUST be updated more frequently than the CPU timestamp timer
    578          *                       overflows; otherwise, CPU timestamp(s) will lose time.
    579          *
    580          *                       See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()  Note #2c2'.
    581          *********************************************************************************************************
    582          */
    583          
    584          #if (CPU_CFG_TS_EN == DEF_ENABLED)

   \                                 In  segment CODE, align 1, keep-with-next
    585          void  CPU_TS_Update (void)
   \                     CPU_TS_Update:
    586          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000                       ; Auto size: 0
    587          #if ((CPU_CFG_TS_32_EN    == DEF_ENABLED)  && \
    588               (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_32))
    589             (void)CPU_TS_Get32();
    590          #endif
    591          
    592          #if ((CPU_CFG_TS_64_EN    == DEF_ENABLED)  && \
    593               (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_64))
    594             (void)CPU_TS_Get64();
    595          #endif
    596          }
   \   000000 D7                    RET                          ;; 6 cycles
   \   000001                       ; ------------------------------------- Block: 6 cycles
   \   000001                       ; ------------------------------------- Total: 6 cycles
   \   000001                       REQUIRE ?CLRL78_V1_0_L00
    597          #endif
    598          
    599          
    600          /*$PAGE*/
    601          /*
    602          *********************************************************************************************************
    603          *                                         CPU_TS_TmrFreqGet()
    604          *
    605          * Description : Get CPU timestamp's timer frequency.
    606          *
    607          * Argument(s) : p_err       Pointer to variable that will receive the return error code from this function :
    608          *
    609          *                               CPU_ERR_NONE                    CPU timestamp's timer frequency successfully
    610          *                                                                   returned.
    611          *                               CPU_ERR_TS_FREQ_INVALID         CPU timestamp's timer frequency invalid &/or
    612          *                                                                   NOT yet configured.
    613          *
    614          * Return(s)   : CPU timestamp's timer frequency (in Hertz), if NO error(s).
    615          *
    616          *               0,                                          otherwise.
    617          *
    618          * Caller(s)   : Application.
    619          *
    620          *               This function is a CPU module application programming interface (API) function & MAY be
    621          *               called by application function(s).
    622          *
    623          * Note(s)     : none.
    624          *********************************************************************************************************
    625          */
    626          
    627          #if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)

   \                                 In  segment CODE, align 1, keep-with-next
    628          CPU_TS_TMR_FREQ  CPU_TS_TmrFreqGet (CPU_ERR  *p_err)
   \                     CPU_TS_TmrFreqGet:
    629          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000 C5                    PUSH      DE                 ;; 1 cycle
   \   000001                       ; Auto size: 0
   \   000001 14                    MOVW      DE, AX             ;; 1 cycle
    630              CPU_TS_TMR_FREQ  freq_hz;
    631          
    632          
    633              if (p_err == (CPU_ERR *)0) {
   \   000002 440000                CMPW      AX, #0x0           ;; 1 cycle
   \   000005 61F8                  SKNZ                         ;; 4 cycles
   \   000007                       ; ------------------------------------- Block: 7 cycles
   \                     ??CPU_TS_TmrFreqGet_0:
   \   000007 EFFE                  BR        S:??CPU_TS_TmrFreqGet_0  ;; 3 cycles
   \   000009                       ; ------------------------------------- Block: 3 cycles
    634                  CPU_SW_EXCEPTION(;);
    635              }
    636          
    637              freq_hz =  CPU_TS_TmrFreq_Hz;
   \                     ??CPU_TS_TmrFreqGet_1:
   \   000009 DB....                MOVW      BC, N:CPU_TS_TmrFreq_Hz+2  ;; 1 cycle
   \   00000C AF....                MOVW      AX, N:CPU_TS_TmrFreq_Hz  ;; 1 cycle
    638             *p_err   = (freq_hz != 0u) ? CPU_ERR_NONE : CPU_ERR_TS_FREQ_INVALID;
   \   00000F 33                    XCHW      AX, BC             ;; 1 cycle
   \   000010 440000                CMPW      AX, #0x0           ;; 1 cycle
   \   000013 33                    XCHW      AX, BC             ;; 1 cycle
   \   000014 61F8                  SKNZ                         ;; 4 cycles
   \   000016                       ; ------------------------------------- Block: 9 cycles
   \   000016 440000                CMPW      AX, #0x0           ;; 1 cycle
   \   000019                       ; ------------------------------------- Block: 1 cycles
   \                     ??CPU_TS_TmrFreqGet_2:
   \   000019 DD05                  BZ        ??CPU_IntDisMeasMaxCalc_5  ;; 4 cycles
   \   00001B                       ; ------------------------------------- Block: 4 cycles
   \   00001B 360000                MOVW      HL, #0x0           ;; 1 cycle
   \   00001E EF03                  BR        S:??CPU_IntDisMeasMaxCalc_6  ;; 3 cycles
   \   000020                       ; ------------------------------------- Block: 4 cycles
   \                     ??CPU_IntDisMeasMaxCalc_5:
   \   000020 36D007                MOVW      HL, #0x7D0         ;; 1 cycle
   \   000023                       ; ------------------------------------- Block: 1 cycles
   \                     ??CPU_IntDisMeasMaxCalc_6:
   \   000023 37                    XCHW      AX, HL             ;; 1 cycle
   \   000024 B9                    MOVW      [DE], AX           ;; 1 cycle
   \   000025 17                    MOVW      AX, HL             ;; 1 cycle
    639          
    640              return (freq_hz);
   \   000026 C4                    POP       DE                 ;; 1 cycle
   \   000027 D7                    RET                          ;; 6 cycles
   \   000028                       ; ------------------------------------- Block: 10 cycles
   \   000028                       ; ------------------------------------- Total: 39 cycles
   \   000028                       REQUIRE ?CLRL78_V1_0_L00
    641          }
    642          #endif
    643          
    644          
    645          /*$PAGE*/
    646          /*
    647          *********************************************************************************************************
    648          *                                         CPU_TS_TmrFreqSet()
    649          *
    650          * Description : Set CPU timestamp's timer frequency.
    651          *
    652          * Argument(s) : freq_hz     Frequency (in Hertz) to set for CPU timestamp's timer.
    653          *
    654          * Return(s)   : none.
    655          *
    656          * Caller(s)   : CPU_TS_TmrInit(),
    657          *               Application/BSP initialization function(s).
    658          *
    659          *               This function is a CPU module BSP function & SHOULD be called only by appropriate
    660          *               application/BSP function(s) [see Note #1].
    661          *
    662          * Note(s)     : (1) (a) (1) CPU timestamp timer frequency is NOT required for internal CPU timestamp
    663          *                           operations but may OPTIONALLY be configured by CPU_TS_TmrInit() or other
    664          *                           application/BSP initialization functions.
    665          *
    666          *                       (2) CPU timestamp timer frequency MAY be used with optional CPU_TSxx_to_uSec()
    667          *                           to convert CPU timestamps from timer counts into microseconds.
    668          *
    669          *                           See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TSxx_to_uSec()  Note #2a'.
    670          *
    671          *                   (b) CPU timestamp timer period SHOULD be less than the typical measured time but MUST
    672          *                       be less than the maximum measured time; otherwise, timer resolution inadequate to
    673          *                       measure desired times.
    674          *
    675          *                       See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TSxx_to_uSec()  Note #2b'.
    676          *********************************************************************************************************
    677          */
    678          
    679          #if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)

   \                                 In  segment CODE, align 1, keep-with-next
    680          void  CPU_TS_TmrFreqSet (CPU_TS_TMR_FREQ  freq_hz)
   \                     CPU_TS_TmrFreqSet:
    681          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000                       ; Auto size: 0
    682              CPU_TS_TmrFreq_Hz = freq_hz;
   \   000000 BF....                MOVW      N:CPU_TS_TmrFreq_Hz, AX  ;; 1 cycle
   \   000003 13                    MOVW      AX, BC             ;; 1 cycle
   \   000004 BF....                MOVW      N:CPU_TS_TmrFreq_Hz+2, AX  ;; 1 cycle
    683          }
   \   000007 D7                    RET                          ;; 6 cycles
   \   000008                       ; ------------------------------------- Block: 9 cycles
   \   000008                       ; ------------------------------------- Total: 9 cycles
   \   000008                       REQUIRE ?CLRL78_V1_0_L00
    684          #endif
    685          
    686          
    687          /*$PAGE*/
    688          /*
    689          *********************************************************************************************************
    690          *                                     CPU_IntDisMeasMaxCurReset()
    691          *
    692          * Description : Reset current maximum interrupts disabled time.
    693          *
    694          * Argument(s) : none.
    695          *
    696          * Return(s)   : Maximum interrupts disabled time (in CPU timestamp timer counts) before resetting.
    697          *
    698          *               See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()      Note #2c'
    699          *                      & 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TSxx_to_uSec()  Note #2'.
    700          *
    701          * Caller(s)   : Application.
    702          *
    703          *               This function is a CPU module application programming interface (API) function
    704          *               & MAY be called by application function(s).
    705          *
    706          * Note(s)     : (1) After initialization, 'CPU_IntDisMeasMaxCur_cnts' MUST ALWAYS be accessed
    707          *                   exclusively with interrupts disabled -- but NOT with critical sections.
    708          *********************************************************************************************************
    709          */
    710          
    711          #ifdef  CPU_CFG_INT_DIS_MEAS_EN

   \                                 In  segment CODE, align 1, keep-with-next
    712          CPU_TS_TMR  CPU_IntDisMeasMaxCurReset (void)
   \                     CPU_IntDisMeasMaxCurReset:
    713          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000                       ; Auto size: 4
   \   000000 2004                  SUBW      SP, #0x4           ;; 1 cycle
    714              CPU_TS_TMR  time_max_cnts;
    715              CPU_SR_ALLOC();
    716          
    717          
    718              time_max_cnts             = CPU_IntDisMeasMaxCurGet();
   \   000002 FD....                CALL      CPU_IntDisMeasMaxCurGet  ;; 3 cycles
   \   000005 1004                  ADDW      SP, #0x4           ;; 1 cycle
   \   000007 C3                    PUSH      BC                 ;; 1 cycle
   \   000008 C1                    PUSH      AX                 ;; 1 cycle
    719              CPU_INT_DIS();
   \   000009 8EFA                  MOV       A, PSW             ;; 1 cycle
   \   00000B 73                    MOV       B, A               ;; 1 cycle
   \   00000C 717BFA                DI                           ;; 2 cycles
    720              CPU_IntDisMeasMaxCur_cnts = 0u;
   \   00000F 36....                MOVW      HL, #CPU_IntDisMeasMaxCur_cnts  ;; 1 cycle
   \   000012 F6                    CLRW      AX                 ;; 1 cycle
   \   000013 BB                    MOVW      [HL], AX           ;; 1 cycle
   \   000014 BC02                  MOVW      [HL+0x02], AX      ;; 1 cycle
    721              CPU_INT_EN();
   \   000016 63                    MOV       A, B               ;; 1 cycle
   \   000017 FD....                CALL      N:?Subroutine4     ;; 3 cycles
   \   00001A                       ; ------------------------------------- Block: 19 cycles
    722          
    723              return (time_max_cnts);
   \                     ??CrossCallReturnLabel_2:
   \   00001A A802                  MOVW      AX, [SP+0x02]      ;; 1 cycle
   \   00001C 12                    MOVW      BC, AX             ;; 1 cycle
   \   00001D A800                  MOVW      AX, [SP]           ;; 1 cycle
   \   00001F 1004                  ADDW      SP, #0x4           ;; 1 cycle
   \   000021 D7                    RET                          ;; 6 cycles
   \   000022                       ; ------------------------------------- Block: 10 cycles
   \   000022                       ; ------------------------------------- Total: 29 cycles
   \   000022                       REQUIRE ?CLRL78_V1_0_L00
    724          }
    725          #endif
    726          
    727          
    728          /*$PAGE*/
    729          /*
    730          *********************************************************************************************************
    731          *                                      CPU_IntDisMeasMaxCurGet()
    732          *
    733          * Description : Get current maximum interrupts disabled time.
    734          *
    735          * Argument(s) : none.
    736          *
    737          * Return(s)   : Current maximum interrupts disabled time (in CPU timestamp timer counts).
    738          *
    739          *               See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()      Note #2c'
    740          *                      & 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TSxx_to_uSec()  Note #2'.
    741          *
    742          * Caller(s)   : CPU_IntDisMeasMaxCurReset(),
    743          *               Application.
    744          *
    745          *               This function is a CPU module application programming interface (API) function
    746          *               & MAY be called by application function(s).
    747          *
    748          * Note(s)     : (1) After initialization, 'CPU_IntDisMeasMaxCur_cnts' MUST ALWAYS be accessed
    749          *                   exclusively with interrupts disabled -- but NOT with critical sections.
    750          *********************************************************************************************************
    751          */
    752          
    753          #ifdef  CPU_CFG_INT_DIS_MEAS_EN

   \                                 In  segment CODE, align 1, keep-with-next
    754          CPU_TS_TMR  CPU_IntDisMeasMaxCurGet (void)
   \                     CPU_IntDisMeasMaxCurGet:
    755          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000 C5                    PUSH      DE                 ;; 1 cycle
   \   000001                       ; Auto size: 0
    756              CPU_TS_TMR  time_tot_cnts;
    757              CPU_TS_TMR  time_max_cnts;
    758              CPU_SR_ALLOC();
    759          
    760          
    761              CPU_INT_DIS();
   \   000001 FD....                CALL      N:?Subroutine6     ;; 3 cycles
   \   000004                       ; ------------------------------------- Block: 4 cycles
    762              time_tot_cnts = CPU_IntDisMeasMaxCur_cnts;
   \                     ??CrossCallReturnLabel_8:
   \   000004 DB....                MOVW      BC, N:CPU_IntDisMeasMaxCur_cnts+2  ;; 1 cycle
   \   000007 AF....                MOVW      AX, N:CPU_IntDisMeasMaxCur_cnts  ;; 1 cycle
   \   00000A                       ; ------------------------------------- Block: 2 cycles
   \   00000A                       ; ------------------------------------- Total: 6 cycles
    763              CPU_INT_EN();
   \   00000A                       REQUIRE ?CLRL78_V1_0_L00
   \   00000A                       REQUIRE ?Subroutine0
   \   00000A                       ; // Fall through to label ?Subroutine0
    764              time_max_cnts = CPU_IntDisMeasMaxCalc(time_tot_cnts);
    765          
    766              return (time_max_cnts);
    767          }

   \                                 In  segment CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000 618D                  XCH       A, D               ;; 1 cycle
   \   000002 FD....                CALL      N:?Subroutine4     ;; 3 cycles
   \   000005                       ; ------------------------------------- Block: 4 cycles
   \                     ??CrossCallReturnLabel_3:
   \   000005 65                    MOV       A, D               ;; 1 cycle
   \   000006 FD....                CALL      CPU_IntDisMeasMaxCalc  ;; 3 cycles
   \   000009 C4                    POP       DE                 ;; 1 cycle
   \   00000A D7                    RET                          ;; 6 cycles
   \   00000B                       ; ------------------------------------- Block: 11 cycles
   \   00000B                       ; ------------------------------------- Total: 15 cycles
   \   00000B                       REQUIRE ?CLRL78_V1_0_L00
    768          #endif
    769          
    770          
    771          /*$PAGE*/
    772          /*
    773          *********************************************************************************************************
    774          *                                       CPU_IntDisMeasMaxGet()
    775          *
    776          * Description : Get (non-resetable) maximum interrupts disabled time.
    777          *
    778          * Argument(s) : none.
    779          *
    780          * Return(s)   : (Non-resetable) maximum interrupts disabled time (in CPU timestamp timer counts).
    781          *
    782          *               See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()      Note #2c'
    783          *                      & 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TSxx_to_uSec()  Note #2'.
    784          *
    785          * Caller(s)   : CPU_IntDisMeasInit(),
    786          *               Application.
    787          *
    788          *               This function is a CPU module application programming interface (API) function
    789          *               & MAY be called by application function(s).
    790          *
    791          * Note(s)     : (1) After initialization, 'CPU_IntDisMeasMax_cnts' MUST ALWAYS be accessed
    792          *                   exclusively with interrupts disabled -- but NOT with critical sections.
    793          *********************************************************************************************************
    794          */
    795          
    796          #ifdef  CPU_CFG_INT_DIS_MEAS_EN

   \                                 In  segment CODE, align 1, keep-with-next
    797          CPU_TS_TMR  CPU_IntDisMeasMaxGet (void)
   \                     CPU_IntDisMeasMaxGet:
    798          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000 C5                    PUSH      DE                 ;; 1 cycle
   \   000001                       ; Auto size: 0
    799              CPU_TS_TMR  time_tot_cnts;
    800              CPU_TS_TMR  time_max_cnts;
    801              CPU_SR_ALLOC();
    802          
    803          
    804              CPU_INT_DIS();
   \   000001 FD....                CALL      N:?Subroutine6     ;; 3 cycles
   \   000004                       ; ------------------------------------- Block: 4 cycles
    805              time_tot_cnts = CPU_IntDisMeasMax_cnts;
   \                     ??CrossCallReturnLabel_9:
   \   000004 DB....                MOVW      BC, N:CPU_IntDisMeasMax_cnts+2  ;; 1 cycle
   \   000007 AF....                MOVW      AX, N:CPU_IntDisMeasMax_cnts  ;; 1 cycle
    806              CPU_INT_EN();
   \   00000A ED....                BR        N:?Subroutine0     ;; 3 cycles
   \   00000D                       ; ------------------------------------- Block: 5 cycles
   \   00000D                       ; ------------------------------------- Total: 9 cycles
   \   00000D                       REQUIRE ?CLRL78_V1_0_L00
    807              time_max_cnts = CPU_IntDisMeasMaxCalc(time_tot_cnts);
    808          
    809              return (time_max_cnts);
    810          }
    811          #endif
    812          
    813          
    814          /*$PAGE*/
    815          /*
    816          *********************************************************************************************************
    817          *                                        CPU_IntDisMeasStart()
    818          *
    819          * Description : Start interrupts disabled time measurement.
    820          *
    821          * Argument(s) : none.
    822          *
    823          * Return(s)   : none.
    824          *
    825          * Caller(s)   : CPU_CRITICAL_ENTER().
    826          *
    827          *               This function is an INTERNAL CPU module function & MUST NOT be called by application
    828          *               function(s).
    829          *
    830          * Note(s)     : none.
    831          *********************************************************************************************************
    832          */
    833          
    834          #ifdef  CPU_CFG_INT_DIS_MEAS_EN

   \                                 In  segment CODE, align 1, keep-with-next
    835          void  CPU_IntDisMeasStart (void)
   \                     CPU_IntDisMeasStart:
    836          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000 C3                    PUSH      BC                 ;; 1 cycle
   \   000001                       ; Auto size: 0
    837              CPU_IntDisMeasCtr++;
   \   000001 A2....                INCW      N:CPU_IntDisMeasCtr  ;; 2 cycles
    838              if (CPU_IntDisNestCtr == 0u) {                                  /* If ints NOT yet dis'd, ...                       */
   \   000004 F6                    CLRW      AX                 ;; 1 cycle
   \   000005 42....                CMPW      AX, N:CPU_IntDisNestCtr  ;; 1 cycle
   \   000008 DF0A                  BNZ       ??CPU_IntDisMeasMaxCalc_7  ;; 4 cycles
   \   00000A                       ; ------------------------------------- Block: 9 cycles
    839                  CPU_IntDisMeasStart_cnts = CPU_TS_TmrRd();                  /* ... get ints dis'd start time.                   */
   \   00000A FD....                CALL      CPU_TS_TmrRd       ;; 3 cycles
   \   00000D BF....                MOVW      N:CPU_IntDisMeasStart_cnts, AX  ;; 1 cycle
   \   000010 13                    MOVW      AX, BC             ;; 1 cycle
   \   000011 BF....                MOVW      N:CPU_IntDisMeasStart_cnts+2, AX  ;; 1 cycle
   \   000014                       ; ------------------------------------- Block: 6 cycles
    840              }
    841              CPU_IntDisNestCtr++;
   \                     ??CPU_IntDisMeasMaxCalc_7:
   \   000014 A2....                INCW      N:CPU_IntDisNestCtr  ;; 2 cycles
    842          }
   \   000017 C2                    POP       BC                 ;; 1 cycle
   \   000018 D7                    RET                          ;; 6 cycles
   \   000019                       ; ------------------------------------- Block: 9 cycles
   \   000019                       ; ------------------------------------- Total: 24 cycles
   \   000019                       REQUIRE ?CLRL78_V1_0_L00
    843          #endif
    844          
    845          
    846          /*$PAGE*/
    847          /*
    848          *********************************************************************************************************
    849          *                                        CPU_IntDisMeasStop()
    850          *
    851          * Description : Stop interrupts disabled time measurement.
    852          *
    853          * Argument(s) : none.
    854          *
    855          * Return(s)   : none.
    856          *
    857          * Caller(s)   : CPU_CRITICAL_EXIT().
    858          *
    859          *               This function is an INTERNAL CPU module function & MUST NOT be called by application
    860          *               function(s).
    861          *
    862          * Note(s)     : (1) (a) The total amount of time interrupts are disabled by system &/or application code
    863          *                       during critical sections is calculated by the following equations :
    864          *
    865          *                       (1) When interrupts disabled time measurements are disabled :
    866          *
    867          *
    868          *                               |   CRITICAL  |                           |   CRITICAL  |
    869          *                               |<- SECTION ->|                           |<- SECTION ->|
    870          *                               |    ENTER    |                           |    EXIT     |
    871          *
    872          *                            Disable                                    Enable
    873          *                           Interrupts                                Interrupts
    874          *
    875          *                               ||           ||                           ||           ||
    876          *                               ||           ||                           ||           ||
    877          *                               ||       |   ||<------------------------->||       |   ||
    878          *                               ||       |<->||             |             ||<----->|   ||
    879          *                               ||       | | ||             |             ||   |   |   ||
    880          *                                        | |                |                  |   |
    881          *                                   interrupts            time                 interrupts
    882          *                                    disabled                 interrupts       |enabled
    883          *                                          |                   disabled        |
    884          *                                          |              (via application)    |
    885          *                                       time                                 time
    886          *                                           interrupts                           interrupts
    887          *                                         disabled ovrhd                        enabled ovrhd
    888          *
    889          *
    890          *                           (A) time            =  [ time            -  time           ]  -  time
    891          *                                   interrupts     [     interrupts         interrupts ]         total
    892          *                                    disabled      [      enabled            disabled  ]         ovrhd
    893          *                               (via application)
    894          *
    895          *
    896          *                           (B) time       =  time              +  time
    897          *                                   total         interrupts           interrupts
    898          *                                   ovrhd        enabled ovrhd       disabled ovrhd
    899          *
    900          *
    901          *                                   where
    902          *
    903          *                                           time                    time interrupts are disabled between
    904          *                                               interrupts              first critical section enter &
    905          *                                                disabled               last  critical section exit (i.e.
    906          *                                           (via application)           minus total overhead time)
    907          *
    908          *                                           time                    time when interrupts are disabled
    909          *                                               interrupts
    910          *                                                disabled
    911          *
    912          *                                           time                    time when interrupts are  enabled
    913          *                                               interrupts
    914          *                                                enabled
    915          *
    916          *
    917          *                                           time                    total overhead time to disable/enable
    918          *                                               total                   interrupts during critical section
    919          *                                               ovrhd                   enter & exit
    920          *
    921          *                                           time                    total overhead time to disable interrupts
    922          *                                               interrupts              during critical section enter
    923          *                                             disabled ovrhd
    924          *
    925          *                                           time                    total overhead time to enable  interrupts
    926          *                                               interrupts              during critical section exit
    927          *                                              enabled ovrhd
    928          *
    929          *$PAGE*
    930          *
    931          *                       (2) When interrupts disabled time measurements are enabled :
    932          *
    933          *
    934          *        |                                    |                           |                                       |
    935          *        |<----- CRITICAL SECTION ENTER ----->|                           |<------- CRITICAL SECTION EXIT ------->|
    936          *        |                                    |                           |                                       |
    937          *
    938          *                   Time                                                 Time
    939          *     Disable    Measurement                                          Measurement                  Enable
    940          *    Interrupts     Start                                                Stop                    Interrupts
    941          *
    942          *        ||           |                      ||                           ||                         |           ||
    943          *        ||           |                      ||                           ||                         |           ||
    944          *        ||           |        |             ||<------------------------->||               |         |           ||
    945          *        ||       |   |        |<----------->||             |             ||<------------->|         |       |   ||
    946          *        ||       |   |        |      |      ||             |             ||       |       |         |       |   ||
    947          *                 |            |      |                     |                      |       |                 |
    948          *            interrupts       get     |                   time                     |      get            interrupts
    949          *             disabled    start time  |                       interrupts           |   stop time          enabled
    950          *                            meas     |                        disabled            |     meas
    951          *                                   time                  (via application)      time
    952          *                                       start meas                                   stop meas
    953          *                                         ovrhd                                        ovrhd
    954          *
    955          *
    956          *                           (A) time            =  [ time       -  time      ]  -  time
    957          *                                   interrupts     [      stop         start ]         total meas
    958          *                                    disabled      [      meas         meas  ]           ovrhd
    959          *                               (via application)
    960          *
    961          *
    962          *                           (B) time            =  time            +  time
    963          *                                   total meas         start meas         stop meas
    964          *                                     ovrhd              ovrhd              ovrhd
    965          *
    966          *
    967          *                                   where
    968          *
    969          *                                           time                    time interrupts are disabled between first
    970          *                                               interrupts              critical section enter & last critical
    971          *                                                disabled               section exit (i.e. minus measurement
    972          *                                           (via application)           overhead time; however, this does NOT
    973          *                                                                       include any overhead time to disable
    974          *                                                                       or enable interrupts during critical
    975          *                                                                       section enter & exit)
    976          *
    977          *                                           time                    time of disable interrupts start time
    978          *                                               start                   measurement (in timer counts)
    979          *                                               meas
    980          *
    981          *                                           time                    time of disable interrupts stop  time
    982          *                                               stop                    measurement (in timer counts)
    983          *                                               meas
    984          *
    985          *
    986          *                                           time                    total overhead time to start/stop disabled
    987          *                                               total meas              interrupts time measurements (in timer
    988          *                                                 ovrhd                 counts)
    989          *
    990          *                                           time                    total overhead time after getting start
    991          *                                               start meas              time until end of start measurement
    992          *                                                 ovrhd                 function  (in timer counts)
    993          *
    994          *                                           time                    total overhead time from beginning of stop
    995          *                                               stop meas               measurement function until after getting
    996          *                                                 ovrhd                 stop time (in timer counts)
    997          *
    998          *
    999          *$PAGE*
   1000          *                   (b) (1) (A) In order to correctly handle unsigned subtraction overflows of start times
   1001          *                               from stop times, CPU timestamp timer count values MUST be returned via
   1002          *                               word-size-configurable 'CPU_TS_TMR' data type.
   1003          *
   1004          *                               See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()  Note #2a'.
   1005          *
   1006          *                           (B) Since unsigned subtraction of start times from stop times assumes increasing
   1007          *                               values, timestamp timer count values MUST increase with each time count.
   1008          *
   1009          *                               See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()  Note #2b'.
   1010          *
   1011          *                       (2) (A) To expedite & reduce interrupts disabled time measurement overhead; only the
   1012          *                               subtraction of start times from stop times is performed.
   1013          *
   1014          *                           (B) The final calculations to subtract the interrupts disabled time measurement
   1015          *                               overhead is performed asynchronously in appropriate API functions.
   1016          *
   1017          *                               See also 'CPU_IntDisMeasMaxCalc()  Note #1b'.
   1018          *********************************************************************************************************
   1019          */
   1020          
   1021          #ifdef  CPU_CFG_INT_DIS_MEAS_EN

   \                                 In  segment CODE, align 1, keep-with-next
   1022          void  CPU_IntDisMeasStop (void)
   \                     CPU_IntDisMeasStop:
   1023          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000 C3                    PUSH      BC                 ;; 1 cycle
   \   000001 C5                    PUSH      DE                 ;; 1 cycle
   \   000002                       ; Auto size: 0
   1024              CPU_TS_TMR  time_ints_disd_cnts;
   1025          
   1026          
   1027              CPU_IntDisNestCtr--;
   \   000002 B2....                DECW      N:CPU_IntDisNestCtr  ;; 2 cycles
   1028              if (CPU_IntDisNestCtr == 0u) {                                  /* If ints NO longer dis'd,        ...              */
   \   000005 F6                    CLRW      AX                 ;; 1 cycle
   \   000006 42....                CMPW      AX, N:CPU_IntDisNestCtr  ;; 1 cycle
   \   000009 DF45                  BNZ       ??CPU_IntDisMeasMaxCalc_8  ;; 4 cycles
   \   00000B                       ; ------------------------------------- Block: 10 cycles
   1029                  CPU_IntDisMeasStop_cnts = CPU_TS_TmrRd();                   /* ... get  ints dis'd stop time & ...              */
   \   00000B FD....                CALL      CPU_TS_TmrRd       ;; 3 cycles
   \   00000E BF....                MOVW      N:CPU_IntDisMeasStop_cnts, AX  ;; 1 cycle
   \   000011 13                    MOVW      AX, BC             ;; 1 cycle
   \   000012 BF....                MOVW      N:CPU_IntDisMeasStop_cnts+2, AX  ;; 1 cycle
   1030                                                                              /* ... calc ints dis'd tot  time (see Note #1b2A).  */
   1031                  time_ints_disd_cnts     = CPU_IntDisMeasStop_cnts -
   1032                                            CPU_IntDisMeasStart_cnts;
   \   000015 AF....                MOVW      AX, N:CPU_IntDisMeasStop_cnts  ;; 1 cycle
   \   000018 22....                SUBW      AX, N:CPU_IntDisMeasStart_cnts  ;; 1 cycle
   \   00001B 61D8                  SKNC
   \   00001D B3                    DECW      BC                 ;; 5 cycles
   \   00001E 33                    XCHW      AX, BC             ;; 1 cycle
   \   00001F 22....                SUBW      AX, N:CPU_IntDisMeasStart_cnts+2  ;; 1 cycle
   \   000022 33                    XCHW      AX, BC             ;; 1 cycle
   \   000023 14                    MOVW      DE, AX             ;; 1 cycle
   \   000024 C3                    PUSH      BC                 ;; 1 cycle
   \   000025 C6                    POP       HL                 ;; 1 cycle
   1033                                                                              /* Calc max ints dis'd times.                       */
   1034                  if (CPU_IntDisMeasMaxCur_cnts < time_ints_disd_cnts) {
   \   000026 C7                    PUSH      HL                 ;; 1 cycle
   \   000027 C5                    PUSH      DE                 ;; 1 cycle
   \   000028 DB....                MOVW      BC, N:CPU_IntDisMeasMaxCur_cnts+2  ;; 1 cycle
   \   00002B AF....                MOVW      AX, N:CPU_IntDisMeasMaxCur_cnts  ;; 1 cycle
   \   00002E FD....                CALL      N:?UL_CMP_L03      ;; 3 cycles
   \   000031 DE08                  BNC       ??CPU_IntDisMeasMaxCalc_9  ;; 4 cycles
   \   000033                       ; ------------------------------------- Block: 30 cycles
   1035                      CPU_IntDisMeasMaxCur_cnts = time_ints_disd_cnts;
   \   000033 15                    MOVW      AX, DE             ;; 1 cycle
   \   000034 BF....                MOVW      N:CPU_IntDisMeasMaxCur_cnts, AX  ;; 1 cycle
   \   000037 17                    MOVW      AX, HL             ;; 1 cycle
   \   000038 BF....                MOVW      N:CPU_IntDisMeasMaxCur_cnts+2, AX  ;; 1 cycle
   \   00003B                       ; ------------------------------------- Block: 4 cycles
   1036                  }
   1037                  if (CPU_IntDisMeasMax_cnts    < time_ints_disd_cnts) {
   \                     ??CPU_IntDisMeasMaxCalc_9:
   \   00003B C7                    PUSH      HL                 ;; 1 cycle
   \   00003C C5                    PUSH      DE                 ;; 1 cycle
   \   00003D DB....                MOVW      BC, N:CPU_IntDisMeasMax_cnts+2  ;; 1 cycle
   \   000040 AF....                MOVW      AX, N:CPU_IntDisMeasMax_cnts  ;; 1 cycle
   \   000043 FD....                CALL      N:?UL_CMP_L03      ;; 3 cycles
   \   000046 DE08                  BNC       ??CPU_IntDisMeasMaxCalc_8  ;; 4 cycles
   \   000048                       ; ------------------------------------- Block: 11 cycles
   1038                      CPU_IntDisMeasMax_cnts    = time_ints_disd_cnts;
   \   000048 15                    MOVW      AX, DE             ;; 1 cycle
   \   000049 BF....                MOVW      N:CPU_IntDisMeasMax_cnts, AX  ;; 1 cycle
   \   00004C 17                    MOVW      AX, HL             ;; 1 cycle
   \   00004D BF....                MOVW      N:CPU_IntDisMeasMax_cnts+2, AX  ;; 1 cycle
   \   000050                       ; ------------------------------------- Block: 4 cycles
   1039                  }
   1040              }
   1041          }
   \                     ??CPU_IntDisMeasMaxCalc_8:
   \   000050 C4                    POP       DE                 ;; 1 cycle
   \   000051 C2                    POP       BC                 ;; 1 cycle
   \   000052 D7                    RET                          ;; 6 cycles
   \   000053                       ; ------------------------------------- Block: 8 cycles
   \   000053                       ; ------------------------------------- Total: 67 cycles
   \   000053                       REQUIRE ?CLRL78_V1_0_L00
   1042          #endif
   1043          
   1044          
   1045          /*$PAGE*/
   1046          /*
   1047          *********************************************************************************************************
   1048          *                                         CPU_CntLeadZeros()
   1049          *
   1050          * Description : Count the number of contiguous, most-significant, leading zero bits in a data value.
   1051          *
   1052          * Argument(s) : val         Data value to count leading zero bits.
   1053          *
   1054          * Return(s)   : Number of contiguous, most-significant, leading zero bits in 'val', if NO error(s).
   1055          *
   1056          *               DEF_INT_CPU_U_MAX_VAL,                                              otherwise.
   1057          *
   1058          * Caller(s)   : CPU_CntTrailZeros(),
   1059          *               Application.
   1060          *
   1061          *               This function is a CPU module application programming interface (API) function & MAY
   1062          *               be called by application function(s).
   1063          *
   1064          * Note(s)     : (1) (a) Supports the following data value sizes :
   1065          *
   1066          *                       (1)  8-bits
   1067          *                       (2) 16-bits
   1068          *                       (3) 32-bits
   1069          *                       (4) 64-bits
   1070          *
   1071          *                       See also 'cpu_def.h  CPU WORD CONFIGURATION  Note #1'.
   1072          *
   1073          *                   (b) (1) For  8-bit values :
   1074          *
   1075          *                                  b07  b06  b05  b04  b03  b02  b01  b00    # Leading Zeros
   1076          *                                  ---  ---  ---  ---  ---  ---  ---  ---    ---------------
   1077          *                                   1    x    x    x    x    x    x    x            0
   1078          *                                   0    1    x    x    x    x    x    x            1
   1079          *                                   0    0    1    x    x    x    x    x            2
   1080          *                                   0    0    0    1    x    x    x    x            3
   1081          *                                   0    0    0    0    1    x    x    x            4
   1082          *                                   0    0    0    0    0    1    x    x            5
   1083          *                                   0    0    0    0    0    0    1    x            6
   1084          *                                   0    0    0    0    0    0    0    1            7
   1085          *                                   0    0    0    0    0    0    0    0            8
   1086          *
   1087          *
   1088          *                       (2) For 16-bit values :
   1089          *
   1090          *                             b15  b14  b13  ...  b04  b03  b02  b01  b00    # Leading Zeros
   1091          *                             ---  ---  ---       ---  ---  ---  ---  ---    ---------------
   1092          *                              1    x    x         x    x    x    x    x            0
   1093          *                              0    1    x         x    x    x    x    x            1
   1094          *                              0    0    1         x    x    x    x    x            2
   1095          *                              :    :    :         :    :    :    :    :            :
   1096          *                              :    :    :         :    :    :    :    :            :
   1097          *                              0    0    0         1    x    x    x    x           11
   1098          *                              0    0    0         0    1    x    x    x           12
   1099          *                              0    0    0         0    0    1    x    x           13
   1100          *                              0    0    0         0    0    0    1    x           14
   1101          *                              0    0    0         0    0    0    0    1           15
   1102          *                              0    0    0         0    0    0    0    0           16
   1103          *
   1104          *$PAGE*
   1105          *                       (3) For 32-bit values :
   1106          *
   1107          *                             b31  b30  b29  ...  b04  b03  b02  b01  b00    # Leading Zeros
   1108          *                             ---  ---  ---       ---  ---  ---  ---  ---    ---------------
   1109          *                              1    x    x         x    x    x    x    x            0
   1110          *                              0    1    x         x    x    x    x    x            1
   1111          *                              0    0    1         x    x    x    x    x            2
   1112          *                              :    :    :         :    :    :    :    :            :
   1113          *                              :    :    :         :    :    :    :    :            :
   1114          *                              0    0    0         1    x    x    x    x           27
   1115          *                              0    0    0         0    1    x    x    x           28
   1116          *                              0    0    0         0    0    1    x    x           29
   1117          *                              0    0    0         0    0    0    1    x           30
   1118          *                              0    0    0         0    0    0    0    1           31
   1119          *                              0    0    0         0    0    0    0    0           32
   1120          *
   1121          *
   1122          *                       (4) For 64-bit values :
   1123          *
   1124          *                             b63  b62  b61  ...  b04  b03  b02  b01  b00    # Leading Zeros
   1125          *                             ---  ---  ---       ---  ---  ---  ---  ---    ---------------
   1126          *                              1    x    x         x    x    x    x    x            0
   1127          *                              0    1    x         x    x    x    x    x            1
   1128          *                              0    0    1         x    x    x    x    x            2
   1129          *                              :    :    :         :    :    :    :    :            :
   1130          *                              :    :    :         :    :    :    :    :            :
   1131          *                              0    0    0         1    x    x    x    x           59
   1132          *                              0    0    0         0    1    x    x    x           60
   1133          *                              0    0    0         0    0    1    x    x           61
   1134          *                              0    0    0         0    0    0    1    x           62
   1135          *                              0    0    0         0    0    0    0    1           63
   1136          *                              0    0    0         0    0    0    0    0           64
   1137          *
   1138          *
   1139          *                       See also 'CPU COUNT LEAD ZEROs LOOKUP TABLE  Note #1'.
   1140          *********************************************************************************************************
   1141          */
   1142          
   1143          #ifndef   CPU_CFG_LEAD_ZEROS_ASM_PRESENT

   \                                 In  segment CODE, align 1, keep-with-next
   1144          CPU_DATA  CPU_CntLeadZeros (CPU_DATA  val)
   \                     CPU_CntLeadZeros:
   1145          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000                       ; Auto size: 0
   1146              CPU_DATA  nbr_lead_zeros;
   1147          
   1148          
   1149          #if   (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_08)
   1150              nbr_lead_zeros = CPU_CntLeadZeros08((CPU_INT08U)val);
   1151          
   1152          #elif (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_16)
   1153              nbr_lead_zeros = CPU_CntLeadZeros16((CPU_INT16U)val);
   1154          
   1155          #elif (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_32)
   1156              nbr_lead_zeros = CPU_CntLeadZeros32((CPU_INT32U)val);
   1157          
   1158          #elif (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_64)
   1159              nbr_lead_zeros = CPU_CntLeadZeros64((CPU_INT64U)val);
   1160          
   1161          #else                                                           /* See Note #1a.                                        */
   1162              nbr_lead_zeros = DEF_INT_CPU_U_MAX_VAL;
   1163          #endif
   1164          
   1165          
   1166              return (nbr_lead_zeros);
   \   000000 ED....                BR        N:CPU_CntLeadZeros16  ;; 3 cycles
   \   000003                       ; ------------------------------------- Block: 3 cycles
   \   000003                       ; ------------------------------------- Total: 3 cycles
   \   000003                       REQUIRE ?CLRL78_V1_0_L00
   1167          }
   1168          #endif
   1169          
   1170          
   1171          /*$PAGE*/
   1172          /*
   1173          *********************************************************************************************************
   1174          *                                        CPU_CntLeadZeros08()
   1175          *
   1176          * Description : Count the number of contiguous, most-significant, leading zero bits in an 8-bit data value.
   1177          *
   1178          * Argument(s) : val         Data value to count leading zero bits.
   1179          *
   1180          * Return(s)   : Number of contiguous, most-significant, leading zero bits in 'val'.
   1181          *
   1182          * Caller(s)   : CPU_CntLeadZeros(),
   1183          *               CPU_CntTrailZeros08(),
   1184          *               Application.
   1185          *
   1186          *               This function is a CPU module application programming interface (API) function & MAY be
   1187          *               called by application function(s).
   1188          *
   1189          * Note(s)     : (1) Supports  8-bit values :
   1190          *
   1191          *                               b07  b06  b05  b04  b03  b02  b01  b00    # Leading Zeros
   1192          *                               ---  ---  ---  ---  ---  ---  ---  ---    ---------------
   1193          *                                1    x    x    x    x    x    x    x            0
   1194          *                                0    1    x    x    x    x    x    x            1
   1195          *                                0    0    1    x    x    x    x    x            2
   1196          *                                0    0    0    1    x    x    x    x            3
   1197          *                                0    0    0    0    1    x    x    x            4
   1198          *                                0    0    0    0    0    1    x    x            5
   1199          *                                0    0    0    0    0    0    1    x            6
   1200          *                                0    0    0    0    0    0    0    1            7
   1201          *                                0    0    0    0    0    0    0    0            8
   1202          *
   1203          *
   1204          *                   See also 'CPU COUNT LEAD ZEROs LOOKUP TABLE  Note #1'.
   1205          *********************************************************************************************************
   1206          */
   1207          
   1208          #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_08)

   \                                 In  segment CODE, align 1, keep-with-next
   1209          CPU_DATA  CPU_CntLeadZeros08 (CPU_INT08U  val)
   \                     CPU_CntLeadZeros08:
   1210          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000 C3                    PUSH      BC                 ;; 1 cycle
   \   000001                       ; Auto size: 0
   1211          #if  (!((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
   1212                  (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_08)))
   1213              CPU_DATA  ix;
   1214          #endif
   1215              CPU_DATA  nbr_lead_zeros;
   1216          
   1217                                                                                          /* ---------- ASM-OPTIMIZED ----------- */
   1218          #if ((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
   1219               (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_08))
   1220              nbr_lead_zeros  =  CPU_CntLeadZeros((CPU_DATA)val);
   1221              nbr_lead_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_08) * DEF_OCTET_NBR_BITS;
   1222          
   1223          
   1224          #else                                                                           /* ----------- C-OPTIMIZED ------------ */
   1225                                                                                          /* Chk bits [07:00] :                   */
   1226                                                                                          /* .. Nbr lead zeros =               .. */
   1227              ix              = (CPU_DATA)(val >>  0u);                                   /* .. lookup tbl ix  = 'val' >>  0 bits */
   1228              nbr_lead_zeros  = (CPU_DATA)(CPU_CntLeadZerosTbl[ix] +  0u);                /* .. plus nbr msb lead zeros =  0 bits.*/
   1229          #endif
   1230          
   1231          
   1232              return (nbr_lead_zeros);
   \   000001 73                    MOV       B, A               ;; 1 cycle
   \   000002 09....                MOV       A, (CPU_CntLeadZerosTbl & 0xFFFF)[B]  ;; 1 cycle
   \   000005 70                    MOV       X, A               ;; 1 cycle
   \   000006 F1                    CLRB      A                  ;; 1 cycle
   \   000007 C2                    POP       BC                 ;; 1 cycle
   \   000008 D7                    RET                          ;; 6 cycles
   \   000009                       ; ------------------------------------- Block: 12 cycles
   \   000009                       ; ------------------------------------- Total: 12 cycles
   \   000009                       REQUIRE ?CLRL78_V1_0_L00
   1233          }
   1234          #endif
   1235          
   1236          
   1237          /*$PAGE*/
   1238          /*
   1239          *********************************************************************************************************
   1240          *                                        CPU_CntLeadZeros16()
   1241          *
   1242          * Description : Count the number of contiguous, most-significant, leading zero bits in a 16-bit data value.
   1243          *
   1244          * Argument(s) : val         Data value to count leading zero bits.
   1245          *
   1246          * Return(s)   : Number of contiguous, most-significant, leading zero bits in 'val'.
   1247          *
   1248          * Caller(s)   : CPU_CntLeadZeros(),
   1249          *               CPU_CntTrailZeros16(),
   1250          *               Application.
   1251          *
   1252          *               This function is a CPU module application programming interface (API) function & MAY be
   1253          *               called by application function(s).
   1254          *
   1255          * Note(s)     : (1) Supports 16-bit values :
   1256          *
   1257          *                          b15  b14  b13  ...  b04  b03  b02  b01  b00    # Leading Zeros
   1258          *                          ---  ---  ---       ---  ---  ---  ---  ---    ---------------
   1259          *                           1    x    x         x    x    x    x    x            0
   1260          *                           0    1    x         x    x    x    x    x            1
   1261          *                           0    0    1         x    x    x    x    x            2
   1262          *                           :    :    :         :    :    :    :    :            :
   1263          *                           :    :    :         :    :    :    :    :            :
   1264          *                           0    0    0         1    x    x    x    x           11
   1265          *                           0    0    0         0    1    x    x    x           12
   1266          *                           0    0    0         0    0    1    x    x           13
   1267          *                           0    0    0         0    0    0    1    x           14
   1268          *                           0    0    0         0    0    0    0    1           15
   1269          *                           0    0    0         0    0    0    0    0           16
   1270          *
   1271          *
   1272          *                   See also 'CPU COUNT LEAD ZEROs LOOKUP TABLE  Note #1'.
   1273          *********************************************************************************************************
   1274          */
   1275          
   1276          #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_16)

   \                                 In  segment CODE, align 1, keep-with-next
   1277          CPU_DATA  CPU_CntLeadZeros16 (CPU_INT16U  val)
   \                     CPU_CntLeadZeros16:
   1278          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000 C3                    PUSH      BC                 ;; 1 cycle
   \   000001                       ; Auto size: 0
   1279          #if  (!((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
   1280                  (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_16)))
   1281              CPU_DATA  ix;
   1282          #endif
   1283              CPU_DATA  nbr_lead_zeros;
   1284          
   1285                                                                                          /* ---------- ASM-OPTIMIZED ----------- */
   1286          #if ((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
   1287               (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_16))
   1288              nbr_lead_zeros  =  CPU_CntLeadZeros((CPU_DATA)val);
   1289              nbr_lead_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_16) * DEF_OCTET_NBR_BITS;
   1290          
   1291          
   1292          #else                                                                           /* ----------- C-OPTIMIZED ------------ */
   1293              if (val > 0x00FFu) {                                                        /* Chk bits [15:08] :                   */
   \   000001 440001                CMPW      AX, #0x100         ;; 1 cycle
   \   000004 DC07                  BC        ??CPU_IntDisMeasMaxCalc_10  ;; 4 cycles
   \   000006                       ; ------------------------------------- Block: 6 cycles
   1294                                                                                          /* .. Nbr lead zeros =               .. */
   1295                  ix             = (CPU_DATA)(val >>  8u);                                /* .. lookup tbl ix  = 'val' >>  8 bits */
   1296                  nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix] +  0u);             /* .. plus nbr msb lead zeros =  0 bits.*/
   \   000006 F0                    CLRB      X                  ;; 1 cycle
   \   000007 08                    XCH       A, X               ;; 1 cycle
   \   000008 FD....                CALL      N:?Subroutine8     ;; 3 cycles
   \   00000B                       ; ------------------------------------- Block: 5 cycles
   1297          
   1298              } else {                                                                    /* Chk bits [07:00] :                   */
   \                     ??CrossCallReturnLabel_12:
   \   00000B EF06                  BR        S:??CPU_IntDisMeasMaxCalc_11  ;; 3 cycles
   \   00000D                       ; ------------------------------------- Block: 3 cycles
   1299                                                                                          /* .. Nbr lead zeros =               .. */
   1300                  ix             = (CPU_DATA)(val >>  0u);                                /* .. lookup tbl ix  = 'val' >>  0 bits */
   1301                  nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix] +  8u);             /* .. plus nbr msb lead zeros =  8 bits.*/
   \                     ??CPU_IntDisMeasMaxCalc_10:
   \   00000D FD....                CALL      N:?Subroutine8     ;; 3 cycles
   \   000010                       ; ------------------------------------- Block: 3 cycles
   1302              }
   \                     ??CrossCallReturnLabel_13:
   \   000010 040800                ADDW      AX, #0x8           ;; 1 cycle
   \   000013                       ; ------------------------------------- Block: 1 cycles
   1303          #endif
   1304          
   1305          
   1306              return (nbr_lead_zeros);
   \                     ??CPU_IntDisMeasMaxCalc_11:
   \   000013 C2                    POP       BC                 ;; 1 cycle
   \   000014 D7                    RET                          ;; 6 cycles
   \   000015                       ; ------------------------------------- Block: 7 cycles
   \   000015                       ; ------------------------------------- Total: 25 cycles
   \   000015                       REQUIRE ?CLRL78_V1_0_L00
   1307          }

   \                                 In  segment CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000 12                    MOVW      BC, AX             ;; 1 cycle
   \   000001 49....                MOV       A, (CPU_CntLeadZerosTbl & 0xFFFF)[BC]  ;; 1 cycle
   \   000004 70                    MOV       X, A               ;; 1 cycle
   \   000005 F1                    CLRB      A                  ;; 1 cycle
   \   000006 D7                    RET                          ;; 6 cycles
   \   000007                       ; ------------------------------------- Block: 10 cycles
   \   000007                       ; ------------------------------------- Total: 10 cycles
   \   000007                       REQUIRE ?CLRL78_V1_0_L00
   1308          #endif
   1309          
   1310          
   1311          /*$PAGE*/
   1312          /*
   1313          *********************************************************************************************************
   1314          *                                        CPU_CntLeadZeros32()
   1315          *
   1316          * Description : Count the number of contiguous, most-significant, leading zero bits in a 32-bit data value.
   1317          *
   1318          * Argument(s) : val         Data value to count leading zero bits.
   1319          *
   1320          * Return(s)   : Number of contiguous, most-significant, leading zero bits in 'val'.
   1321          *
   1322          * Caller(s)   : CPU_CntLeadZeros(),
   1323          *               CPU_CntTrailZeros32(),
   1324          *               Application.
   1325          *
   1326          *               This function is a CPU module application programming interface (API) function & MAY be
   1327          *               called by application function(s).
   1328          *
   1329          * Note(s)     : (1) Supports 32-bit values :
   1330          *
   1331          *                          b31  b30  b29  ...  b04  b03  b02  b01  b00    # Leading Zeros
   1332          *                          ---  ---  ---       ---  ---  ---  ---  ---    ---------------
   1333          *                           1    x    x         x    x    x    x    x            0
   1334          *                           0    1    x         x    x    x    x    x            1
   1335          *                           0    0    1         x    x    x    x    x            2
   1336          *                           :    :    :         :    :    :    :    :            :
   1337          *                           :    :    :         :    :    :    :    :            :
   1338          *                           0    0    0         1    x    x    x    x           27
   1339          *                           0    0    0         0    1    x    x    x           28
   1340          *                           0    0    0         0    0    1    x    x           29
   1341          *                           0    0    0         0    0    0    1    x           30
   1342          *                           0    0    0         0    0    0    0    1           31
   1343          *                           0    0    0         0    0    0    0    0           32
   1344          *
   1345          *
   1346          *                   See also 'CPU COUNT LEAD ZEROs LOOKUP TABLE  Note #1'.
   1347          *********************************************************************************************************
   1348          */
   1349          
   1350          #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_32)

   \                                 In  segment CODE, align 1, keep-with-next
   1351          CPU_DATA  CPU_CntLeadZeros32 (CPU_INT32U  val)
   \                     CPU_CntLeadZeros32:
   1352          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000 C5                    PUSH      DE                 ;; 1 cycle
   \   000001                       ; Auto size: 0
   1353          #if  (!((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
   1354                  (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_32)))
   1355              CPU_DATA  ix;
   1356          #endif
   1357              CPU_DATA  nbr_lead_zeros;
   1358          
   1359                                                                                          /* ---------- ASM-OPTIMIZED ----------- */
   1360          #if ((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
   1361               (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_32))
   1362              nbr_lead_zeros  =  CPU_CntLeadZeros((CPU_DATA)val);
   1363              nbr_lead_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_32) * DEF_OCTET_NBR_BITS;
   1364          
   1365          
   1366          #else                                                                           /* ----------- C-OPTIMIZED ------------ */
   1367              if (val > 0x0000FFFFu) {
   \   000001 33                    XCHW      AX, BC             ;; 1 cycle
   \   000002 440100                CMPW      AX, #0x1           ;; 1 cycle
   \   000005 33                    XCHW      AX, BC             ;; 1 cycle
   \   000006 61F8                  SKNZ                         ;; 4 cycles
   \   000008                       ; ------------------------------------- Block: 8 cycles
   \   000008 440000                CMPW      AX, #0x0           ;; 1 cycle
   \   00000B                       ; ------------------------------------- Block: 1 cycles
   \                     ??CPU_CntLeadZeros32_0:
   \   00000B 33                    XCHW      AX, BC             ;; 1 cycle
   \   00000C DC1F                  BC        ??CPU_IntDisMeasMaxCalc_12  ;; 4 cycles
   \   00000E                       ; ------------------------------------- Block: 5 cycles
   1368                  if (val > 0x00FFFFFFu) {                                                /* Chk bits [31:24] :                   */
   \   00000E 440001                CMPW      AX, #0x100         ;; 1 cycle
   \   000011 33                    XCHW      AX, BC             ;; 1 cycle
   \   000012 61F8                  SKNZ                         ;; 4 cycles
   \   000014                       ; ------------------------------------- Block: 6 cycles
   \   000014 440000                CMPW      AX, #0x0           ;; 1 cycle
   \   000017                       ; ------------------------------------- Block: 1 cycles
   \                     ??CPU_CntLeadZeros32_1:
   \   000017 DC0A                  BC        ??CPU_IntDisMeasMaxCalc_13  ;; 4 cycles
   \   000019                       ; ------------------------------------- Block: 4 cycles
   1369                                                                                          /* .. Nbr lead zeros =               .. */
   1370                      ix             = (CPU_DATA)(val >> 24u);                            /* .. lookup tbl ix  = 'val' >> 24 bits */
   1371                      nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix] +  0u);         /* .. plus nbr msb lead zeros =  0 bits.*/
   \   000019 5418                  MOV       E, #0x18           ;; 1 cycle
   \   00001B FD....                CALL      N:?UL_RSH_L03      ;; 3 cycles
   \   00001E FD....                CALL      N:?Subroutine8     ;; 3 cycles
   \   000021                       ; ------------------------------------- Block: 7 cycles
   1372          
   1373                  } else {                                                                /* Chk bits [23:16] :                   */
   \                     ??CrossCallReturnLabel_14:
   \   000021 EF25                  BR        S:??CPU_IntDisMeasMaxCalc_14  ;; 3 cycles
   \   000023                       ; ------------------------------------- Block: 3 cycles
   1374                                                                                          /* .. Nbr lead zeros =               .. */
   1375                      ix             = (CPU_DATA)(val >> 16u);                            /* .. lookup tbl ix  = 'val' >> 16 bits */
   1376                      nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix] +  8u);         /* .. plus nbr msb lead zeros =  8 bits.*/
   \                     ??CPU_IntDisMeasMaxCalc_13:
   \   000023 49....                MOV       A, (CPU_CntLeadZerosTbl & 0xFFFF)[BC]  ;; 1 cycle
   \   000026 70                    MOV       X, A               ;; 1 cycle
   \   000027 F1                    CLRB      A                  ;; 1 cycle
   \   000028 040800                ADDW      AX, #0x8           ;; 1 cycle
   \   00002B EF1B                  BR        S:??CPU_IntDisMeasMaxCalc_14  ;; 3 cycles
   \   00002D                       ; ------------------------------------- Block: 7 cycles
   1377                  }
   1378          
   1379              } else {
   1380                  if (val > 0x000000FFu) {                                                /* Chk bits [15:08] :                   */
   \                     ??CPU_IntDisMeasMaxCalc_12:
   \   00002D 440000                CMPW      AX, #0x0           ;; 1 cycle
   \   000030 33                    XCHW      AX, BC             ;; 1 cycle
   \   000031 61F8                  SKNZ                         ;; 4 cycles
   \   000033                       ; ------------------------------------- Block: 6 cycles
   \   000033 440001                CMPW      AX, #0x100         ;; 1 cycle
   \   000036                       ; ------------------------------------- Block: 1 cycles
   \                     ??CPU_CntLeadZeros32_2:
   \   000036 DC0A                  BC        ??CPU_IntDisMeasMaxCalc_15  ;; 4 cycles
   \   000038                       ; ------------------------------------- Block: 4 cycles
   1381                                                                                          /* .. Nbr lead zeros =               .. */
   1382                      ix             = (CPU_DATA)(val >>  8u);                            /* .. lookup tbl ix  = 'val' >>  8 bits */
   1383                      nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix] + 16u);         /* .. plus nbr msb lead zeros = 16 bits.*/
   \   000038 70                    MOV       X, A               ;; 1 cycle
   \   000039 62                    MOV       A, C               ;; 1 cycle
   \   00003A FD....                CALL      N:?Subroutine8     ;; 3 cycles
   \   00003D                       ; ------------------------------------- Block: 5 cycles
   1384          
   1385                  } else {                                                                /* Chk bits [07:00] :                   */
   \                     ??CrossCallReturnLabel_15:
   \   00003D 041000                ADDW      AX, #0x10          ;; 1 cycle
   \   000040 EF06                  BR        S:??CPU_IntDisMeasMaxCalc_14  ;; 3 cycles
   \   000042                       ; ------------------------------------- Block: 4 cycles
   1386                                                                                          /* .. Nbr lead zeros =               .. */
   1387                      ix             = (CPU_DATA)(val >>  0u);                            /* .. lookup tbl ix  = 'val' >>  0 bits */
   1388                      nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix] + 24u);         /* .. plus nbr msb lead zeros = 24 bits.*/
   \                     ??CPU_IntDisMeasMaxCalc_15:
   \   000042 FD....                CALL      N:?Subroutine8     ;; 3 cycles
   \   000045                       ; ------------------------------------- Block: 3 cycles
   1389                  }
   1390              }
   \                     ??CrossCallReturnLabel_16:
   \   000045 041800                ADDW      AX, #0x18          ;; 1 cycle
   \   000048                       ; ------------------------------------- Block: 1 cycles
   1391          #endif
   1392          
   1393          
   1394              return (nbr_lead_zeros);
   \                     ??CPU_IntDisMeasMaxCalc_14:
   \   000048 C4                    POP       DE                 ;; 1 cycle
   \   000049 D7                    RET                          ;; 6 cycles
   \   00004A                       ; ------------------------------------- Block: 7 cycles
   \   00004A                       ; ------------------------------------- Total: 73 cycles
   \   00004A                       REQUIRE ?CLRL78_V1_0_L00
   1395          }
   1396          #endif
   1397          
   1398          
   1399          /*$PAGE*/
   1400          /*
   1401          *********************************************************************************************************
   1402          *                                        CPU_CntLeadZeros64()
   1403          *
   1404          * Description : Count the number of contiguous, most-significant, leading zero bits in a 64-bit data value.
   1405          *
   1406          * Argument(s) : val         Data value to count leading zero bits.
   1407          *
   1408          * Return(s)   : Number of contiguous, most-significant, leading zero bits in 'val'.
   1409          *
   1410          * Caller(s)   : CPU_CntLeadZeros(),
   1411          *               CPU_CntTrailZeros64(),
   1412          *               Application.
   1413          *
   1414          *               This function is a CPU module application programming interface (API) function & MAY be
   1415          *               called by application function(s).
   1416          *
   1417          * Note(s)     : (1) Supports 64-bit values :
   1418          *
   1419          *                          b63  b62  b61  ...  b04  b03  b02  b01  b00    # Leading Zeros
   1420          *                          ---  ---  ---       ---  ---  ---  ---  ---    ---------------
   1421          *                           1    x    x         x    x    x    x    x            0
   1422          *                           0    1    x         x    x    x    x    x            1
   1423          *                           0    0    1         x    x    x    x    x            2
   1424          *                           :    :    :         :    :    :    :    :            :
   1425          *                           :    :    :         :    :    :    :    :            :
   1426          *                           0    0    0         1    x    x    x    x           59
   1427          *                           0    0    0         0    1    x    x    x           60
   1428          *                           0    0    0         0    0    1    x    x           61
   1429          *                           0    0    0         0    0    0    1    x           62
   1430          *                           0    0    0         0    0    0    0    1           63
   1431          *                           0    0    0         0    0    0    0    0           64
   1432          *
   1433          *
   1434          *                   See also 'CPU COUNT LEAD ZEROs LOOKUP TABLE  Note #1'.
   1435          *********************************************************************************************************
   1436          */
   1437          /*$PAGE*/
   1438          #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_64)
   1439          CPU_DATA  CPU_CntLeadZeros64 (CPU_INT64U  val)
   1440          {
   1441          #if  (!((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
   1442                  (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_64)))
   1443              CPU_DATA  ix;
   1444          #endif
   1445              CPU_DATA  nbr_lead_zeros;
   1446          
   1447                                                                                          /* ---------- ASM-OPTIMIZED ----------- */
   1448          #if ((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
   1449               (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_64))
   1450              nbr_lead_zeros  =  CPU_CntLeadZeros((CPU_DATA)val);
   1451              nbr_lead_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_64) * DEF_OCTET_NBR_BITS;
   1452          
   1453          
   1454          #else                                                                           /* ----------- C-OPTIMIZED ------------ */
   1455              if (val > 0x00000000FFFFFFFFu) {
   1456                  if (val > 0x0000FFFFFFFFFFFFu) {
   1457                      if (val > 0x00FFFFFFFFFFFFFFu) {                                    /* Chk bits [63:56] :                   */
   1458                                                                                          /* .. Nbr lead zeros =               .. */
   1459                          ix             = (CPU_DATA)(val >> 56u);                        /* .. lookup tbl ix  = 'val' >> 56 bits */
   1460                          nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix] +  0u);     /* .. plus nbr msb lead zeros =  0 bits.*/
   1461          
   1462                      } else {                                                            /* Chk bits [55:48] :                   */
   1463                                                                                          /* .. Nbr lead zeros =               .. */
   1464                          ix             = (CPU_DATA)(val >> 48u);                        /* .. lookup tbl ix  = 'val' >> 48 bits */
   1465                          nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix] +  8u);     /* .. plus nbr msb lead zeros =  8 bits.*/
   1466                      }
   1467          
   1468                  } else {
   1469                      if (val > 0x000000FFFFFFFFFFu) {                                    /* Chk bits [47:40] :                   */
   1470                                                                                          /* .. Nbr lead zeros =               .. */
   1471                          ix             = (CPU_DATA)(val >> 40u);                        /* .. lookup tbl ix  = 'val' >> 40 bits */
   1472                          nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix] + 16u);     /* .. plus nbr msb lead zeros = 16 bits.*/
   1473          
   1474                      } else {                                                            /* Chk bits [39:32] :                   */
   1475                                                                                          /* .. Nbr lead zeros =               .. */
   1476                          ix             = (CPU_DATA)(val >> 32u);                        /* .. lookup tbl ix  = 'val' >> 32 bits */
   1477                          nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix] + 24u);     /* .. plus nbr msb lead zeros = 24 bits.*/
   1478                      }
   1479                  }
   1480          
   1481              } else {
   1482                  if (val > 0x000000000000FFFFu) {
   1483                      if (val > 0x0000000000FFFFFFu) {                                    /* Chk bits [31:24] :                   */
   1484                                                                                          /* .. Nbr lead zeros =               .. */
   1485                          ix             = (CPU_DATA)(val >> 24u);                        /* .. lookup tbl ix  = 'val' >> 24 bits */
   1486                          nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix] + 32u);     /* .. plus nbr msb lead zeros = 32 bits.*/
   1487          
   1488                      } else {                                                            /* Chk bits [23:16] :                   */
   1489                                                                                          /* .. Nbr lead zeros =               .. */
   1490                          ix             = (CPU_DATA)(val >> 16u);                        /* .. lookup tbl ix  = 'val' >> 16 bits */
   1491                          nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix] + 40u);     /* .. plus nbr msb lead zeros = 40 bits.*/
   1492                      }
   1493          
   1494                  } else {
   1495                      if (val > 0x00000000000000FFu) {                                    /* Chk bits [15:08] :                   */
   1496                                                                                          /* .. Nbr lead zeros =               .. */
   1497                          ix             = (CPU_DATA)(val >>  8u);                        /* .. lookup tbl ix  = 'val' >>  8 bits */
   1498                          nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix] + 48u);     /* .. plus nbr msb lead zeros = 48 bits.*/
   1499          
   1500                      } else {                                                            /* Chk bits [07:00] :                   */
   1501                                                                                          /* .. Nbr lead zeros =               .. */
   1502                          ix             = (CPU_DATA)(val >>  0u);                        /* .. lookup tbl ix  = 'val' >>  0 bits */
   1503                          nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix] + 56u);     /* .. plus nbr msb lead zeros = 56 bits.*/
   1504                      }
   1505                  }
   1506              }
   1507          #endif
   1508          
   1509          
   1510              return (nbr_lead_zeros);
   1511          }
   1512          #endif
   1513          
   1514          
   1515          /*$PAGE*/
   1516          /*
   1517          *********************************************************************************************************
   1518          *                                         CPU_CntTrailZeros()
   1519          *
   1520          * Description : Count the number of contiguous, least-significant, trailing zero bits in a data value.
   1521          *
   1522          * Argument(s) : val         Data value to count trailing zero bits.
   1523          *
   1524          * Return(s)   : Number of contiguous, least-significant, trailing zero bits in 'val'.
   1525          *
   1526          * Caller(s)   : Application.
   1527          *
   1528          *               This function is a CPU module application programming interface (API) function & MAY
   1529          *               be called by application function(s).
   1530          *
   1531          * Note(s)     : (1) (a) Supports the following data value sizes :
   1532          *
   1533          *                       (1)  8-bits
   1534          *                       (2) 16-bits
   1535          *                       (3) 32-bits
   1536          *                       (4) 64-bits
   1537          *
   1538          *                       See also 'cpu_def.h  CPU WORD CONFIGURATION  Note #1'.
   1539          *
   1540          *                   (b) (1) For  8-bit values :
   1541          *
   1542          *                                  b07  b06  b05  b04  b03  b02  b01  b00    # Trailing Zeros
   1543          *                                  ---  ---  ---  ---  ---  ---  ---  ---    ----------------
   1544          *                                   x    x    x    x    x    x    x    1            0
   1545          *                                   x    x    x    x    x    x    1    0            1
   1546          *                                   x    x    x    x    x    1    0    0            2
   1547          *                                   x    x    x    x    1    0    0    0            3
   1548          *                                   x    x    x    1    0    0    0    0            4
   1549          *                                   x    x    1    0    0    0    0    0            5
   1550          *                                   x    1    0    0    0    0    0    0            6
   1551          *                                   1    0    0    0    0    0    0    0            7
   1552          *                                   0    0    0    0    0    0    0    0            8
   1553          *
   1554          *
   1555          *                       (2) For 16-bit values :
   1556          *
   1557          *                             b15  b14  b13  b12  b11  ...  b02  b01  b00    # Trailing Zeros
   1558          *                             ---  ---  ---  ---  ---       ---  ---  ---    ----------------
   1559          *                              x    x    x    x    x         x    x    1            0
   1560          *                              x    x    x    x    x         x    1    0            1
   1561          *                              x    x    x    x    x         1    0    0            2
   1562          *                              :    :    :    :    :         :    :    :            :
   1563          *                              :    :    :    :    :         :    :    :            :
   1564          *                              x    x    x    x    1         0    0    0           11
   1565          *                              x    x    x    1    0         0    0    0           12
   1566          *                              x    x    1    0    0         0    0    0           13
   1567          *                              x    1    0    0    0         0    0    0           14
   1568          *                              1    0    0    0    0         0    0    0           15
   1569          *                              0    0    0    0    0         0    0    0           16
   1570          *
   1571          *
   1572          *                       (3) For 32-bit values :
   1573          *
   1574          *                             b31  b30  b29  b28  b27  ...  b02  b01  b00    # Trailing Zeros
   1575          *                             ---  ---  ---  ---  ---       ---  ---  ---    ----------------
   1576          *                              x    x    x    x    x         x    x    1            0
   1577          *                              x    x    x    x    x         x    1    0            1
   1578          *                              x    x    x    x    x         1    0    0            2
   1579          *                              :    :    :    :    :         :    :    :            :
   1580          *                              :    :    :    :    :         :    :    :            :
   1581          *                              x    x    x    x    1         0    0    0           27
   1582          *                              x    x    x    1    0         0    0    0           28
   1583          *                              x    x    1    0    0         0    0    0           29
   1584          *                              x    1    0    0    0         0    0    0           30
   1585          *                              1    0    0    0    0         0    0    0           31
   1586          *                              0    0    0    0    0         0    0    0           32
   1587          *
   1588          *
   1589          *                       (4) For 64-bit values :
   1590          *
   1591          *                             b63  b62  b61  b60  b59  ...  b02  b01  b00    # Trailing Zeros
   1592          *                             ---  ---  ---  ---  ---       ---  ---  ---    ----------------
   1593          *                              x    x    x    x    x         x    x    1            0
   1594          *                              x    x    x    x    x         x    1    0            1
   1595          *                              x    x    x    x    x         1    0    0            2
   1596          *                              :    :    :    :    :         :    :    :            :
   1597          *                              :    :    :    :    :         :    :    :            :
   1598          *                              x    x    x    x    1         0    0    0           59
   1599          *                              x    x    x    1    0         0    0    0           60
   1600          *                              x    x    1    0    0         0    0    0           61
   1601          *                              x    1    0    0    0         0    0    0           62
   1602          *                              1    0    0    0    0         0    0    0           63
   1603          *                              0    0    0    0    0         0    0    0           64
   1604          *
   1605          *$PAGE*
   1606          *               (2) For non-zero values, the returned number of contiguous, least-significant, trailing
   1607          *                   zero bits is also equivalent to the bit position of the least-significant set bit.
   1608          *
   1609          *               (3) 'val' SHOULD be validated for non-'0' PRIOR to all other counting zero calculations :
   1610          *
   1611          *                   (a) CPU_CntTrailZeros()'s final conditional statement calculates 'val's number of
   1612          *                       trailing zeros based on its return data size, 'CPU_CFG_DATA_SIZE', & 'val's
   1613          *                       calculated number of lead zeros ONLY if the initial 'val' is non-'0' :
   1614          *
   1615          *                           if (val != 0u) {
   1616          *                               nbr_trail_zeros = ((CPU_CFG_DATA_SIZE * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
   1617          *                           } else {
   1618          *                               nbr_trail_zeros = nbr_lead_zeros;
   1619          *                           }
   1620          *
   1621          *                       Therefore, initially validating all non-'0' values avoids having to conditionally
   1622          *                       execute the final 'if' statement.
   1623          *********************************************************************************************************
   1624          */
   1625          
   1626          #ifndef   CPU_CFG_TRAIL_ZEROS_ASM_PRESENT

   \                                 In  segment CODE, align 1, keep-with-next
   1627          CPU_DATA  CPU_CntTrailZeros (CPU_DATA  val)
   \                     CPU_CntTrailZeros:
   1628          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000                       ; Auto size: 0
   1629              CPU_DATA  val_bit_mask;
   1630              CPU_DATA  nbr_lead_zeros;
   1631              CPU_DATA  nbr_trail_zeros;
   1632          
   1633          
   1634              if (val == 0u) {                                            /* Rtn ALL val bits as zero'd (see Note #3).            */
   \   000000 440000                CMPW      AX, #0x0           ;; 1 cycle
   \   000003 DF04                  BNZ       ??CPU_IntDisMeasMaxCalc_16  ;; 4 cycles
   \   000005                       ; ------------------------------------- Block: 5 cycles
   1635                  return (CPU_CFG_DATA_SIZE * DEF_OCTET_NBR_BITS);
   \   000005 301000                MOVW      AX, #0x10          ;; 1 cycle
   \   000008 D7                    RET                          ;; 6 cycles
   \   000009                       ; ------------------------------------- Block: 7 cycles
   1636              }
   1637          
   1638          
   1639              val_bit_mask    = val & ((CPU_DATA)~val + 1u);              /* Zero/clr all bits EXCEPT least-sig set bit.          */
   1640              nbr_lead_zeros  = CPU_CntLeadZeros(val_bit_mask);           /* Cnt  nbr lead  0s.                                   */
   1641                                                                          /* Calc nbr trail 0s = (nbr val bits - 1) - nbr lead 0s.*/
   1642              nbr_trail_zeros = ((CPU_CFG_DATA_SIZE * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
   1643          
   1644          
   1645              return (nbr_trail_zeros);
   \                     ??CPU_IntDisMeasMaxCalc_16:
   \   000009 FD....                CALL      N:?Subroutine7     ;; 3 cycles
   \   00000C                       ; ------------------------------------- Block: 3 cycles
   \                     ??CrossCallReturnLabel_10:
   \   00000C FD....                CALL      CPU_CntLeadZeros   ;; 3 cycles
   \   00000F                       ; ------------------------------------- Block: 3 cycles
   \   00000F                       ; ------------------------------------- Total: 18 cycles
   \   00000F                       REQUIRE ?CLRL78_V1_0_L00
   \   00000F                       REQUIRE ?Subroutine2
   \   00000F                       ; // Fall through to label ?Subroutine2
   1646          }

   \                                 In  segment CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000 16                    MOVW      HL, AX             ;; 1 cycle
   \   000001 300F00                MOVW      AX, #0xF           ;; 1 cycle
   \   000004 27                    SUBW      AX, HL             ;; 1 cycle
   \   000005 D7                    RET                          ;; 6 cycles
   \   000006                       ; ------------------------------------- Block: 9 cycles
   \   000006                       ; ------------------------------------- Total: 9 cycles
   \   000006                       REQUIRE ?CLRL78_V1_0_L00

   \                                 In  segment CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000 16                    MOVW      HL, AX             ;; 1 cycle
   \   000001 7CFF                  XOR       A, #0xFF           ;; 1 cycle
   \   000003 08                    XCH       A, X               ;; 1 cycle
   \   000004 7CFF                  XOR       A, #0xFF           ;; 1 cycle
   \   000006 08                    XCH       A, X               ;; 1 cycle
   \   000007 37                    XCHW      AX, HL             ;; 1 cycle
   \   000008 A7                    INCW      HL                 ;; 1 cycle
   \   000009 615F                  AND       A, H               ;; 1 cycle
   \   00000B 08                    XCH       A, X               ;; 1 cycle
   \   00000C 615E                  AND       A, L               ;; 1 cycle
   \   00000E 08                    XCH       A, X               ;; 1 cycle
   \   00000F D7                    RET                          ;; 6 cycles
   \   000010                       ; ------------------------------------- Block: 17 cycles
   \   000010                       ; ------------------------------------- Total: 17 cycles
   \   000010                       REQUIRE ?CLRL78_V1_0_L00
   1647          #endif
   1648          
   1649          
   1650          /*$PAGE*/
   1651          /*
   1652          *********************************************************************************************************
   1653          *                                        CPU_CntTrailZeros08()
   1654          *
   1655          * Description : Count the number of contiguous, least-significant, trailing zero bits in an 8-bit data value.
   1656          *
   1657          * Argument(s) : val         Data value to count trailing zero bits.
   1658          *
   1659          * Return(s)   : Number of contiguous, least-significant, trailing zero bits in 'val'.
   1660          *
   1661          * Caller(s)   : Application.
   1662          *
   1663          *               This function is a CPU module application programming interface (API) function & MAY be
   1664          *               called by application function(s).
   1665          *
   1666          * Note(s)     : (1) Supports  8-bit values :
   1667          *
   1668          *                               b07  b06  b05  b04  b03  b02  b01  b00    # Trailing Zeros
   1669          *                               ---  ---  ---  ---  ---  ---  ---  ---    ----------------
   1670          *                                x    x    x    x    x    x    x    1            0
   1671          *                                x    x    x    x    x    x    1    0            1
   1672          *                                x    x    x    x    x    1    0    0            2
   1673          *                                x    x    x    x    1    0    0    0            3
   1674          *                                x    x    x    1    0    0    0    0            4
   1675          *                                x    x    1    0    0    0    0    0            5
   1676          *                                x    1    0    0    0    0    0    0            6
   1677          *                                1    0    0    0    0    0    0    0            7
   1678          *                                0    0    0    0    0    0    0    0            8
   1679          *
   1680          *
   1681          *               (2) For non-zero values, the returned number of contiguous, least-significant, trailing
   1682          *                   zero bits is also equivalent to the bit position of the least-significant set bit.
   1683          *
   1684          *               (3) 'val' SHOULD be validated for non-'0' PRIOR to all other counting zero calculations :
   1685          *
   1686          *                   (a) For assembly-optimized implementations, CPU_CntTrailZeros() returns 'val's
   1687          *                       number of trailing zeros via CPU's native data size, 'CPU_CFG_DATA_SIZE'.
   1688          *                       If the returned number of zeros exceeds CPU_CntTrailZeros08()'s  8-bit return
   1689          *                       data size, then the returned number of zeros must be offset by the difference
   1690          *                       between CPU_CntTrailZeros()'s  & CPU_CntTrailZeros08()'s return data size :
   1691          *
   1692          *                           nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
   1693          *                           if (nbr_trail_zeros >  (CPU_WORD_SIZE_08  * DEF_OCTET_NBR_BITS)) {
   1694          *                               nbr_trail_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_08) * DEF_OCTET_NBR_BITS;
   1695          *                           }
   1696          *
   1697          *                       However, this ONLY occurs for an initial 'val' of '0' since all non-'0'  8-bit
   1698          *                       values would return a number of trailing zeros less than or equal to  8 bits.
   1699          *
   1700          *                       Therefore, initially validating all non-'0' values prior to calling assembly-
   1701          *                       optimized CPU_CntTrailZeros() avoids having to offset the number of returned
   1702          *                       trailing zeros by the difference in CPU data size and  8-bit data value bits.
   1703          *
   1704          *                   (b) For CPU_CntTrailZeros08()'s C implementation, the final conditional statement
   1705          *                       calculates 'val's number of trailing zeros based on CPU_CntTrailZeros08()'s
   1706          *                        8-bit return data size & 'val's calculated number of lead zeros ONLY if the
   1707          *                       initial 'val' is non-'0' :
   1708          *
   1709          *                           if (val != 0u) {
   1710          *                               nbr_trail_zeros = ((CPU_WORD_SIZE_08 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
   1711          *                           } else {
   1712          *                               nbr_trail_zeros = nbr_lead_zeros;
   1713          *                           }
   1714          *
   1715          *                       Therefore, initially validating all non-'0' values avoids having to conditionally
   1716          *                       execute the final 'if' statement.
   1717          *********************************************************************************************************
   1718          */
   1719          /*$PAGE*/
   1720          #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_08)

   \                                 In  segment CODE, align 1, keep-with-next
   1721          CPU_DATA  CPU_CntTrailZeros08 (CPU_INT08U  val)
   \                     CPU_CntTrailZeros08:
   1722          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000 C3                    PUSH      BC                 ;; 1 cycle
   \   000001                       ; Auto size: 0
   1723          #if  (!((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
   1724                  (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_08)))
   1725              CPU_INT08U  val_bit_mask;
   1726              CPU_DATA    nbr_lead_zeros;
   1727          #endif
   1728              CPU_DATA    nbr_trail_zeros;
   1729          
   1730          
   1731              if (val == 0u) {                                            /* Rtn ALL val bits as zero'd (see Note #3).            */
   \   000001 D1                    CMP0      A                  ;; 1 cycle
   \   000002 DF05                  BNZ       ??CPU_IntDisMeasMaxCalc_17  ;; 4 cycles
   \   000004                       ; ------------------------------------- Block: 6 cycles
   1732                  return (CPU_WORD_SIZE_08 * DEF_OCTET_NBR_BITS);
   \   000004 300800                MOVW      AX, #0x8           ;; 1 cycle
   \   000007 EF12                  BR        S:??CPU_IntDisMeasMaxCalc_18  ;; 3 cycles
   \   000009                       ; ------------------------------------- Block: 4 cycles
   1733              }
   1734          
   1735                                                                          /* ------------------ ASM-OPTIMIZED ------------------- */
   1736          #if ((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
   1737               (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_08))
   1738              nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
   1739          
   1740          #else                                                           /* ------------------- C-OPTIMIZED -------------------- */
   1741              val_bit_mask    = val & ((CPU_INT08U)~val + 1u);            /* Zero/clr all bits EXCEPT least-sig set bit.          */
   1742              nbr_lead_zeros  = CPU_CntLeadZeros08(val_bit_mask);         /* Cnt  nbr lead  0s.                                   */
   1743                                                                          /* Calc nbr trail 0s = (nbr val bits - 1) - nbr lead 0s.*/
   1744              nbr_trail_zeros = ((CPU_WORD_SIZE_08 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
   1745          #endif
   1746          
   1747          
   1748              return (nbr_trail_zeros);
   \                     ??CPU_IntDisMeasMaxCalc_17:
   \   000009 70                    MOV       X, A               ;; 1 cycle
   \   00000A 7CFF                  XOR       A, #0xFF           ;; 1 cycle
   \   00000C 08                    XCH       A, X               ;; 1 cycle
   \   00000D 80                    INC       X                  ;; 1 cycle
   \   00000E 6158                  AND       A, X               ;; 1 cycle
   \   000010 73                    MOV       B, A               ;; 1 cycle
   \   000011 09....                MOV       A, (CPU_CntLeadZerosTbl & 0xFFFF)[B]  ;; 1 cycle
   \   000014 76                    MOV       L, A               ;; 1 cycle
   \   000015 5700                  MOV       H, #0x0            ;; 1 cycle
   \   000017 300700                MOVW      AX, #0x7           ;; 1 cycle
   \   00001A 27                    SUBW      AX, HL             ;; 1 cycle
   \   00001B                       ; ------------------------------------- Block: 11 cycles
   \                     ??CPU_IntDisMeasMaxCalc_18:
   \   00001B C2                    POP       BC                 ;; 1 cycle
   \   00001C D7                    RET                          ;; 6 cycles
   \   00001D                       ; ------------------------------------- Block: 7 cycles
   \   00001D                       ; ------------------------------------- Total: 28 cycles
   \   00001D                       REQUIRE ?CLRL78_V1_0_L00
   1749          }
   1750          #endif
   1751          
   1752          
   1753          /*$PAGE*/
   1754          /*
   1755          *********************************************************************************************************
   1756          *                                        CPU_CntTrailZeros16()
   1757          *
   1758          * Description : Count the number of contiguous, least-significant, trailing zero bits in a 16-bit data value.
   1759          *
   1760          * Argument(s) : val         Data value to count trailing zero bits.
   1761          *
   1762          * Return(s)   : Number of contiguous, least-significant, trailing zero bits in 'val'.
   1763          *
   1764          * Caller(s)   : Application.
   1765          *
   1766          *               This function is a CPU module application programming interface (API) function & MAY be
   1767          *               called by application function(s).
   1768          *
   1769          * Note(s)     : (1) Supports 16-bit values :
   1770          *
   1771          *                          b15  b14  b13  b12  b11  ...  b02  b01  b00    # Trailing Zeros
   1772          *                          ---  ---  ---  ---  ---       ---  ---  ---    ----------------
   1773          *                           x    x    x    x    x         x    x    1            0
   1774          *                           x    x    x    x    x         x    1    0            1
   1775          *                           x    x    x    x    x         1    0    0            2
   1776          *                           :    :    :    :    :         :    :    :            :
   1777          *                           :    :    :    :    :         :    :    :            :
   1778          *                           x    x    x    x    1         0    0    0           11
   1779          *                           x    x    x    1    0         0    0    0           12
   1780          *                           x    x    1    0    0         0    0    0           13
   1781          *                           x    1    0    0    0         0    0    0           14
   1782          *                           1    0    0    0    0         0    0    0           15
   1783          *                           0    0    0    0    0         0    0    0           16
   1784          *
   1785          *
   1786          *               (2) For non-zero values, the returned number of contiguous, least-significant, trailing
   1787          *                   zero bits is also equivalent to the bit position of the least-significant set bit.
   1788          *
   1789          *               (3) 'val' SHOULD be validated for non-'0' PRIOR to all other counting zero calculations :
   1790          *
   1791          *                   (a) For assembly-optimized implementations, CPU_CntTrailZeros() returns 'val's
   1792          *                       number of trailing zeros via CPU's native data size, 'CPU_CFG_DATA_SIZE'.
   1793          *                       If the returned number of zeros exceeds CPU_CntTrailZeros16()'s 16-bit return
   1794          *                       data size, then the returned number of zeros must be offset by the difference
   1795          *                       between CPU_CntTrailZeros()'s  & CPU_CntTrailZeros16()'s return data size :
   1796          *
   1797          *                           nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
   1798          *                           if (nbr_trail_zeros >  (CPU_WORD_SIZE_16  * DEF_OCTET_NBR_BITS)) {
   1799          *                               nbr_trail_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_16) * DEF_OCTET_NBR_BITS;
   1800          *                           }
   1801          *
   1802          *                       However, this ONLY occurs for an initial 'val' of '0' since all non-'0' 16-bit
   1803          *                       values would return a number of trailing zeros less than or equal to 16 bits.
   1804          *
   1805          *                       Therefore, initially validating all non-'0' values prior to calling assembly-
   1806          *                       optimized CPU_CntTrailZeros() avoids having to offset the number of returned
   1807          *                       trailing zeros by the difference in CPU data size and 16-bit data value bits.
   1808          *
   1809          *                   (b) For CPU_CntTrailZeros16()'s C implementation, the final conditional statement
   1810          *                       calculates 'val's number of trailing zeros based on CPU_CntTrailZeros16()'s
   1811          *                       16-bit return data size & 'val's calculated number of lead zeros ONLY if the
   1812          *                       initial 'val' is non-'0' :
   1813          *
   1814          *                           if (val != 0u) {
   1815          *                               nbr_trail_zeros = ((CPU_WORD_SIZE_16 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
   1816          *                           } else {
   1817          *                               nbr_trail_zeros = nbr_lead_zeros;
   1818          *                           }
   1819          *
   1820          *                       Therefore, initially validating all non-'0' values avoids having to conditionally
   1821          *                       execute the final 'if' statement.
   1822          *********************************************************************************************************
   1823          */
   1824          /*$PAGE*/
   1825          #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_16)

   \                                 In  segment CODE, align 1, keep-with-next
   1826          CPU_DATA  CPU_CntTrailZeros16 (CPU_INT16U  val)
   \                     CPU_CntTrailZeros16:
   1827          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000                       ; Auto size: 0
   1828          #if  (!((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
   1829                  (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_16)))
   1830              CPU_INT16U  val_bit_mask;
   1831              CPU_DATA    nbr_lead_zeros;
   1832          #endif
   1833              CPU_DATA    nbr_trail_zeros;
   1834          
   1835          
   1836              if (val == 0u) {                                            /* Rtn ALL val bits as zero'd (see Note #3).            */
   \   000000 440000                CMPW      AX, #0x0           ;; 1 cycle
   \   000003 DF04                  BNZ       ??CPU_IntDisMeasMaxCalc_19  ;; 4 cycles
   \   000005                       ; ------------------------------------- Block: 5 cycles
   1837                  return (CPU_WORD_SIZE_16 * DEF_OCTET_NBR_BITS);
   \   000005 301000                MOVW      AX, #0x10          ;; 1 cycle
   \   000008 D7                    RET                          ;; 6 cycles
   \   000009                       ; ------------------------------------- Block: 7 cycles
   1838              }
   1839          
   1840                                                                          /* ------------------ ASM-OPTIMIZED ------------------- */
   1841          #if ((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
   1842               (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_16))
   1843              nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
   1844          
   1845          #else                                                           /* ------------------- C-OPTIMIZED -------------------- */
   1846              val_bit_mask    = val & ((CPU_INT16U)~val + 1u);            /* Zero/clr all bits EXCEPT least-sig set bit.          */
   1847              nbr_lead_zeros  = CPU_CntLeadZeros16(val_bit_mask);         /* Cnt  nbr lead  0s.                                   */
   1848                                                                          /* Calc nbr trail 0s = (nbr val bits - 1) - nbr lead 0s.*/
   1849              nbr_trail_zeros = ((CPU_WORD_SIZE_16 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
   1850          #endif
   1851          
   1852          
   1853              return (nbr_trail_zeros);
   \                     ??CPU_IntDisMeasMaxCalc_19:
   \   000009 FD....                CALL      N:?Subroutine7     ;; 3 cycles
   \   00000C                       ; ------------------------------------- Block: 3 cycles
   \                     ??CrossCallReturnLabel_11:
   \   00000C FD....                CALL      CPU_CntLeadZeros16  ;; 3 cycles
   \   00000F ED....                BR        N:?Subroutine2     ;; 3 cycles
   \   000012                       ; ------------------------------------- Block: 6 cycles
   \   000012                       ; ------------------------------------- Total: 21 cycles
   \   000012                       REQUIRE ?CLRL78_V1_0_L00
   1854          }
   1855          #endif
   1856          
   1857          
   1858          /*$PAGE*/
   1859          /*
   1860          *********************************************************************************************************
   1861          *                                        CPU_CntTrailZeros32()
   1862          *
   1863          * Description : Count the number of contiguous, least-significant, trailing zero bits in a 32-bit data value.
   1864          *
   1865          * Argument(s) : val         Data value to count trailing zero bits.
   1866          *
   1867          * Return(s)   : Number of contiguous, least-significant, trailing zero bits in 'val'.
   1868          *
   1869          * Caller(s)   : Application.
   1870          *
   1871          *               This function is a CPU module application programming interface (API) function & MAY be
   1872          *               called by application function(s).
   1873          *
   1874          * Note(s)     : (1) Supports 32-bit values :
   1875          *
   1876          *                          b31  b30  b29  b28  b27  ...  b02  b01  b00    # Trailing Zeros
   1877          *                          ---  ---  ---  ---  ---       ---  ---  ---    ----------------
   1878          *                           x    x    x    x    x         x    x    1            0
   1879          *                           x    x    x    x    x         x    1    0            1
   1880          *                           x    x    x    x    x         1    0    0            2
   1881          *                           :    :    :    :    :         :    :    :            :
   1882          *                           :    :    :    :    :         :    :    :            :
   1883          *                           x    x    x    x    1         0    0    0           27
   1884          *                           x    x    x    1    0         0    0    0           28
   1885          *                           x    x    1    0    0         0    0    0           29
   1886          *                           x    1    0    0    0         0    0    0           30
   1887          *                           1    0    0    0    0         0    0    0           31
   1888          *                           0    0    0    0    0         0    0    0           32
   1889          *
   1890          *
   1891          *               (2) For non-zero values, the returned number of contiguous, least-significant, trailing
   1892          *                   zero bits is also equivalent to the bit position of the least-significant set bit.
   1893          *
   1894          *               (3) 'val' SHOULD be validated for non-'0' PRIOR to all other counting zero calculations :
   1895          *
   1896          *                   (a) For assembly-optimized implementations, CPU_CntTrailZeros() returns 'val's
   1897          *                       number of trailing zeros via CPU's native data size, 'CPU_CFG_DATA_SIZE'.
   1898          *                       If the returned number of zeros exceeds CPU_CntTrailZeros32()'s 32-bit return
   1899          *                       data size, then the returned number of zeros must be offset by the difference
   1900          *                       between CPU_CntTrailZeros()'s  & CPU_CntTrailZeros32()'s return data size :
   1901          *
   1902          *                           nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
   1903          *                           if (nbr_trail_zeros >  (CPU_WORD_SIZE_32  * DEF_OCTET_NBR_BITS)) {
   1904          *                               nbr_trail_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_32) * DEF_OCTET_NBR_BITS;
   1905          *                           }
   1906          *
   1907          *                       However, this ONLY occurs for an initial 'val' of '0' since all non-'0' 32-bit
   1908          *                       values would return a number of trailing zeros less than or equal to 32 bits.
   1909          *
   1910          *                       Therefore, initially validating all non-'0' values prior to calling assembly-
   1911          *                       optimized CPU_CntTrailZeros() avoids having to offset the number of returned
   1912          *                       trailing zeros by the difference in CPU data size and 32-bit data value bits.
   1913          *
   1914          *                   (b) For CPU_CntTrailZeros32()'s C implementation, the final conditional statement
   1915          *                       calculates 'val's number of trailing zeros based on CPU_CntTrailZeros32()'s
   1916          *                       32-bit return data size & 'val's calculated number of lead zeros ONLY if the
   1917          *                       initial 'val' is non-'0' :
   1918          *
   1919          *                           if (val != 0u) {
   1920          *                               nbr_trail_zeros = ((CPU_WORD_SIZE_32 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
   1921          *                           } else {
   1922          *                               nbr_trail_zeros = nbr_lead_zeros;
   1923          *                           }
   1924          *
   1925          *                       Therefore, initially validating all non-'0' values avoids having to conditionally
   1926          *                       execute the final 'if' statement.
   1927          *********************************************************************************************************
   1928          */
   1929          /*$PAGE*/
   1930          #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_32)

   \                                 In  segment CODE, align 1, keep-with-next
   1931          CPU_DATA  CPU_CntTrailZeros32 (CPU_INT32U  val)
   \                     CPU_CntTrailZeros32:
   1932          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000 C5                    PUSH      DE                 ;; 1 cycle
   \   000001                       ; Auto size: 0
   \   000001 14                    MOVW      DE, AX             ;; 1 cycle
   \   000002 C3                    PUSH      BC                 ;; 1 cycle
   \   000003 C6                    POP       HL                 ;; 1 cycle
   1933          #if  (!((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
   1934                  (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_32)))
   1935              CPU_INT32U  val_bit_mask;
   1936              CPU_DATA    nbr_lead_zeros;
   1937          #endif
   1938              CPU_DATA    nbr_trail_zeros;
   1939          
   1940          
   1941              if (val == 0u) {                                            /* Rtn ALL val bits as zero'd (see Note #3).            */
   \   000004 37                    XCHW      AX, HL             ;; 1 cycle
   \   000005 F7                    CLRW      BC                 ;; 1 cycle
   \   000006 43                    CMPW      AX, BC             ;; 1 cycle
   \   000007 37                    XCHW      AX, HL             ;; 1 cycle
   \   000008 61F8                  SKNZ                         ;; 4 cycles
   \   00000A                       ; ------------------------------------- Block: 12 cycles
   \   00000A 43                    CMPW      AX, BC             ;; 1 cycle
   \   00000B                       ; ------------------------------------- Block: 1 cycles
   \                     ??CPU_CntTrailZeros32_0:
   \   00000B DF05                  BNZ       ??CPU_IntDisMeasMaxCalc_20  ;; 4 cycles
   \   00000D                       ; ------------------------------------- Block: 4 cycles
   1942                  return (CPU_WORD_SIZE_32 * DEF_OCTET_NBR_BITS);
   \   00000D 302000                MOVW      AX, #0x20          ;; 1 cycle
   \   000010 EF1B                  BR        S:??CPU_IntDisMeasMaxCalc_21  ;; 3 cycles
   \   000012                       ; ------------------------------------- Block: 4 cycles
   1943              }
   1944          
   1945                                                                          /* ------------------ ASM-OPTIMIZED ------------------- */
   1946          #if ((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
   1947               (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_32))
   1948              nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
   1949          
   1950          #else                                                           /* ------------------- C-OPTIMIZED -------------------- */
   1951              val_bit_mask    = val & ((CPU_INT32U)~val + 1u);            /* Zero/clr all bits EXCEPT least-sig set bit.          */
   1952              nbr_lead_zeros  = CPU_CntLeadZeros32(val_bit_mask);         /* Cnt  nbr lead  0s.                                   */
   1953                                                                          /* Calc nbr trail 0s = (nbr val bits - 1) - nbr lead 0s.*/
   1954              nbr_trail_zeros = ((CPU_WORD_SIZE_32 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
   1955          #endif
   1956          
   1957          
   1958              return (nbr_trail_zeros);
   \                     ??CPU_IntDisMeasMaxCalc_20:
   \   000012 C7                    PUSH      HL                 ;; 1 cycle
   \   000013 C2                    POP       BC                 ;; 1 cycle
   \   000014 FD....                CALL      N:?L_NOT_L03       ;; 3 cycles
   \   000017 040100                ADDW      AX, #0x1           ;; 1 cycle
   \   00001A 61D8                  SKNC
   \   00001C A3                    INCW      BC                 ;; 5 cycles
   \   00001D C3                    PUSH      BC                 ;; 1 cycle
   \   00001E C1                    PUSH      AX                 ;; 1 cycle
   \   00001F 15                    MOVW      AX, DE             ;; 1 cycle
   \   000020 C7                    PUSH      HL                 ;; 1 cycle
   \   000021 C2                    POP       BC                 ;; 1 cycle
   \   000022 FD....                CALL      N:?L_AND_L03       ;; 3 cycles
   \   000025 FD....                CALL      CPU_CntLeadZeros32  ;; 3 cycles
   \   000028 16                    MOVW      HL, AX             ;; 1 cycle
   \   000029 301F00                MOVW      AX, #0x1F          ;; 1 cycle
   \   00002C 27                    SUBW      AX, HL             ;; 1 cycle
   \   00002D                       ; ------------------------------------- Block: 25 cycles
   \                     ??CPU_IntDisMeasMaxCalc_21:
   \   00002D C4                    POP       DE                 ;; 1 cycle
   \   00002E D7                    RET                          ;; 6 cycles
   \   00002F                       ; ------------------------------------- Block: 7 cycles
   \   00002F                       ; ------------------------------------- Total: 53 cycles
   \   00002F                       REQUIRE ?CLRL78_V1_0_L00
   1959          }
   1960          #endif
   1961          
   1962          
   1963          /*$PAGE*/
   1964          /*
   1965          *********************************************************************************************************
   1966          *                                        CPU_CntTrailZeros64()
   1967          *
   1968          * Description : Count the number of contiguous, least-significant, trailing zero bits in a 64-bit data value.
   1969          *
   1970          * Argument(s) : val         Data value to count trailing zero bits.
   1971          *
   1972          * Return(s)   : Number of contiguous, least-significant, trailing zero bits in 'val'.
   1973          *
   1974          * Caller(s)   : Application.
   1975          *
   1976          *               This function is a CPU module application programming interface (API) function & MAY be
   1977          *               called by application function(s).
   1978          *
   1979          * Note(s)     : (1) Supports 64-bit values :
   1980          *
   1981          *                          b63  b62  b61  b60  b59  ...  b02  b01  b00    # Trailing Zeros
   1982          *                          ---  ---  ---  ---  ---       ---  ---  ---    ----------------
   1983          *                           x    x    x    x    x         x    x    1            0
   1984          *                           x    x    x    x    x         x    1    0            1
   1985          *                           x    x    x    x    x         1    0    0            2
   1986          *                           :    :    :    :    :         :    :    :            :
   1987          *                           :    :    :    :    :         :    :    :            :
   1988          *                           x    x    x    x    1         0    0    0           59
   1989          *                           x    x    x    1    0         0    0    0           60
   1990          *                           x    x    1    0    0         0    0    0           61
   1991          *                           x    1    0    0    0         0    0    0           62
   1992          *                           1    0    0    0    0         0    0    0           63
   1993          *                           0    0    0    0    0         0    0    0           64
   1994          *
   1995          *
   1996          *               (2) For non-zero values, the returned number of contiguous, least-significant, trailing
   1997          *                   zero bits is also equivalent to the bit position of the least-significant set bit.
   1998          *
   1999          *               (3) 'val' SHOULD be validated for non-'0' PRIOR to all other counting zero calculations :
   2000          *
   2001          *                   (a) For assembly-optimized implementations, CPU_CntTrailZeros() returns 'val's
   2002          *                       number of trailing zeros via CPU's native data size, 'CPU_CFG_DATA_SIZE'.
   2003          *                       If the returned number of zeros exceeds CPU_CntTrailZeros64()'s 64-bit return
   2004          *                       data size, then the returned number of zeros must be offset by the difference
   2005          *                       between CPU_CntTrailZeros()'s  & CPU_CntTrailZeros64()'s return data size :
   2006          *
   2007          *                           nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
   2008          *                           if (nbr_trail_zeros >  (CPU_WORD_SIZE_64  * DEF_OCTET_NBR_BITS)) {
   2009          *                               nbr_trail_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_64) * DEF_OCTET_NBR_BITS;
   2010          *                           }
   2011          *
   2012          *                       However, this ONLY occurs for an initial 'val' of '0' since all non-'0' 64-bit
   2013          *                       values would return a number of trailing zeros less than or equal to 64 bits.
   2014          *
   2015          *                       Therefore, initially validating all non-'0' values prior to calling assembly-
   2016          *                       optimized CPU_CntTrailZeros() avoids having to offset the number of returned
   2017          *                       trailing zeros by the difference in CPU data size and 64-bit data value bits.
   2018          *
   2019          *                   (b) For CPU_CntTrailZeros64()'s C implementation, the final conditional statement
   2020          *                       calculates 'val's number of trailing zeros based on CPU_CntTrailZeros64()'s
   2021          *                       64-bit return data size & 'val's calculated number of lead zeros ONLY if the
   2022          *                       initial 'val' is non-'0' :
   2023          *
   2024          *                           if (val != 0u) {
   2025          *                               nbr_trail_zeros = ((CPU_WORD_SIZE_64 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
   2026          *                           } else {
   2027          *                               nbr_trail_zeros = nbr_lead_zeros;
   2028          *                           }
   2029          *
   2030          *                       Therefore, initially validating all non-'0' values avoids having to conditionally
   2031          *                       execute the final 'if' statement.
   2032          *********************************************************************************************************
   2033          */
   2034          /*$PAGE*/
   2035          #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_64)
   2036          CPU_DATA  CPU_CntTrailZeros64 (CPU_INT64U  val)
   2037          {
   2038          #if  (!((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
   2039                  (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_64)))
   2040              CPU_INT64U  val_bit_mask;
   2041              CPU_DATA    nbr_lead_zeros;
   2042          #endif
   2043              CPU_DATA    nbr_trail_zeros;
   2044          
   2045          
   2046              if (val == 0u) {                                            /* Rtn ALL val bits as zero'd (see Note #3).            */
   2047                  return (CPU_WORD_SIZE_64 * DEF_OCTET_NBR_BITS);
   2048              }
   2049          
   2050                                                                          /* ------------------ ASM-OPTIMIZED ------------------- */
   2051          #if ((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
   2052               (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_64))
   2053              nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
   2054          
   2055          #else                                                           /* ------------------- C-OPTIMIZED -------------------- */
   2056              val_bit_mask    = val & ((CPU_INT64U)~val + 1u);            /* Zero/clr all bits EXCEPT least-sig set bit.          */
   2057              nbr_lead_zeros  = CPU_CntLeadZeros64(val_bit_mask);         /* Cnt  nbr lead  0s.                                   */
   2058                                                                          /* Calc nbr trail 0s = (nbr val bits - 1) - nbr lead 0s.*/
   2059              nbr_trail_zeros = ((CPU_WORD_SIZE_64 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
   2060          #endif
   2061          
   2062          
   2063              return (nbr_trail_zeros);
   2064          }
   2065          #endif
   2066          
   2067          
   2068          /*$PAGE*/
   2069          /*
   2070          *********************************************************************************************************
   2071          *********************************************************************************************************
   2072          *                                           LOCAL FUNCTIONS
   2073          *********************************************************************************************************
   2074          *********************************************************************************************************
   2075          */
   2076          
   2077          /*
   2078          *********************************************************************************************************
   2079          *                                           CPU_NameInit()
   2080          *
   2081          * Description : Initialize CPU Name.
   2082          *
   2083          * Argument(s) : none.
   2084          *
   2085          * Return(s)   : none.
   2086          *
   2087          * Caller(s)   : CPU_Init().
   2088          *
   2089          * Note(s)     : none.
   2090          *********************************************************************************************************
   2091          */
   2092          
   2093          #if (CPU_CFG_NAME_EN == DEF_ENABLED)
   2094          static  void  CPU_NameInit (void)
   2095          {
   2096              CPU_NameClr();
   2097          }
   2098          #endif
   2099          
   2100          
   2101          /*$PAGE*/
   2102          /*
   2103          *********************************************************************************************************
   2104          *                                            CPU_TS_Init()
   2105          *
   2106          * Description : (1) Initialize CPU timestamp :
   2107          *
   2108          *                   (a) Initialize/start CPU timestamp timer                            See Note #1
   2109          *                   (b) Initialize       CPU timestamp controls
   2110          *
   2111          *
   2112          * Argument(s) : none.
   2113          *
   2114          * Return(s)   : none.
   2115          *
   2116          * Caller(s)   : CPU_Init().
   2117          *
   2118          * Note(s)     : (1) The following initialization MUST be sequenced as follows :
   2119          *
   2120          *                   (a) CPU_TS_TmrFreq_Hz     MUST be initialized prior to CPU_TS_TmrInit()
   2121          *                   (b) CPU_TS_TmrInit()      SHOULD precede calls to all other CPU timestamp functions;
   2122          *                                                 otherwise, invalid time measurements may be calculated/
   2123          *                                                 returned.
   2124          *
   2125          *                   See also 'CPU_Init()  Note #3a'.
   2126          *********************************************************************************************************
   2127          */
   2128          
   2129          #if ((CPU_CFG_TS_EN     == DEF_ENABLED) || \
   2130               (CPU_CFG_TS_TMR_EN == DEF_ENABLED))
   2131          static  void  CPU_TS_Init (void)
   2132          {
   2133          #if (((CPU_CFG_TS_32_EN    == DEF_ENABLED     )  && \
   2134                (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_32)) || \
   2135               ((CPU_CFG_TS_64_EN    == DEF_ENABLED     )  && \
   2136                (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_64)))
   2137              CPU_TS_TMR  ts_tmr_cnts;
   2138          #endif
   2139          
   2140          
   2141                                                                          /* ----------------- INIT CPU TS TMR ------------------ */
   2142          #if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)
   2143              CPU_TS_TmrFreq_Hz   = 0u;                                   /* Init/clr     ts tmr freq (see Note #1a).             */
   2144              CPU_TS_TmrInit();                                           /* Init & start ts tmr      (see Note #1b).             */
   2145          #endif
   2146          
   2147          
   2148                                                                          /* ------------------- INIT CPU TS -------------------- */
   2149          #if (((CPU_CFG_TS_32_EN    == DEF_ENABLED     )  && \
   2150                (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_32)) || \
   2151               ((CPU_CFG_TS_64_EN    == DEF_ENABLED     )  && \
   2152                (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_64)))
   2153              ts_tmr_cnts = CPU_TS_TmrRd();                               /* Get init ts tmr val (in ts tmr cnts).                */
   2154          #endif
   2155          
   2156          #if  ((CPU_CFG_TS_32_EN    == DEF_ENABLED)  && \
   2157                (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_32))
   2158              CPU_TS_32_Accum   = 0u;                                     /* Init 32-bit accum'd ts.                              */
   2159              CPU_TS_32_TmrPrev = ts_tmr_cnts;                            /* Init 32-bit ts prev tmr val.                         */
   2160          #endif
   2161          
   2162          #if  ((CPU_CFG_TS_64_EN    == DEF_ENABLED)  && \
   2163                (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_64))
   2164              CPU_TS_64_Accum   = 0u;                                     /* Init 64-bit accum'd ts.                              */
   2165              CPU_TS_64_TmrPrev = ts_tmr_cnts;                            /* Init 64-bit ts prev tmr val.                         */
   2166          #endif
   2167          }
   2168          #endif
   2169          
   2170          
   2171          /*$PAGE*/
   2172          /*
   2173          *********************************************************************************************************
   2174          *                                        CPU_IntDisMeasInit()
   2175          *
   2176          * Description : (1) Initialize interrupts disabled time measurements feature :
   2177          *
   2178          *                   (a) Initialize interrupts disabled time measurement controls
   2179          *                   (b) Calculate  interrupts disabled time measurement overhead
   2180          *
   2181          *
   2182          * Argument(s) : none.
   2183          *
   2184          * Return(s)   : none.
   2185          *
   2186          * Caller(s)   : CPU_Init().
   2187          *
   2188          * Note(s)     : (2) CPU_IntDisMeasInit() SHOULD precede ALL calls to CPU_CRITICAL_ENTER()/CPU_CRITICAL_EXIT()
   2189          *                   & other CPU interrupts disabled time measurement functions; otherwise, invalid interrupts
   2190          *                   disabled time measurements may be calculated/returned.
   2191          *
   2192          *                   See also 'CPU_Init()  Note #3b'.
   2193          *
   2194          *               (3) (a) (1) Interrupts disabled time measurement overhead performed multiple times to calculate
   2195          *                           a rounded average with better accuracy, hopefully of +/- one timer count.
   2196          *
   2197          *                       (2) However, a single overhead time measurement is recommended, even for instruction-
   2198          *                           cache-enabled CPUs, since critical sections are NOT typically called within
   2199          *                           instruction-cached loops.  Thus a single non-cached/non-averaged time measurement
   2200          *                           is a more realistic overhead for the majority of non-cached interrupts disabled
   2201          *                           time measurements.
   2202          *
   2203          *                   (b) Interrupts MUST be disabled while measuring the interrupts disabled time measurement
   2204          *                       overhead; otherwise, overhead measurements could be interrupted which would incorrectly
   2205          *                       calculate an inflated overhead time which would then incorrectly calculate deflated
   2206          *                       interrupts disabled times.
   2207          *********************************************************************************************************
   2208          */
   2209          
   2210          #ifdef  CPU_CFG_INT_DIS_MEAS_EN

   \                                 In  segment CODE, align 1, keep-with-next
   2211          static  void  CPU_IntDisMeasInit (void)
   \                     CPU_IntDisMeasInit:
   2212          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000 C3                    PUSH      BC                 ;; 1 cycle
   \   000001 C5                    PUSH      DE                 ;; 1 cycle
   \   000002                       ; Auto size: 0
   2213              CPU_TS_TMR  time_meas_tot_cnts;
   2214              CPU_INT16U  i;
   2215              CPU_SR_ALLOC();
   2216          
   2217                                                                          /* ----------- INIT INT DIS TIME MEAS CTRLS ----------- */
   2218              CPU_IntDisMeasCtr         = 0u;
   \   000002 F6                    CLRW      AX                 ;; 1 cycle
   \   000003 BF....                MOVW      N:CPU_IntDisMeasCtr, AX  ;; 1 cycle
   2219              CPU_IntDisNestCtr         = 0u;
   \   000006 BF....                MOVW      N:CPU_IntDisNestCtr, AX  ;; 1 cycle
   2220              CPU_IntDisMeasStart_cnts  = 0u;
   \   000009 36....                MOVW      HL, #CPU_IntDisMeasStart_cnts  ;; 1 cycle
   \   00000C BB                    MOVW      [HL], AX           ;; 1 cycle
   \   00000D BC02                  MOVW      [HL+0x02], AX      ;; 1 cycle
   2221              CPU_IntDisMeasStop_cnts   = 0u;
   \   00000F 36....                MOVW      HL, #CPU_IntDisMeasStop_cnts  ;; 1 cycle
   \   000012 BB                    MOVW      [HL], AX           ;; 1 cycle
   \   000013 BC02                  MOVW      [HL+0x02], AX      ;; 1 cycle
   2222              CPU_IntDisMeasMaxCur_cnts = 0u;
   \   000015 36....                MOVW      HL, #CPU_IntDisMeasMaxCur_cnts  ;; 1 cycle
   \   000018 FD....                CALL      N:?Subroutine5     ;; 3 cycles
   \   00001B                       ; ------------------------------------- Block: 15 cycles
   2223              CPU_IntDisMeasMax_cnts    = 0u;
   2224              CPU_IntDisMeasOvrhd_cnts  = 0u;
   \                     ??CrossCallReturnLabel_5:
   \   00001B 36....                MOVW      HL, #CPU_IntDisMeasOvrhd_cnts  ;; 1 cycle
   \   00001E BB                    MOVW      [HL], AX           ;; 1 cycle
   \   00001F BC02                  MOVW      [HL+0x02], AX      ;; 1 cycle
   2225          
   2226                                                                          /* ----------- CALC INT DIS TIME MEAS OVRHD ----------- */
   2227              time_meas_tot_cnts = 0u;
   2228              CPU_INT_DIS();                                              /* Ints MUST be dis'd for ovrhd calc (see Note #3b).    */
   \   000021 8EFA                  MOV       A, PSW             ;; 1 cycle
   \   000023 73                    MOV       B, A               ;; 1 cycle
   \   000024 717BFA                DI                           ;; 2 cycles
   2229              for (i = 0u; i < CPU_CFG_INT_DIS_MEAS_OVRHD_NBR; i++) {
   2230                  CPU_IntDisMeasMaxCur_cnts = 0u;
   2231                  CPU_IntDisMeasStart();                                  /* Perform multiple consecutive start/stop time meas's  */
   \   000027 FD....                CALL      CPU_IntDisMeasStart  ;; 3 cycles
   2232                  CPU_IntDisMeasStop();
   \   00002A FD....                CALL      CPU_IntDisMeasStop  ;; 3 cycles
   2233                  time_meas_tot_cnts += CPU_IntDisMeasMaxCur_cnts;        /* ...       & sum time meas max's                  ... */
   2234              }
   2235                                                                          /* ... to calc avg time meas ovrhd (see Note #3a).      */
   2236              CPU_IntDisMeasOvrhd_cnts  = (time_meas_tot_cnts + (CPU_CFG_INT_DIS_MEAS_OVRHD_NBR / 2u))
   2237                                                              /  CPU_CFG_INT_DIS_MEAS_OVRHD_NBR;
   \   00002D FB....                MOVW      HL, N:CPU_IntDisMeasMaxCur_cnts+2  ;; 1 cycle
   \   000030 AF....                MOVW      AX, N:CPU_IntDisMeasMaxCur_cnts  ;; 1 cycle
   \   000033 BF....                MOVW      N:CPU_IntDisMeasOvrhd_cnts, AX  ;; 1 cycle
   \   000036 17                    MOVW      AX, HL             ;; 1 cycle
   \   000037 BF....                MOVW      N:CPU_IntDisMeasOvrhd_cnts+2, AX  ;; 1 cycle
   2238              CPU_IntDisMeasMaxCur_cnts =  0u;                            /* Reset max ints dis'd times.                          */
   \   00003A 36....                MOVW      HL, #CPU_IntDisMeasMaxCur_cnts  ;; 1 cycle
   \   00003D F6                    CLRW      AX                 ;; 1 cycle
   \   00003E FD....                CALL      N:?Subroutine5     ;; 3 cycles
   \   000041                       ; ------------------------------------- Block: 23 cycles
   2239              CPU_IntDisMeasMax_cnts    =  0u;
   2240              CPU_INT_EN();
   \                     ??CrossCallReturnLabel_6:
   \   000041 63                    MOV       A, B               ;; 1 cycle
   \   000042 ED....                BR        N:?Subroutine1     ;; 3 cycles
   \   000045                       ; ------------------------------------- Block: 4 cycles
   \   000045                       ; ------------------------------------- Total: 42 cycles
   \   000045                       REQUIRE ?CLRL78_V1_0_L00
   2241          }

   \                                 In  segment CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000 BB                    MOVW      [HL], AX           ;; 1 cycle
   \   000001 BC02                  MOVW      [HL+0x02], AX      ;; 1 cycle
   \   000003 36....                MOVW      HL, #CPU_IntDisMeasMax_cnts  ;; 1 cycle
   \   000006 BB                    MOVW      [HL], AX           ;; 1 cycle
   \   000007 BC02                  MOVW      [HL+0x02], AX      ;; 1 cycle
   \   000009 D7                    RET                          ;; 6 cycles
   \   00000A                       ; ------------------------------------- Block: 11 cycles
   \   00000A                       ; ------------------------------------- Total: 11 cycles
   \   00000A                       REQUIRE ?CLRL78_V1_0_L00
   2242          #endif
   2243          
   2244          
   2245          /*$PAGE*/
   2246          /*
   2247          *********************************************************************************************************
   2248          *                                       CPU_IntDisMeasMaxCalc()
   2249          *
   2250          * Description : Calculate maximum interrupts disabled time.
   2251          *
   2252          * Argument(s) : time_tot_cnts   Total interrupt disabled time, in timer counts.
   2253          *
   2254          * Return(s)   : Maximum interrupts disabled time (in CPU timestamp timer counts).
   2255          *
   2256          * Caller(s)   : CPU_IntDisMeasMaxCurGet(),
   2257          *               CPU_IntDisMeasMaxGet().
   2258          *
   2259          * Note(s)     : (1) (a) The total amount of time interrupts are disabled by system &/or application code
   2260          *                       during critical sections is calculated by the following equations :
   2261          *
   2262          *                       (1) time            =   [ time      -  time      ]  -  time
   2263          *                               interrupts      [     stop         start ]         total meas
   2264          *                                disabled       [     meas         meas  ]           ovrhd
   2265          *                           (via application)
   2266          *
   2267          *
   2268          *                       (2) time            =  time            +  time
   2269          *                               total meas         start meas         stop meas
   2270          *                                 ovrhd              ovrhd              ovrhd
   2271          *
   2272          *
   2273          *                               where
   2274          *
   2275          *                                       time                    time interrupts are disabled between
   2276          *                                           interrupts              first critical section enter &
   2277          *                                            disabled               last  critical section exit minus
   2278          *                                       (via application)           time measurement overhead
   2279          *
   2280          *                                       time                    time of disable interrupts start time
   2281          *                                           start                   measurement (in timer counts)
   2282          *                                           meas
   2283          *
   2284          *                                       time                    time of disable interrupts stop  time
   2285          *                                           stop                    measurement (in timer counts)
   2286          *                                           meas
   2287          *
   2288          *                                       time                    total overhead time to start/stop disabled
   2289          *                                           total meas              interrupts time measurements (in timer
   2290          *                                             ovrhd                 counts)
   2291          *
   2292          *                                       time                    total overhead time after getting start
   2293          *                                           start meas              time until end of start measurement
   2294          *                                             ovrhd                 function  (in timer counts)
   2295          *
   2296          *                                       time                    total overhead time from beginning of stop
   2297          *                                           stop meas               measurement function until after getting
   2298          *                                             ovrhd                 stop time (in timer counts)
   2299          *
   2300          *
   2301          *                   (b) To expedite & reduce interrupts disabled time measurement overhead, the final
   2302          *                       calculations to subtract the interrupts disabled time measurement overhead is
   2303          *                       performed asynchronously in API functions.
   2304          *
   2305          *                       See also 'CPU_IntDisMeasStop()  Note #1b2'.
   2306          *$PAGE*
   2307          *                   (c) The amount of time interrupts are disabled is calculated by either of the
   2308          *                       following equations :
   2309          *
   2310          *                       (1) Interrupts disabled time  =  Number timer counts  *  Timer period
   2311          *
   2312          *                               where
   2313          *
   2314          *                                   Number timer counts             Number of timer counts measured
   2315          *                                   Timer period                    Timer's period in some units of
   2316          *                                                                       (fractional) seconds
   2317          *                                   Interrupts disabled time        Amount of time interrupts are
   2318          *                                                                       disabled, in same units of
   2319          *                                                                       (fractional) seconds as the
   2320          *                                                                       Timer period
   2321          *
   2322          *                                                         Number timer counts
   2323          *                       (2) Interrupts disabled time  =  ---------------------
   2324          *                                                           Timer frequency
   2325          *
   2326          *                               where
   2327          *
   2328          *                                   Number timer counts             Number of timer counts measured
   2329          *                                   Timer frequency                 Timer's frequency in some units
   2330          *                                                                       of counts per second
   2331          *                                   Interrupts disabled time        Amount of time interrupts are
   2332          *                                                                       disabled, in seconds
   2333          *
   2334          *                       See also 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TS_TmrRd()      Note #2c'
   2335          *                              & 'cpu_core.h  FUNCTION PROTOTYPES  CPU_TSxx_to_uSec()  Note #2'.
   2336          *
   2337          *               (2) Although it is not typical, it is possible for an interrupts disabled time
   2338          *                   measurement to be less than the interrupts disabled time measurement overhead;
   2339          *                   especially if the overhead was calculated with a single, non-cached measurement
   2340          *                   & critical sections are called within instruction-cached loops.
   2341          *********************************************************************************************************
   2342          */
   2343          
   2344          #ifdef  CPU_CFG_INT_DIS_MEAS_EN

   \                                 In  segment CODE, align 1, keep-with-next
   2345          static  CPU_TS_TMR  CPU_IntDisMeasMaxCalc (CPU_TS_TMR  time_tot_cnts)
   \                     CPU_IntDisMeasMaxCalc:
   2346          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000 C5                    PUSH      DE                 ;; 1 cycle
   \   000001                       ; Auto size: 0
   \   000001 14                    MOVW      DE, AX             ;; 1 cycle
   \   000002 C3                    PUSH      BC                 ;; 1 cycle
   \   000003 C6                    POP       HL                 ;; 1 cycle
   2347              CPU_TS_TMR  time_max_cnts;
   2348          
   2349          
   2350              time_max_cnts = time_tot_cnts;
   2351              if (time_max_cnts >  CPU_IntDisMeasOvrhd_cnts) {            /* If       max ints dis'd time >  ovrhd time, ...      */
   \   000004 C7                    PUSH      HL                 ;; 1 cycle
   \   000005 C5                    PUSH      DE                 ;; 1 cycle
   \   000006 DB....                MOVW      BC, N:CPU_IntDisMeasOvrhd_cnts+2  ;; 1 cycle
   \   000009 AF....                MOVW      AX, N:CPU_IntDisMeasOvrhd_cnts  ;; 1 cycle
   \   00000C FD....                CALL      N:?UL_CMP_L03      ;; 3 cycles
   \   00000F DE10                  BNC       ??CPU_IntDisMeasMaxCalc_22  ;; 4 cycles
   \   000011                       ; ------------------------------------- Block: 15 cycles
   2352                  time_max_cnts -= CPU_IntDisMeasOvrhd_cnts;              /* ... adj  max ints dis'd time by ovrhd time; ...      */
   \   000011 15                    MOVW      AX, DE             ;; 1 cycle
   \   000012 C7                    PUSH      HL                 ;; 1 cycle
   \   000013 C2                    POP       BC                 ;; 1 cycle
   \   000014 22....                SUBW      AX, N:CPU_IntDisMeasOvrhd_cnts  ;; 1 cycle
   \   000017 61D8                  SKNC
   \   000019 B3                    DECW      BC                 ;; 5 cycles
   \   00001A 33                    XCHW      AX, BC             ;; 1 cycle
   \   00001B 22....                SUBW      AX, N:CPU_IntDisMeasOvrhd_cnts+2  ;; 1 cycle
   \   00001E 33                    XCHW      AX, BC             ;; 1 cycle
   \   00001F EF02                  BR        S:??CPU_IntDisMeasMaxCalc_23  ;; 3 cycles
   \   000021                       ; ------------------------------------- Block: 15 cycles
   2353              } else {                                                    /* ... else max ints dis'd time <  ovrhd time, ...      */
   2354                  time_max_cnts  = 0u;                                    /* ... clr  max ints dis'd time (see Note #2).          */
   \                     ??CPU_IntDisMeasMaxCalc_22:
   \   000021 F6                    CLRW      AX                 ;; 1 cycle
   \   000022 F7                    CLRW      BC                 ;; 1 cycle
   \   000023                       ; ------------------------------------- Block: 2 cycles
   2355              }
   2356          
   2357              return (time_max_cnts);
   \                     ??CPU_IntDisMeasMaxCalc_23:
   \   000023 C4                    POP       DE                 ;; 1 cycle
   \   000024 D7                    RET                          ;; 6 cycles
   \   000025                       ; ------------------------------------- Block: 7 cycles
   \   000025                       ; ------------------------------------- Total: 39 cycles
   \   000025                       REQUIRE ?CLRL78_V1_0_L00
   2358          }
   2359          #endif
   2360          

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      0   CPU_CntLeadZeros
        0   -> CPU_CntLeadZeros16
      2   CPU_CntLeadZeros08
      2   CPU_CntLeadZeros16
      2   CPU_CntLeadZeros32
      0   CPU_CntTrailZeros
        0   -> CPU_CntLeadZeros
      2   CPU_CntTrailZeros08
      0   CPU_CntTrailZeros16
        0   -> CPU_CntLeadZeros16
      6   CPU_CntTrailZeros32
        2   -> CPU_CntLeadZeros32
      0   CPU_Init
        0   -> CPU_IntDisMeasInit
        0   -> CPU_NameClr
        0   -> CPU_TS_TmrInit
      4   CPU_IntDisMeasInit
        4   -> CPU_IntDisMeasStart
        4   -> CPU_IntDisMeasStop
      6   CPU_IntDisMeasMaxCalc
      2   CPU_IntDisMeasMaxCurGet
        2   -> CPU_IntDisMeasMaxCalc
      4   CPU_IntDisMeasMaxCurReset
        4   -> CPU_IntDisMeasMaxCurGet
      2   CPU_IntDisMeasMaxGet
        2   -> CPU_IntDisMeasMaxCalc
      2   CPU_IntDisMeasStart
        2   -> CPU_TS_TmrRd
      8   CPU_IntDisMeasStop
        4   -> CPU_TS_TmrRd
      4   CPU_NameClr
        4   -> CPU_IntDisMeasStart
        4   -> CPU_IntDisMeasStop
        4   -> Mem_Clr
      8   CPU_NameGet
        8   -> CPU_IntDisMeasStart
        8   -> CPU_IntDisMeasStop
        8   -> Str_Copy_N
      8   CPU_NameSet
        8   -> CPU_IntDisMeasStart
        8   -> CPU_IntDisMeasStop
        8   -> Str_Copy_N
        8   -> Str_Len_N
      0   CPU_SW_Exception
      0   CPU_TS_Get32
        0   -> CPU_TS_TmrRd
      2   CPU_TS_TmrFreqGet
      0   CPU_TS_TmrFreqSet
      0   CPU_TS_Update


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      11  ?Subroutine0
       6  ?Subroutine1
       6  ?Subroutine2
       5  ?Subroutine3
       6  ?Subroutine4
      10  ?Subroutine5
       7  ?Subroutine6
      16  ?Subroutine7
       7  ?Subroutine8
       3  CPU_CntLeadZeros
       9  CPU_CntLeadZeros08
      21  CPU_CntLeadZeros16
      74  CPU_CntLeadZeros32
     256  CPU_CntLeadZerosTbl
      15  CPU_CntTrailZeros
      29  CPU_CntTrailZeros08
      18  CPU_CntTrailZeros16
      47  CPU_CntTrailZeros32
      16  CPU_Init
       2  CPU_IntDisMeasCtr
      69  CPU_IntDisMeasInit
      37  CPU_IntDisMeasMaxCalc
      10  CPU_IntDisMeasMaxCurGet
      34  CPU_IntDisMeasMaxCurReset
       4  CPU_IntDisMeasMaxCur_cnts
      13  CPU_IntDisMeasMaxGet
       4  CPU_IntDisMeasMax_cnts
       4  CPU_IntDisMeasOvrhd_cnts
      25  CPU_IntDisMeasStart
       4  CPU_IntDisMeasStart_cnts
      83  CPU_IntDisMeasStop
       4  CPU_IntDisMeasStop_cnts
       2  CPU_IntDisNestCtr
      16  CPU_Name
      21  CPU_NameClr
      59  CPU_NameGet
      82  CPU_NameSet
       2  CPU_SW_Exception
       3  CPU_TS_Get32
      40  CPU_TS_TmrFreqGet
       8  CPU_TS_TmrFreqSet
       4  CPU_TS_TmrFreq_Hz
       1  CPU_TS_Update

 
 793 bytes in segment CODE
 256 bytes in segment NEAR_CONST
  44 bytes in segment NEAR_Z
 
 793 bytes of CODE  memory
 256 bytes of CONST memory
  44 bytes of DATA  memory

Errors: none
Warnings: none

###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.30.5.50715 for RL78             23/Mar/2014  17:08:40 #
# Copyright 2011-2013 IAR Systems AB.                                         #
# Network license: ece-lic-19.ece.ncsu.edu (STD)                              #
#                                                                             #
#    Core         =  rl78_2                                                   #
#    Code model   =  Near                                                     #
#    Data model   =  Near                                                     #
#                 =                                                           #
#    Source file  =  C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\uCOS-III\Source\os_core.c  #
#    Command line =  C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\uCOS-III\Source\os_core.c  #
#                    --core rl78_2 --code_model near --data_model near        #
#                    --near_const_location rom0 -o                            #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\Debug\Obj\ --dlib_config            #
#                    "C:\Program Files\IAR Systems\Embedded Workbench         #
#                    6.5\rl78\LIB\dlrl78nn2n.h" -e -Ohz --no_scheduling       #
#                    --no_clustering --debug -lC                              #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\Debug\List\ -I                      #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\ -I C:\Users\Suddenlink\Dropbox\git #
#                    _files\embedded_design\Proj2_uCOS-III-LCD-G14\Software\E #
#                    valBoards\Renesas\YRDKRL78G14\IAR\Application\Source\    #
#                    -I C:\Users\Suddenlink\Dropbox\git_files\embedded_design #
#                    \Proj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDK #
#                    RL78G14\IAR\Application\..\uCOS-III\ -I                  #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\..\BSP\ -I                          #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\..\BSP\applilet3_src\ -I            #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\..\BSP\Glyph\Drivers\ -I            #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\..\BSP\Glyph\glyph\ -I              #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\..\..\..\..\..\uC-CPU\ -I           #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\..\..\..\..\..\uC-CPU\RL78\IAR\ -I  #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\..\..\..\..\..\uC-LIB\ -I           #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\..\..\..\..\..\uCOS-III\Ports\Renes #
#                    as\RL78\IAR\ -I C:\Users\Suddenlink\Dropbox\git_files\em #
#                    bedded_design\Proj2_uCOS-III-LCD-G14\Software\EvalBoards #
#                    \Renesas\YRDKRL78G14\IAR\Application\..\..\..\..\..\uCOS #
#                    -III\Source\ --relaxed_fp                                #
#    List file    =  C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\Debug\List\os_core.lst              #
#    Object file  =  C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\Debug\Obj\os_core.r87               #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Proj2_uCOS-III-LCD-G14\Software\uCOS-III\Source\os_core.c
      1          /*
      2          ************************************************************************************************************************
      3          *                                                      uC/OS-III
      4          *                                                 The Real-Time Kernel
      5          *
      6          *                                  (c) Copyright 2009-2011; Micrium, Inc.; Weston, FL
      7          *                           All rights reserved.  Protected by international copyright laws.
      8          *
      9          *                                                    CORE FUNCTIONS
     10          *
     11          * File    : OS_CORE.C
     12          * By      : JJL
     13          * Version : V3.02.00
     14          *
     15          * LICENSING TERMS:
     16          * ---------------
     17          *           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or
     18          *           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
     19          *           product then, you need to contact Micrium to properly license uC/OS-III for its use in your
     20          *           application/product.   We provide ALL the source code for your convenience and to help you
     21          *           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use
     22          *           it commercially without paying a licensing fee.
     23          *
     24          *           Knowledge of the source code may NOT be used to develop a similar product.
     25          *
     26          *           Please help us continue to provide the embedded community with the finest software available.
     27          *           Your honesty is greatly appreciated.
     28          *
     29          *           You can contact us at www.micrium.com, or by phone at +1 (954) 217-2036.
     30          ************************************************************************************************************************
     31          */
     32          
     33          #include  <os.h>
     34          
     35          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     36          const  CPU_CHAR  *os_core__c = "$Id: $";
     37          #endif
     38          
     39          /*
     40          ************************************************************************************************************************
     41          *                                                    INITIALIZATION
     42          *
     43          * Description: This function is used to initialize the internals of uC/OS-III and MUST be called prior to
     44          *              creating any uC/OS-III object and, prior to calling OS_Start().
     45          *
     46          * Arguments  : p_err         is a pointer to a variable that will contain an error code returned by this function.
     47          *
     48          *                                OS_ERR_NONE    Initialization was successful
     49          *                                Other          Other OS_ERR_xxx depending on the sub-functions called by OSInit().
     50          * Returns    : none
     51          ************************************************************************************************************************
     52          */
     53          

   \                                 In  segment CODE, align 1, keep-with-next
     54          void  OSInit (OS_ERR  *p_err)
   \                     OSInit:
     55          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000 C3                    PUSH      BC                 ;; 1 cycle
   \   000001 C5                    PUSH      DE                 ;; 1 cycle
   \   000002                       ; Auto size: 0
   \   000002 14                    MOVW      DE, AX             ;; 1 cycle
     56              CPU_STK      *p_stk;
     57              CPU_STK_SIZE  size;
     58          
     59          
     60          
     61          #ifdef OS_SAFETY_CRITICAL
     62              if (p_err == (OS_ERR *)0) {
     63                  OS_SAFETY_CRITICAL_EXCEPTION();
     64                  return;
     65              }
     66          #endif
     67          
     68              OSInitHook();                                           /* Call port specific initialization code                 */
   \   000003 FD....                CALL      OSInitHook         ;; 3 cycles
     69          
     70              OSIntNestingCtr                 = (OS_NESTING_CTR)0;    /* Clear the interrupt nesting counter                    */
   \   000006 F5....                CLRB      N:OSIntNestingCtr  ;; 1 cycle
     71          
     72              OSRunning                       =  OS_STATE_OS_STOPPED; /* Indicate that multitasking not started                 */
   \   000009 F5....                CLRB      N:OSRunning        ;; 1 cycle
     73          
     74              OSSchedLockNestingCtr           = (OS_NESTING_CTR)0;    /* Clear the scheduling lock counter                      */
   \   00000C F5....                CLRB      N:OSSchedLockNestingCtr  ;; 1 cycle
     75          
     76          #if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
     77              OSSchedLockTimeBegin            = (CPU_TS)0;
     78              OSSchedLockTimeMax              = (CPU_TS)0;
     79              OSSchedLockTimeMaxCur           = (CPU_TS)0;
     80          #endif
     81          
     82          #ifdef OS_SAFETY_CRITICAL_IEC61508
     83              OSSafetyCriticalStartFlag       =  DEF_FALSE;
     84          #endif
     85          
     86          #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
     87              OSSchedRoundRobinEn             = DEF_FALSE;
     88              OSSchedRoundRobinDfltTimeQuanta = OSCfg_TickRate_Hz / 10u;
     89          #endif
     90          
     91              if (OSCfg_ISRStkSize > (CPU_STK_SIZE)0) {
   \   00000F F6                    CLRW      AX                 ;; 1 cycle
   \   000010 42....                CMPW      AX, N:OSCfg_ISRStkSize  ;; 1 cycle
   \   000013 DD16                  BZ        ??OS_TaskRdy_0     ;; 4 cycles
   \   000015                       ; ------------------------------------- Block: 15 cycles
     92                  p_stk = OSCfg_ISRStkBasePtr;                        /* Clear exception stack for stack checking.              */
   \   000015 AF....                MOVW      AX, N:OSCfg_ISRStkBasePtr  ;; 1 cycle
     93                  if (p_stk != (CPU_STK *)0) {
   \   000018 440000                CMPW      AX, #0x0           ;; 1 cycle
   \   00001B 16                    MOVW      HL, AX             ;; 1 cycle
   \   00001C DD0D                  BZ        ??OS_TaskRdy_0     ;; 4 cycles
   \   00001E                       ; ------------------------------------- Block: 7 cycles
     94                      size  = OSCfg_ISRStkSize;
   \   00001E AF....                MOVW      AX, N:OSCfg_ISRStkSize  ;; 1 cycle
   \   000021                       ; ------------------------------------- Block: 1 cycles
     95                      while (size > (CPU_STK_SIZE)0) {
     96                          size--;
   \                     ??OSInit_0:
   \   000021 B1                    DECW      AX                 ;; 1 cycle
     97                          *p_stk = (CPU_STK)0;
   \   000022 F7                    CLRW      BC                 ;; 1 cycle
   \   000023 33                    XCHW      AX, BC             ;; 1 cycle
   \   000024 BB                    MOVW      [HL], AX           ;; 1 cycle
   \   000025 33                    XCHW      AX, BC             ;; 1 cycle
     98                          p_stk++;
   \   000026 A7                    INCW      HL                 ;; 1 cycle
   \   000027 A7                    INCW      HL                 ;; 1 cycle
     99                      }
   \   000028 43                    CMPW      AX, BC             ;; 1 cycle
   \   000029 DFF6                  BNZ       ??OSInit_0         ;; 4 cycles
   \   00002B                       ; ------------------------------------- Block: 12 cycles
    100                  }
    101              }
    102          
    103          #if OS_CFG_APP_HOOKS_EN > 0u
    104              OS_AppTaskCreateHookPtr = (OS_APP_HOOK_TCB )0;          /* Clear application hook pointers                        */
    105              OS_AppTaskDelHookPtr    = (OS_APP_HOOK_TCB )0;
    106              OS_AppTaskReturnHookPtr = (OS_APP_HOOK_TCB )0;
    107          
    108              OS_AppIdleTaskHookPtr   = (OS_APP_HOOK_VOID)0;
    109              OS_AppStatTaskHookPtr   = (OS_APP_HOOK_VOID)0;
    110              OS_AppTaskSwHookPtr     = (OS_APP_HOOK_VOID)0;
    111              OS_AppTimeTickHookPtr   = (OS_APP_HOOK_VOID)0;
    112          #endif
    113          
    114              OS_PrioInit();                                          /* Initialize the priority bitmap table                   */
   \                     ??OS_TaskRdy_0:
   \   00002B FD....                CALL      OS_PrioInit        ;; 3 cycles
    115          
    116              OS_RdyListInit();                                       /* Initialize the Ready List                              */
   \   00002E FD....                CALL      OS_RdyListInit     ;; 3 cycles
    117          
    118              OS_TaskInit(p_err);                                     /* Initialize the task manager                            */
   \   000031 15                    MOVW      AX, DE             ;; 1 cycle
   \   000032 FD....                CALL      OS_TaskInit        ;; 3 cycles
    119              if (*p_err != OS_ERR_NONE) {
   \   000035 A9                    MOVW      AX, [DE]           ;; 1 cycle
   \   000036 F7                    CLRW      BC                 ;; 1 cycle
   \   000037 43                    CMPW      AX, BC             ;; 1 cycle
   \   000038 DF33                  BNZ       ??OS_TaskRdy_1     ;; 4 cycles
   \   00003A                       ; ------------------------------------- Block: 17 cycles
    120                  return;
    121              }
    122          
    123          #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
    124              OS_IntQTaskInit(p_err);                                 /* Initialize the Interrupt Queue Handler Task            */
    125              if (*p_err != OS_ERR_NONE) {
    126                  return;
    127              }
    128          #endif
    129          
    130              OS_IdleTaskInit(p_err);                                 /* Initialize the Idle Task                               */
   \   00003A 15                    MOVW      AX, DE             ;; 1 cycle
   \   00003B FD....                CALL      OS_IdleTaskInit    ;; 3 cycles
    131              if (*p_err != OS_ERR_NONE) {
   \   00003E A9                    MOVW      AX, [DE]           ;; 1 cycle
   \   00003F 43                    CMPW      AX, BC             ;; 1 cycle
   \   000040 DF2B                  BNZ       ??OS_TaskRdy_1     ;; 4 cycles
   \   000042                       ; ------------------------------------- Block: 10 cycles
    132                  return;
    133              }
    134          
    135              OS_TickTaskInit(p_err);                                 /* Initialize the Tick Task                               */
   \   000042 15                    MOVW      AX, DE             ;; 1 cycle
   \   000043 FD....                CALL      OS_TickTaskInit    ;; 3 cycles
    136              if (*p_err != OS_ERR_NONE) {
   \   000046 A9                    MOVW      AX, [DE]           ;; 1 cycle
   \   000047 43                    CMPW      AX, BC             ;; 1 cycle
   \   000048 DF23                  BNZ       ??OS_TaskRdy_1     ;; 4 cycles
   \   00004A                       ; ------------------------------------- Block: 10 cycles
    137                  return;
    138              }
    139          
    140          
    141          #if OS_CFG_STAT_TASK_EN > 0u                                /* Initialize the Statistic Task                          */
    142              OS_StatTaskInit(p_err);
    143              if (*p_err != OS_ERR_NONE) {
    144                  return;
    145              }
    146          #endif
    147          
    148          
    149          #if OS_CFG_FLAG_EN > 0u                                     /* Initialize the Event Flag module                       */
    150              OS_FlagInit(p_err);
    151              if (*p_err != OS_ERR_NONE) {
    152                  return;
    153              }
    154          #endif
    155          
    156          
    157          #if OS_CFG_MEM_EN > 0u                                      /* Initialize the Memory Manager module                   */
    158              OS_MemInit(p_err);
    159              if (*p_err != OS_ERR_NONE) {
    160                  return;
    161              }
    162          #endif
    163          
    164          
    165          #if (OS_MSG_EN) > 0u                                        /* Initialize the free list of OS_MSGs                    */
    166              OS_MsgPoolInit(p_err);
   \   00004A 15                    MOVW      AX, DE             ;; 1 cycle
   \   00004B FD....                CALL      OS_MsgPoolInit     ;; 3 cycles
    167              if (*p_err != OS_ERR_NONE) {
   \   00004E A9                    MOVW      AX, [DE]           ;; 1 cycle
   \   00004F 43                    CMPW      AX, BC             ;; 1 cycle
   \   000050 DF1B                  BNZ       ??OS_TaskRdy_1     ;; 4 cycles
   \   000052                       ; ------------------------------------- Block: 10 cycles
    168                  return;
    169              }
    170          #endif
    171          
    172          
    173          #if OS_CFG_MUTEX_EN > 0u                                    /* Initialize the Mutex Manager module                    */
    174              OS_MutexInit(p_err);
   \   000052 15                    MOVW      AX, DE             ;; 1 cycle
   \   000053 FD....                CALL      OS_MutexInit       ;; 3 cycles
    175              if (*p_err != OS_ERR_NONE) {
   \   000056 A9                    MOVW      AX, [DE]           ;; 1 cycle
   \   000057 43                    CMPW      AX, BC             ;; 1 cycle
   \   000058 DF13                  BNZ       ??OS_TaskRdy_1     ;; 4 cycles
   \   00005A                       ; ------------------------------------- Block: 10 cycles
    176                  return;
    177              }
    178          #endif
    179          
    180          
    181          #if OS_CFG_Q_EN > 0u
    182              OS_QInit(p_err);                                        /* Initialize the Message Queue Manager module            */
   \   00005A 15                    MOVW      AX, DE             ;; 1 cycle
   \   00005B FD....                CALL      OS_QInit           ;; 3 cycles
    183              if (*p_err != OS_ERR_NONE) {
   \   00005E A9                    MOVW      AX, [DE]           ;; 1 cycle
   \   00005F 43                    CMPW      AX, BC             ;; 1 cycle
   \   000060 DF0B                  BNZ       ??OS_TaskRdy_1     ;; 4 cycles
   \   000062                       ; ------------------------------------- Block: 10 cycles
    184                  return;
    185              }
    186          #endif
    187          
    188          
    189          #if OS_CFG_SEM_EN > 0u                                      /* Initialize the Semaphore Manager module                */
    190              OS_SemInit(p_err);
   \   000062 15                    MOVW      AX, DE             ;; 1 cycle
   \   000063 FD....                CALL      OS_SemInit         ;; 3 cycles
    191              if (*p_err != OS_ERR_NONE) {
   \   000066 A9                    MOVW      AX, [DE]           ;; 1 cycle
   \   000067 43                    CMPW      AX, BC             ;; 1 cycle
   \   000068 61F8                  SKNZ                         ;; 4 cycles
   \   00006A                       ; ------------------------------------- Block: 10 cycles
    192                  return;
    193              }
    194          #endif
    195          
    196          
    197          #if OS_CFG_TMR_EN > 0u                                      /* Initialize the Timer Manager module                    */
    198              OS_TmrInit(p_err);
    199              if (*p_err != OS_ERR_NONE) {
    200                  return;
    201              }
    202          #endif
    203          
    204          
    205          #if OS_CFG_DBG_EN > 0u
    206              OS_Dbg_Init();
    207          #endif
    208          
    209              OSCfg_Init();
   \   00006A FD....                CALL      OSCfg_Init         ;; 3 cycles
    210          }
   \   00006D                       ; ------------------------------------- Block: 3 cycles
   \                     ??OS_TaskRdy_1:
   \   00006D C4                    POP       DE                 ;; 1 cycle
   \   00006E C2                    POP       BC                 ;; 1 cycle
   \   00006F D7                    RET                          ;; 6 cycles
   \   000070                       ; ------------------------------------- Block: 8 cycles
   \   000070                       ; ------------------------------------- Total: 123 cycles
   \   000070                       REQUIRE ?CLRL78_V1_0_L00
    211          
    212          /*$PAGE*/
    213          /*
    214          ************************************************************************************************************************
    215          *                                                      ENTER ISR
    216          *
    217          * Description: This function is used to notify uC/OS-III that you are about to service an interrupt service routine
    218          *              (ISR).  This allows uC/OS-III to keep track of interrupt nesting and thus only perform rescheduling at
    219          *              the last nested ISR.
    220          *
    221          * Arguments  : none
    222          *
    223          * Returns    : none
    224          *
    225          * Note(s)    : 1) This function MUST be called with interrupts already disabled
    226          *
    227          *              2) Your ISR can directly increment 'OSIntNestingCtr' without calling this function because OSIntNestingCtr has
    228          *                 been declared 'global', the port is actually considered part of the OS and thus is allowed to access
    229          *                 uC/OS-III variables.
    230          *
    231          *              3) You MUST still call OSIntExit() even though you increment 'OSIntNestingCtr' directly.
    232          *
    233          *              4) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call to OSIntEnter()
    234          *                 (or direct increment to OSIntNestingCtr) at the beginning of the ISR you MUST have a call to OSIntExit()
    235          *                 at the end of the ISR.
    236          *
    237          *              5) You are allowed to nest interrupts up to 250 levels deep.
    238          ************************************************************************************************************************
    239          */
    240          

   \                                 In  segment CODE, align 1, keep-with-next
    241          void  OSIntEnter (void)
   \                     OSIntEnter:
    242          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000                       ; Auto size: 0
    243              if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Is OS running?                                         */
   \   000000 40......              CMP       N:OSRunning, #0x1  ;; 1 cycle
   \   000004 61E8                  SKZ                          ;; 4 cycles
   \   000006                       ; ------------------------------------- Block: 5 cycles
    244                  return;                                             /* No                                                     */
   \   000006 D7                    RET                          ;; 6 cycles
   \   000007                       ; ------------------------------------- Block: 6 cycles
    245              }
    246          
    247              if (OSIntNestingCtr >= (OS_NESTING_CTR)250u) {          /* Have we nested past 250 levels?                        */
   \                     ??OSIntEnter_0:
   \   000007 8F....                MOV       A, N:OSIntNestingCtr  ;; 1 cycle
   \   00000A 4CFA                  CMP       A, #0xFA           ;; 1 cycle
   \   00000C 61C8                  SKC                          ;; 4 cycles
   \   00000E                       ; ------------------------------------- Block: 6 cycles
    248                  return;                                             /* Yes                                                    */
   \   00000E D7                    RET                          ;; 6 cycles
   \   00000F                       ; ------------------------------------- Block: 6 cycles
    249              }
    250          
    251              OSIntNestingCtr++;                                      /* Increment ISR nesting level                            */
   \                     ??OSIntEnter_1:
   \   00000F A0....                INC       N:OSIntNestingCtr  ;; 2 cycles
    252          }
   \   000012 D7                    RET                          ;; 6 cycles
   \   000013                       ; ------------------------------------- Block: 8 cycles
   \   000013                       ; ------------------------------------- Total: 31 cycles
   \   000013                       REQUIRE ?CLRL78_V1_0_L00
    253          
    254          /*$PAGE*/
    255          /*
    256          ************************************************************************************************************************
    257          *                                                       EXIT ISR
    258          *
    259          * Description: This function is used to notify uC/OS-III that you have completed servicing an ISR.  When the last nested
    260          *              ISR has completed, uC/OS-III will call the scheduler to determine whether a new, high-priority task, is
    261          *              ready to run.
    262          *
    263          * Arguments  : none
    264          *
    265          * Returns    : none
    266          *
    267          * Note(s)    : 1) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call to OSIntEnter()
    268          *                 (or direct increment to OSIntNestingCtr) at the beginning of the ISR you MUST have a call to OSIntExit()
    269          *                 at the end of the ISR.
    270          *
    271          *              2) Rescheduling is prevented when the scheduler is locked (see OSSchedLock())
    272          ************************************************************************************************************************
    273          */
    274          

   \                                 In  segment CODE, align 1, keep-with-next
    275          void  OSIntExit (void)
   \                     OSIntExit:
    276          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000 C3                    PUSH      BC                 ;; 1 cycle
   \   000001                       ; Auto size: 4
   \   000001 2004                  SUBW      SP, #0x4           ;; 1 cycle
    277              CPU_SR_ALLOC();
    278          
    279          
    280          
    281              if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Has the OS started?                                    */
   \   000003 40......              CMP       N:OSRunning, #0x1  ;; 1 cycle
   \   000007 DD04                  BZ        ??OS_TaskRdy_2     ;; 4 cycles
   \   000009                       ; ------------------------------------- Block: 7 cycles
    282                  return;                                             /* No                                                     */
   \                     ??OSIntExit_0:
   \   000009 1004                  ADDW      SP, #0x4           ;; 1 cycle
   \   00000B C2                    POP       BC                 ;; 1 cycle
   \   00000C D7                    RET                          ;; 6 cycles
   \   00000D                       ; ------------------------------------- Block: 8 cycles
    283              }
    284          
    285              CPU_INT_DIS();
   \                     ??OS_TaskRdy_2:
   \   00000D 8EFA                  MOV       A, PSW             ;; 1 cycle
   \   00000F 70                    MOV       X, A               ;; 1 cycle
   \   000010 F1                    CLRB      A                  ;; 1 cycle
   \   000011 F7                    CLRW      BC                 ;; 1 cycle
   \   000012 B800                  MOVW      [SP], AX           ;; 1 cycle
   \   000014 F6                    CLRW      AX                 ;; 1 cycle
   \   000015 B802                  MOVW      [SP+0x02], AX      ;; 1 cycle
   \   000017 717BFA                DI                           ;; 2 cycles
    286              if (OSIntNestingCtr == (OS_NESTING_CTR)0) {             /* Prevent OSIntNestingCtr from wrapping                  */
   \   00001A D5....                CMP0      N:OSIntNestingCtr  ;; 1 cycle
   \   00001D DD1F                  BZ        ??OS_TaskRdy_3     ;; 4 cycles
   \   00001F                       ; ------------------------------------- Block: 14 cycles
    287                  CPU_INT_EN();
    288                  return;
    289              }
    290              OSIntNestingCtr--;
   \   00001F B0....                DEC       N:OSIntNestingCtr  ;; 2 cycles
    291              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* ISRs still nested?                                     */
   \   000022 D5....                CMP0      N:OSIntNestingCtr  ;; 1 cycle
   \   000025 DF17                  BNZ       ??OS_TaskRdy_3     ;; 4 cycles
   \   000027                       ; ------------------------------------- Block: 7 cycles
    292                  CPU_INT_EN();                                       /* Yes                                                    */
    293                  return;
    294              }
    295          
    296              if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {        /* Scheduler still locked?                                */
   \   000027 D5....                CMP0      N:OSSchedLockNestingCtr  ;; 1 cycle
   \   00002A DF12                  BNZ       ??OS_TaskRdy_3     ;; 4 cycles
   \   00002C                       ; ------------------------------------- Block: 5 cycles
    297                  CPU_INT_EN();                                       /* Yes                                                    */
    298                  return;
    299              }
    300          
    301              OSPrioHighRdy   = OS_PrioGetHighest();                  /* Find highest priority                                  */
   \   00002C FD....                CALL      OS_PrioGetHighest  ;; 3 cycles
   \   00002F 9F....                MOV       N:OSPrioHighRdy, A  ;; 1 cycle
    302              OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;     /* Get highest priority task ready-to-run                 */
   \   000032 70                    MOV       X, A               ;; 1 cycle
   \   000033 F1                    CLRB      A                  ;; 1 cycle
   \   000034 5206                  MOV       C, #0x6            ;; 1 cycle
   \   000036 CEFB01                MULHU                        ;; 2 cycles
   \   000039 FD....                CALL      N:?Subroutine7     ;; 3 cycles
   \   00003C                       ; ------------------------------------- Block: 12 cycles
    303              if (OSTCBHighRdyPtr == OSTCBCurPtr) {                   /* Current task still the highest priority?               */
   \                     ??CrossCallReturnLabel_7:
   \   00003C DF07                  BNZ       ??OS_TaskRdy_4     ;; 4 cycles
   \   00003E                       ; ------------------------------------- Block: 4 cycles
    304                  CPU_INT_EN();                                       /* Yes                                                    */
   \                     ??OS_TaskRdy_3:
   \   00003E 8800                  MOV       A, [SP]            ;; 1 cycle
   \   000040 FD....                CALL      N:??Subroutine15_0  ;; 3 cycles
   \   000043                       ; ------------------------------------- Block: 4 cycles
    305                  return;
   \                     ??CrossCallReturnLabel_24:
   \   000043 EFC4                  BR        S:??OSIntExit_0    ;; 3 cycles
   \   000045                       ; ------------------------------------- Block: 3 cycles
    306              }
    307          
    308          #if OS_CFG_TASK_PROFILE_EN > 0u
    309              OSTCBHighRdyPtr->CtxSwCtr++;                            /* Inc. # of context switches for this new task           */
    310          #endif
    311              OSTaskCtxSwCtr++;                                       /* Keep track of the total number of ctx switches         */
   \                     ??OS_TaskRdy_4:
   \   000045 FD....                CALL      N:?Subroutine11    ;; 3 cycles
   \   000048                       ; ------------------------------------- Block: 3 cycles
   \                     ??CrossCallReturnLabel_14:
   \   000048 61D8                  SKNC
   \   00004A A3                    INCW      BC                 ;; 5 cycles
   \   00004B BF....                MOVW      N:OSTaskCtxSwCtr, AX  ;; 1 cycle
   \   00004E 13                    MOVW      AX, BC             ;; 1 cycle
   \   00004F BF....                MOVW      N:OSTaskCtxSwCtr+2, AX  ;; 1 cycle
    312          
    313              OSIntCtxSw();                                           /* Perform interrupt level ctx switch                     */
   \   000052 FD....                CALL      OSIntCtxSw         ;; 3 cycles
   \   000055 EFE7                  BR        S:??OS_TaskRdy_3   ;; 3 cycles
   \   000057                       ; ------------------------------------- Block: 14 cycles
   \   000057                       ; ------------------------------------- Total: 81 cycles
   \   000057                       REQUIRE ?CLRL78_V1_0_L00
    314              CPU_INT_EN();
    315          }

   \                                 In  segment CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000 DB....                MOVW      BC, N:OSTaskCtxSwCtr+2  ;; 1 cycle
   \   000003 AF....                MOVW      AX, N:OSTaskCtxSwCtr  ;; 1 cycle
   \   000006 040100                ADDW      AX, #0x1           ;; 1 cycle
   \   000009 D7                    RET                          ;; 6 cycles
   \   00000A                       ; ------------------------------------- Block: 9 cycles
   \   00000A                       ; ------------------------------------- Total: 9 cycles
   \   00000A                       REQUIRE ?CLRL78_V1_0_L00

   \                                 In  segment CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000 FD....                CALL      N:?Subroutine13    ;; 3 cycles
   \   000003                       ; ------------------------------------- Block: 3 cycles
   \                     ??CrossCallReturnLabel_23:
   \   000003 FB....                MOVW      HL, N:OSTCBCurPtr  ;; 1 cycle
   \   000006 47                    CMPW      AX, HL             ;; 1 cycle
   \   000007 D7                    RET                          ;; 6 cycles
   \   000008                       ; ------------------------------------- Block: 8 cycles
   \   000008                       ; ------------------------------------- Total: 11 cycles
   \   000008                       REQUIRE ?CLRL78_V1_0_L00

   \                                 In  segment CODE, align 1, keep-with-next
   \                     ??Subroutine15_0:
   \   000000 71FC                  MOV1      CY, A.7            ;; 1 cycle
   \   000002 7179FA                MOV1      PSW.7, CY          ;; 4 cycles
   \   000005 D7                    RET                          ;; 6 cycles
   \   000006                       ; ------------------------------------- Block: 11 cycles
   \   000006                       ; ------------------------------------- Total: 11 cycles
   \   000006                       REQUIRE ?CLRL78_V1_0_L00

   \                                 In  segment CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000 04....                ADDW      AX, #OSRdyList     ;; 1 cycle
   \   000003 16                    MOVW      HL, AX             ;; 1 cycle
   \   000004 AB                    MOVW      AX, [HL]           ;; 1 cycle
   \   000005 BF....                MOVW      N:OSTCBHighRdyPtr, AX  ;; 1 cycle
   \   000008 D7                    RET                          ;; 6 cycles
   \   000009                       ; ------------------------------------- Block: 10 cycles
   \   000009                       ; ------------------------------------- Total: 10 cycles
   \   000009                       REQUIRE ?CLRL78_V1_0_L00
    316          
    317          /*$PAGE*/
    318          /*
    319          ************************************************************************************************************************
    320          *                                    INDICATE THAT IT'S NO LONGER SAFE TO CREATE OBJECTS
    321          *
    322          * Description: This function is called by the application code to indicate that all initialization has been completed
    323          *              and that kernel objects are no longer allowed to be created.
    324          *
    325          * Arguments  : none
    326          *
    327          * Returns    : none
    328          *
    329          * Note(s)    : none
    330          ************************************************************************************************************************
    331          */
    332          
    333          #ifdef OS_SAFETY_CRITICAL_IEC61508
    334          void  OSSafetyCriticalStart (void)
    335          {
    336              OSSafetyCriticalStartFlag = DEF_TRUE;
    337          }
    338          
    339          #endif
    340          
    341          /*$PAGE*/
    342          /*
    343          ************************************************************************************************************************
    344          *                                                      SCHEDULER
    345          *
    346          * Description: This function is called by other uC/OS-III services to determine whether a new, high priority task has
    347          *              been made ready to run.  This function is invoked by TASK level code and is not used to reschedule tasks
    348          *              from ISRs (see OSIntExit() for ISR rescheduling).
    349          *
    350          * Arguments  : none
    351          *
    352          * Returns    : none
    353          *
    354          * Note(s)    : 1) Rescheduling is prevented when the scheduler is locked (see OSSchedLock())
    355          ************************************************************************************************************************
    356          */
    357          

   \                                 In  segment CODE, align 1, keep-with-next
    358          void  OSSched (void)
   \                     OSSched:
    359          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000 C3                    PUSH      BC                 ;; 1 cycle
   \   000001                       ; Auto size: 4
   \   000001 2004                  SUBW      SP, #0x4           ;; 1 cycle
    360              CPU_SR_ALLOC();
    361          
    362          
    363          
    364              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* ISRs still nested?                                     */
   \   000003 D5....                CMP0      N:OSIntNestingCtr  ;; 1 cycle
   \   000006 DF3D                  BNZ       ??CrossCallReturnLabel_25  ;; 4 cycles
   \   000008                       ; ------------------------------------- Block: 7 cycles
    365                  return;                                             /* Yes ... only schedule when no nested ISRs              */
    366              }
    367          
    368              if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {        /* Scheduler locked?                                      */
   \   000008 D5....                CMP0      N:OSSchedLockNestingCtr  ;; 1 cycle
   \   00000B DF38                  BNZ       ??CrossCallReturnLabel_25  ;; 4 cycles
   \   00000D                       ; ------------------------------------- Block: 5 cycles
    369                  return;                                             /* Yes                                                    */
    370              }
    371          
    372              CPU_INT_DIS();
   \   00000D 8EFA                  MOV       A, PSW             ;; 1 cycle
   \   00000F 70                    MOV       X, A               ;; 1 cycle
   \   000010 F1                    CLRB      A                  ;; 1 cycle
   \   000011 F7                    CLRW      BC                 ;; 1 cycle
   \   000012 B800                  MOVW      [SP], AX           ;; 1 cycle
   \   000014 F6                    CLRW      AX                 ;; 1 cycle
   \   000015 B802                  MOVW      [SP+0x02], AX      ;; 1 cycle
   \   000017 717BFA                DI                           ;; 2 cycles
    373              OSPrioHighRdy   = OS_PrioGetHighest();                  /* Find the highest priority ready                        */
   \   00001A FD....                CALL      OS_PrioGetHighest  ;; 3 cycles
   \   00001D 9F....                MOV       N:OSPrioHighRdy, A  ;; 1 cycle
    374              OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;
   \   000020 70                    MOV       X, A               ;; 1 cycle
   \   000021 F1                    CLRB      A                  ;; 1 cycle
   \   000022 5206                  MOV       C, #0x6            ;; 1 cycle
   \   000024 CEFB01                MULHU                        ;; 2 cycles
   \   000027 FD....                CALL      N:?Subroutine7     ;; 3 cycles
   \   00002A                       ; ------------------------------------- Block: 21 cycles
    375              if (OSTCBHighRdyPtr == OSTCBCurPtr) {                   /* Current task is still highest priority task?           */
   \                     ??CrossCallReturnLabel_8:
   \   00002A DD14                  BZ        ??OS_TaskRdy_5     ;; 4 cycles
   \   00002C                       ; ------------------------------------- Block: 4 cycles
    376                  CPU_INT_EN();                                       /* Yes ... no need to context switch                      */
    377                  return;
    378              }
    379          
    380          #if OS_CFG_TASK_PROFILE_EN > 0u
    381              OSTCBHighRdyPtr->CtxSwCtr++;                            /* Inc. # of context switches to this task                */
    382          #endif
    383              OSTaskCtxSwCtr++;                                       /* Increment context switch counter                       */
   \   00002C FD....                CALL      N:?Subroutine11    ;; 3 cycles
   \   00002F                       ; ------------------------------------- Block: 3 cycles
   \                     ??CrossCallReturnLabel_15:
   \   00002F 61D8                  SKNC
   \   000031 A3                    INCW      BC                 ;; 5 cycles
   \   000032 33                    XCHW      AX, BC             ;; 1 cycle
   \   000033 040000                ADDW      AX, #0x0           ;; 1 cycle
   \   000036 33                    XCHW      AX, BC             ;; 1 cycle
   \   000037 BF....                MOVW      N:OSTaskCtxSwCtr, AX  ;; 1 cycle
   \   00003A 13                    MOVW      AX, BC             ;; 1 cycle
   \   00003B BF....                MOVW      N:OSTaskCtxSwCtr+2, AX  ;; 1 cycle
    384          
    385              OS_TASK_SW();                                           /* Perform a task level context switch                    */
   \   00003E 61CC                  BRK                          ;; 5 cycles
    386              CPU_INT_EN();
   \   000040                       ; ------------------------------------- Block: 16 cycles
   \                     ??OS_TaskRdy_5:
   \   000040 8800                  MOV       A, [SP]            ;; 1 cycle
   \   000042 FD....                CALL      N:??Subroutine15_0  ;; 3 cycles
    387          }
   \   000045                       ; ------------------------------------- Block: 4 cycles
   \                     ??CrossCallReturnLabel_25:
   \   000045 1004                  ADDW      SP, #0x4           ;; 1 cycle
   \   000047 C2                    POP       BC                 ;; 1 cycle
   \   000048 D7                    RET                          ;; 6 cycles
   \   000049                       ; ------------------------------------- Block: 8 cycles
   \   000049                       ; ------------------------------------- Total: 68 cycles
   \   000049                       REQUIRE ?CLRL78_V1_0_L00
    388          
    389          /*$PAGE*/
    390          /*
    391          ************************************************************************************************************************
    392          *                                                 PREVENT SCHEDULING
    393          *
    394          * Description: This function is used to prevent rescheduling from taking place.  This allows your application to prevent
    395          *              context switches until you are ready to permit context switching.
    396          *
    397          * Arguments  : p_err     is a pointer to a variable that will receive an error code:
    398          *
    399          *                            OS_ERR_NONE                 The scheduler is locked
    400          *                            OS_ERR_LOCK_NESTING_OVF     If you attempted to nest call to this function > 250 levels
    401          *                            OS_ERR_OS_NOT_RUNNING       If uC/OS-III is not running yet.
    402          *                            OS_ERR_SCHED_LOCK_ISR       If you called this function from an ISR.
    403          *
    404          * Returns    : none
    405          *
    406          * Note(s)    : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every
    407          *                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
    408          ************************************************************************************************************************
    409          */
    410          

   \                                 In  segment CODE, align 1, keep-with-next
    411          void  OSSchedLock (OS_ERR  *p_err)
   \                     OSSchedLock:
    412          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000 C3                    PUSH      BC                 ;; 1 cycle
   \   000001 C5                    PUSH      DE                 ;; 1 cycle
   \   000002                       ; Auto size: 0
   \   000002 14                    MOVW      DE, AX             ;; 1 cycle
    413              CPU_SR_ALLOC();
    414          
    415          
    416          
    417          #ifdef OS_SAFETY_CRITICAL
    418              if (p_err == (OS_ERR *)0) {
    419                  OS_SAFETY_CRITICAL_EXCEPTION();
    420                  return;
    421              }
    422          #endif
    423          
    424          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    425              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
    426                  *p_err = OS_ERR_SCHED_LOCK_ISR;
    427                  return;
    428              }
    429          #endif
    430          
    431              if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Make sure multitasking is running                      */
   \   000003 40......              CMP       N:OSRunning, #0x1  ;; 1 cycle
   \   000007 DD05                  BZ        ??OS_TaskRdy_6     ;; 4 cycles
   \   000009                       ; ------------------------------------- Block: 8 cycles
    432                 *p_err = OS_ERR_OS_NOT_RUNNING;
   \   000009 30895E                MOVW      AX, #0x5E89        ;; 1 cycle
   \   00000C EF1F                  BR        S:??OS_TaskRdy_7   ;; 3 cycles
   \   00000E                       ; ------------------------------------- Block: 4 cycles
    433                  return;
    434              }
    435          
    436              if (OSSchedLockNestingCtr >= (OS_NESTING_CTR)250u) {    /* Prevent OSSchedLockNestingCtr overflowing              */
   \                     ??OS_TaskRdy_6:
   \   00000E 8F....                MOV       A, N:OSSchedLockNestingCtr  ;; 1 cycle
   \   000011 4CFA                  CMP       A, #0xFA           ;; 1 cycle
   \   000013 DC05                  BC        ??OS_TaskRdy_8     ;; 4 cycles
   \   000015                       ; ------------------------------------- Block: 6 cycles
    437                 *p_err = OS_ERR_LOCK_NESTING_OVF;
   \   000015 300952                MOVW      AX, #0x5209        ;; 1 cycle
   \   000018 EF13                  BR        S:??OS_TaskRdy_7   ;; 3 cycles
   \   00001A                       ; ------------------------------------- Block: 4 cycles
    438                  return;
    439              }
    440          
    441              CPU_CRITICAL_ENTER();
   \                     ??OS_TaskRdy_8:
   \   00001A 8EFA                  MOV       A, PSW             ;; 1 cycle
   \   00001C 73                    MOV       B, A               ;; 1 cycle
   \   00001D 717BFA                DI                           ;; 2 cycles
   \   000020 FD....                CALL      CPU_IntDisMeasStart  ;; 3 cycles
    442              OSSchedLockNestingCtr++;                                /* Increment lock nesting level                           */
   \   000023 A0....                INC       N:OSSchedLockNestingCtr  ;; 2 cycles
    443          #if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
    444              OS_SchedLockTimeMeasStart();
    445          #endif
    446              CPU_CRITICAL_EXIT();
   \   000026 FD....                CALL      CPU_IntDisMeasStop  ;; 3 cycles
   \   000029 FD....                CALL      N:?Subroutine10    ;; 3 cycles
   \   00002C                       ; ------------------------------------- Block: 15 cycles
    447             *p_err = OS_ERR_NONE;
   \                     ??CrossCallReturnLabel_28:
   \   00002C F6                    CLRW      AX                 ;; 1 cycle
   \   00002D                       ; ------------------------------------- Block: 1 cycles
   \                     ??OS_TaskRdy_7:
   \   00002D B9                    MOVW      [DE], AX           ;; 1 cycle
    448          }
   \   00002E C4                    POP       DE                 ;; 1 cycle
   \   00002F C2                    POP       BC                 ;; 1 cycle
   \   000030 D7                    RET                          ;; 6 cycles
   \   000031                       ; ------------------------------------- Block: 9 cycles
   \   000031                       ; ------------------------------------- Total: 47 cycles
   \   000031                       REQUIRE ?CLRL78_V1_0_L00

   \                                 In  segment CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000 63                    MOV       A, B               ;; 1 cycle
   \   000001                       ; ------------------------------------- Block: 1 cycles
   \   000001                       ; ------------------------------------- Total: 1 cycles
   \   000001                       REQUIRE ?CLRL78_V1_0_L00
   \   000001                       REQUIRE ??Subroutine15_0
   \   000001                       ; // Fall through to label ??Subroutine15_0
    449          
    450          /*$PAGE*/
    451          /*
    452          ************************************************************************************************************************
    453          *                                                  ENABLE SCHEDULING
    454          *
    455          * Description: This function is used to re-allow rescheduling.
    456          *
    457          * Arguments  : p_err     is a pointer to a variable that will contain an error code returned by this function.
    458          *
    459          *                            OS_ERR_NONE
    460          *                            OS_ERR_OS_NOT_RUNNING       The scheduler has been enabled
    461          *                            OS_ERR_SCHED_LOCKED         The scheduler is still locked, still nested
    462          *                            OS_ERR_SCHED_NOT_LOCKED     The scheduler was not locked
    463          *                            OS_ERR_SCHED_UNLOCK_ISR     If you called this function from an ISR.
    464          *
    465          * Returns    : none
    466          *
    467          * Note(s)    : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every call to
    468          *                 OSSchedLock() you MUST have a call to OSSchedUnlock().
    469          ************************************************************************************************************************
    470          */
    471          

   \                                 In  segment CODE, align 1, keep-with-next
    472          void  OSSchedUnlock (OS_ERR  *p_err)
   \                     OSSchedUnlock:
    473          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000 C3                    PUSH      BC                 ;; 1 cycle
   \   000001 C5                    PUSH      DE                 ;; 1 cycle
   \   000002                       ; Auto size: 4
   \   000002 2004                  SUBW      SP, #0x4           ;; 1 cycle
   \   000004 14                    MOVW      DE, AX             ;; 1 cycle
    474              CPU_SR_ALLOC();
    475          
    476          
    477          
    478          #ifdef OS_SAFETY_CRITICAL
    479              if (p_err == (OS_ERR *)0) {
    480                  OS_SAFETY_CRITICAL_EXCEPTION();
    481                  return;
    482              }
    483          #endif
    484          
    485          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    486              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
    487                  *p_err = OS_ERR_SCHED_UNLOCK_ISR;
    488                  return;
    489              }
    490          #endif
    491          
    492              if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Make sure multitasking is running                      */
   \   000005 40......              CMP       N:OSRunning, #0x1  ;; 1 cycle
   \   000009 DD05                  BZ        ??OS_TaskRdy_9     ;; 4 cycles
   \   00000B                       ; ------------------------------------- Block: 9 cycles
    493                 *p_err = OS_ERR_OS_NOT_RUNNING;
   \   00000B 30895E                MOVW      AX, #0x5E89        ;; 1 cycle
   \   00000E EF37                  BR        S:??OS_TaskRdy_10  ;; 3 cycles
   \   000010                       ; ------------------------------------- Block: 4 cycles
    494                  return;
    495              }
    496          
    497              if (OSSchedLockNestingCtr == (OS_NESTING_CTR)0) {       /* See if the scheduler is locked                         */
   \                     ??OS_TaskRdy_9:
   \   000010 D5....                CMP0      N:OSSchedLockNestingCtr  ;; 1 cycle
   \   000013 DF05                  BNZ       ??OS_TaskRdy_11    ;; 4 cycles
   \   000015                       ; ------------------------------------- Block: 5 cycles
    498                 *p_err = OS_ERR_SCHED_NOT_LOCKED;
   \   000015 30646D                MOVW      AX, #0x6D64        ;; 1 cycle
   \   000018 EF2D                  BR        S:??OS_TaskRdy_10  ;; 3 cycles
   \   00001A                       ; ------------------------------------- Block: 4 cycles
    499                  return;
    500              }
    501          
    502              CPU_CRITICAL_ENTER();
   \                     ??OS_TaskRdy_11:
   \   00001A 8EFA                  MOV       A, PSW             ;; 1 cycle
   \   00001C 70                    MOV       X, A               ;; 1 cycle
   \   00001D F1                    CLRB      A                  ;; 1 cycle
   \   00001E B800                  MOVW      [SP], AX           ;; 1 cycle
   \   000020 F6                    CLRW      AX                 ;; 1 cycle
   \   000021 B802                  MOVW      [SP+0x02], AX      ;; 1 cycle
   \   000023 717BFA                DI                           ;; 2 cycles
   \   000026 FD....                CALL      CPU_IntDisMeasStart  ;; 3 cycles
    503              OSSchedLockNestingCtr--;                                /* Decrement lock nesting level                           */
   \   000029 B0....                DEC       N:OSSchedLockNestingCtr  ;; 2 cycles
    504              if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {
   \   00002C DD0D                  BZ        ??OS_TaskRdy_12    ;; 4 cycles
   \   00002E                       ; ------------------------------------- Block: 17 cycles
    505                  CPU_CRITICAL_EXIT();                                /* Scheduler is still locked                              */
   \   00002E FD....                CALL      CPU_IntDisMeasStop  ;; 3 cycles
   \   000031 8800                  MOV       A, [SP]            ;; 1 cycle
   \   000033 FD....                CALL      N:??Subroutine15_0  ;; 3 cycles
   \   000036                       ; ------------------------------------- Block: 7 cycles
    506                 *p_err = OS_ERR_SCHED_LOCKED;
   \                     ??CrossCallReturnLabel_26:
   \   000036 30636D                MOVW      AX, #0x6D63        ;; 1 cycle
   \   000039 EF0C                  BR        S:??OS_TaskRdy_10  ;; 3 cycles
   \   00003B                       ; ------------------------------------- Block: 4 cycles
    507                  return;
    508              }
    509          
    510          #if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
    511              OS_SchedLockTimeMeasStop();
    512          #endif
    513          
    514              CPU_CRITICAL_EXIT();                                    /* Scheduler should be re-enabled                         */
   \                     ??OS_TaskRdy_12:
   \   00003B FD....                CALL      CPU_IntDisMeasStop  ;; 3 cycles
   \   00003E 8800                  MOV       A, [SP]            ;; 1 cycle
   \   000040 FD....                CALL      N:??Subroutine15_0  ;; 3 cycles
   \   000043                       ; ------------------------------------- Block: 7 cycles
    515              OSSched();                                              /* Run the scheduler                                      */
   \                     ??CrossCallReturnLabel_27:
   \   000043 FD....                CALL      OSSched            ;; 3 cycles
    516             *p_err = OS_ERR_NONE;
   \   000046 F6                    CLRW      AX                 ;; 1 cycle
   \   000047                       ; ------------------------------------- Block: 4 cycles
   \                     ??OS_TaskRdy_10:
   \   000047 B9                    MOVW      [DE], AX           ;; 1 cycle
   \   000048                       ; ------------------------------------- Block: 1 cycles
   \   000048                       ; ------------------------------------- Total: 62 cycles
    517          }
   \   000048                       REQUIRE ?CLRL78_V1_0_L00
   \   000048                       REQUIRE ?Subroutine0
   \   000048                       ; // Fall through to label ?Subroutine0

   \                                 In  segment CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000 1004                  ADDW      SP, #0x4           ;; 1 cycle
   \   000002 C4                    POP       DE                 ;; 1 cycle
   \   000003 C2                    POP       BC                 ;; 1 cycle
   \   000004 D7                    RET                          ;; 6 cycles
   \   000005                       ; ------------------------------------- Block: 9 cycles
   \   000005                       ; ------------------------------------- Total: 9 cycles
   \   000005                       REQUIRE ?CLRL78_V1_0_L00
    518          
    519          /*$PAGE*/
    520          /*
    521          ************************************************************************************************************************
    522          *                                      CONFIGURE ROUND-ROBIN SCHEDULING PARAMETERS
    523          *
    524          * Description: This function is called to change the round-robin scheduling parameters.
    525          *
    526          * Arguments  : en                determines whether round-robin will be enabled (when DEF_EN) or not (when DEF_DIS)
    527          *
    528          *              dflt_time_quanta  default number of ticks between time slices.  0 means assumes OSCfg_TickRate_Hz / 10.
    529          *
    530          *              p_err             is a pointer to a variable that will contain an error code returned by this function.
    531          *
    532          *                                    OS_ERR_NONE    The call was successful
    533          *
    534          * Returns    : none
    535          ************************************************************************************************************************
    536          */
    537          
    538          #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
    539          void  OSSchedRoundRobinCfg (CPU_BOOLEAN  en,
    540                                      OS_TICK      dflt_time_quanta,
    541                                      OS_ERR      *p_err)
    542          {
    543              CPU_SR_ALLOC();
    544          
    545          
    546          
    547          #ifdef OS_SAFETY_CRITICAL
    548              if (p_err == (OS_ERR *)0) {
    549                  OS_SAFETY_CRITICAL_EXCEPTION();
    550                  return;
    551              }
    552          #endif
    553          
    554              CPU_CRITICAL_ENTER();
    555              if (en != DEF_ENABLED) {
    556                  OSSchedRoundRobinEn = DEF_DISABLED;
    557              } else {
    558                  OSSchedRoundRobinEn = DEF_ENABLED;
    559              }
    560          
    561              if (dflt_time_quanta > (OS_TICK)0) {
    562                  OSSchedRoundRobinDfltTimeQuanta = dflt_time_quanta;
    563              } else {
    564                  OSSchedRoundRobinDfltTimeQuanta = (OS_TICK)(OSCfg_TickRate_Hz / (OS_RATE_HZ)10);
    565              }
    566              CPU_CRITICAL_EXIT();
    567             *p_err = OS_ERR_NONE;
    568          }
    569          #endif
    570          
    571          /*$PAGE*/
    572          /*
    573          ************************************************************************************************************************
    574          *                                    YIELD CPU WHEN TASK NO LONGER NEEDS THE TIME SLICE
    575          *
    576          * Description: This function is called to give up the CPU when it is done executing before its time slice expires.
    577          *
    578          * Argument(s): p_err      is a pointer to a variable that will contain an error code returned by this function.
    579          *
    580          *                             OS_ERR_NONE                   The call was successful
    581          *                             OS_ERR_ROUND_ROBIN_1          Only 1 task at this priority, nothing to yield to
    582          *                             OS_ERR_ROUND_ROBIN_DISABLED   Round Robin is not enabled
    583          *                             OS_ERR_SCHED_LOCKED           The scheduler has been locked
    584          *                             OS_ERR_YIELD_ISR              Can't be called from an ISR
    585          *
    586          * Returns    : none
    587          *
    588          * Note(s)    : 1) This function MUST be called from a task.
    589          ************************************************************************************************************************
    590          */
    591          
    592          #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
    593          void  OSSchedRoundRobinYield (OS_ERR  *p_err)
    594          {
    595              OS_RDY_LIST  *p_rdy_list;
    596              OS_TCB       *p_tcb;
    597              CPU_SR_ALLOC();
    598          
    599          
    600          
    601          #ifdef OS_SAFETY_CRITICAL
    602              if (p_err == (OS_ERR *)0) {
    603                  OS_SAFETY_CRITICAL_EXCEPTION();
    604                  return;
    605              }
    606          #endif
    607          
    608          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    609              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't call this function from an ISR                   */
    610                 *p_err = OS_ERR_YIELD_ISR;
    611                  return;
    612              }
    613          #endif
    614          
    615              if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {        /* Can't yield if the scheduler is locked                 */
    616                 *p_err = OS_ERR_SCHED_LOCKED;
    617                  return;
    618              }
    619          
    620              if (OSSchedRoundRobinEn != DEF_TRUE) {                  /* Make sure round-robin has been enabled                 */
    621                 *p_err = OS_ERR_ROUND_ROBIN_DISABLED;
    622                  return;
    623              }
    624          
    625              CPU_CRITICAL_ENTER();
    626              p_rdy_list = &OSRdyList[OSPrioCur];                     /* Can't yield if it's the only task at that priority     */
    627              if (p_rdy_list->NbrEntries < (OS_OBJ_QTY)2) {
    628                  CPU_CRITICAL_EXIT();
    629                 *p_err = OS_ERR_ROUND_ROBIN_1;
    630                  return;
    631              }
    632          
    633              OS_RdyListMoveHeadToTail(p_rdy_list);                   /* Move current OS_TCB to the end of the list             */
    634              p_tcb = p_rdy_list->HeadPtr;                            /* Point to new OS_TCB at head of the list                */
    635              if (p_tcb->TimeQuanta == (OS_TICK)0) {                  /* See if we need to use the default time slice           */
    636                  p_tcb->TimeQuantaCtr = OSSchedRoundRobinDfltTimeQuanta;
    637              } else {
    638                  p_tcb->TimeQuantaCtr = p_tcb->TimeQuanta;           /* Load time slice counter with new time                  */
    639              }
    640          
    641              CPU_CRITICAL_EXIT();
    642          
    643              OSSched();                                              /* Run new task                                           */
    644             *p_err = OS_ERR_NONE;
    645          }
    646          #endif
    647          
    648          /*$PAGE*/
    649          /*
    650          ************************************************************************************************************************
    651          *                                                 START MULTITASKING
    652          *
    653          * Description: This function is used to start the multitasking process which lets uC/OS-III manages the task that you
    654          *              created.  Before you can call OSStart(), you MUST have called OSInit() and you MUST have created at least
    655          *              one application task.
    656          *
    657          * Argument(s): p_err      is a pointer to a variable that will contain an error code returned by this function.
    658          *
    659          *                             OS_ERR_FATAL_RETURN    OS was running and OSStart() returned.
    660          *                             OS_ERR_OS_RUNNING      OS is already running, OSStart() has no effect
    661          *
    662          * Returns    : none
    663          *
    664          * Note(s)    : 1) OSStartHighRdy() MUST:
    665          *                 a) Call OSTaskSwHook() then,
    666          *                 b) Load the context of the task pointed to by OSTCBHighRdyPtr.
    667          *                 c) Execute the task.
    668          *
    669          *              2) OSStart() is not supposed to return.  If it does, that would be considered a fatal error.
    670          ************************************************************************************************************************
    671          */
    672          

   \                                 In  segment CODE, align 1, keep-with-next
    673          void  OSStart (OS_ERR  *p_err)
   \                     OSStart:
    674          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000 C3                    PUSH      BC                 ;; 1 cycle
   \   000001 C5                    PUSH      DE                 ;; 1 cycle
   \   000002                       ; Auto size: 0
   \   000002 14                    MOVW      DE, AX             ;; 1 cycle
    675          #ifdef OS_SAFETY_CRITICAL
    676              if (p_err == (OS_ERR *)0) {
    677                  OS_SAFETY_CRITICAL_EXCEPTION();
    678                  return;
    679              }
    680          #endif
    681          
    682              if (OSRunning == OS_STATE_OS_STOPPED) {
   \   000003 D5....                CMP0      N:OSRunning        ;; 1 cycle
   \   000006 DF22                  BNZ       ??OS_TaskRdy_13    ;; 4 cycles
   \   000008                       ; ------------------------------------- Block: 8 cycles
    683                  OSPrioHighRdy   = OS_PrioGetHighest();              /* Find the highest priority                              */
   \   000008 FD....                CALL      OS_PrioGetHighest  ;; 3 cycles
   \   00000B 9F....                MOV       N:OSPrioHighRdy, A  ;; 1 cycle
    684                  OSPrioCur       = OSPrioHighRdy;
   \   00000E 9F....                MOV       N:OSPrioCur, A     ;; 1 cycle
    685                  OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;
   \   000011 70                    MOV       X, A               ;; 1 cycle
   \   000012 F1                    CLRB      A                  ;; 1 cycle
   \   000013 320600                MOVW      BC, #0x6           ;; 1 cycle
   \   000016 CEFB01                MULHU                        ;; 2 cycles
   \   000019 FD....                CALL      N:?Subroutine13    ;; 3 cycles
   \   00001C                       ; ------------------------------------- Block: 13 cycles
    686                  OSTCBCurPtr     = OSTCBHighRdyPtr;
   \                     ??CrossCallReturnLabel_22:
   \   00001C BF....                MOVW      N:OSTCBCurPtr, AX  ;; 1 cycle
    687                  OSRunning       = OS_STATE_OS_RUNNING;
   \   00001F E5....                ONEB      N:OSRunning        ;; 1 cycle
    688                  OSStartHighRdy();                                   /* Execute target specific code to start task             */
   \   000022 FD....                CALL      OSStartHighRdy     ;; 3 cycles
    689                 *p_err           = OS_ERR_FATAL_RETURN;              /* OSStart() is not supposed to return                    */
   \   000025 30993A                MOVW      AX, #0x3A99        ;; 1 cycle
   \   000028 EF03                  BR        S:??OS_TaskRdy_14  ;; 3 cycles
   \   00002A                       ; ------------------------------------- Block: 9 cycles
    690              } else {
    691                 *p_err           = OS_ERR_OS_RUNNING;                /* OS is already running                                  */
   \                     ??OS_TaskRdy_13:
   \   00002A 308A5E                MOVW      AX, #0x5E8A        ;; 1 cycle
   \   00002D                       ; ------------------------------------- Block: 1 cycles
   \                     ??OS_TaskRdy_14:
   \   00002D B9                    MOVW      [DE], AX           ;; 1 cycle
    692              }
    693          }
   \   00002E C4                    POP       DE                 ;; 1 cycle
   \   00002F C2                    POP       BC                 ;; 1 cycle
   \   000030 D7                    RET                          ;; 6 cycles
   \   000031                       ; ------------------------------------- Block: 9 cycles
   \   000031                       ; ------------------------------------- Total: 40 cycles
   \   000031                       REQUIRE ?CLRL78_V1_0_L00
    694          
    695          /*$PAGE*/
    696          /*
    697          ************************************************************************************************************************
    698          *                                                    GET VERSION
    699          *
    700          * Description: This function is used to return the version number of uC/OS-III.  The returned value corresponds to
    701          *              uC/OS-III's version number multiplied by 10000.  In other words, version 3.01.02 would be returned as 30102.
    702          *
    703          * Arguments  : p_err   is a pointer to a variable that will receive an error code.  However, OSVersion() set this
    704          *                      variable to
    705          *
    706          *                         OS_ERR_NONE
    707          *
    708          * Returns    : The version number of uC/OS-III multiplied by 10000.
    709          ************************************************************************************************************************
    710          */
    711          

   \                                 In  segment CODE, align 1, keep-with-next
    712          CPU_INT16U  OSVersion (OS_ERR  *p_err)
   \                     OSVersion:
    713          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000                       ; Auto size: 0
   \   000000 16                    MOVW      HL, AX             ;; 1 cycle
    714          #ifdef OS_SAFETY_CRITICAL
    715              if (p_err == (OS_ERR *)0) {
    716                  OS_SAFETY_CRITICAL_EXCEPTION();
    717                  return ((CPU_INT16U)0u);
    718              }
    719          #endif
    720          
    721             *p_err = OS_ERR_NONE;
   \   000001 F6                    CLRW      AX                 ;; 1 cycle
   \   000002 BB                    MOVW      [HL], AX           ;; 1 cycle
    722              return (OS_VERSION);
   \   000003 30F875                MOVW      AX, #0x75F8        ;; 1 cycle
   \   000006 D7                    RET                          ;; 6 cycles
   \   000007                       ; ------------------------------------- Block: 10 cycles
   \   000007                       ; ------------------------------------- Total: 10 cycles
   \   000007                       REQUIRE ?CLRL78_V1_0_L00
    723          }
    724          
    725          /*$PAGE*/
    726          /*
    727          ************************************************************************************************************************
    728          *                                                      IDLE TASK
    729          *
    730          * Description: This task is internal to uC/OS-III and executes whenever no other higher priority tasks executes because
    731          *              they are ALL waiting for event(s) to occur.
    732          *
    733          * Arguments  : p_arg    is an argument passed to the task when the task is created.
    734          *
    735          * Returns    : none
    736          *
    737          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    738          *
    739          *              2) OSIdleTaskHook() is called after the critical section to ensure that interrupts will be enabled for at
    740          *                 least a few instructions.  On some processors (ex. Philips XA), enabling and then disabling interrupts
    741          *                 doesn't allow the processor enough time to have interrupts enabled before they were disabled again.
    742          *                 uC/OS-III would thus never recognize interrupts.
    743          *
    744          *              3) This hook has been added to allow you to do such things as STOP the CPU to conserve power.
    745          ************************************************************************************************************************
    746          */
    747          

   \                                 In  segment CODE, align 1, keep-with-next
    748          void  OS_IdleTask (void *p_arg)
   \                     OS_IdleTask:
    749          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000 C3                    PUSH      BC                 ;; 1 cycle
   \   000001 C5                    PUSH      DE                 ;; 1 cycle
   \   000002                       ; Auto size: 0
    750              CPU_SR_ALLOC();
    751          
    752          
    753          
    754              p_arg = p_arg;                                          /* Prevent compiler warning for not using 'p_arg'         */
   \   000002                       ; ------------------------------------- Block: 2 cycles
    755          
    756              while (DEF_ON) {
    757                  CPU_CRITICAL_ENTER();
   \                     ??OS_IdleTask_0:
   \   000002 8EFA                  MOV       A, PSW             ;; 1 cycle
   \   000004 73                    MOV       B, A               ;; 1 cycle
   \   000005 717BFA                DI                           ;; 2 cycles
   \   000008 FD....                CALL      CPU_IntDisMeasStart  ;; 3 cycles
    758                  OSIdleTaskCtr++;
   \   00000B FB....                MOVW      HL, N:OSIdleTaskCtr+2  ;; 1 cycle
   \   00000E AF....                MOVW      AX, N:OSIdleTaskCtr  ;; 1 cycle
   \   000011 040100                ADDW      AX, #0x1           ;; 1 cycle
   \   000014 61D8                  SKNC
   \   000016 A7                    INCW      HL                 ;; 5 cycles
   \   000017 BF....                MOVW      N:OSIdleTaskCtr, AX  ;; 1 cycle
   \   00001A 17                    MOVW      AX, HL             ;; 1 cycle
   \   00001B BF....                MOVW      N:OSIdleTaskCtr+2, AX  ;; 1 cycle
    759          #if OS_CFG_STAT_TASK_EN > 0u
    760                  OSStatTaskCtr++;
    761          #endif
    762                  CPU_CRITICAL_EXIT();
   \   00001E FD....                CALL      CPU_IntDisMeasStop  ;; 3 cycles
   \   000021 FD....                CALL      N:?Subroutine10    ;; 3 cycles
   \   000024                       ; ------------------------------------- Block: 24 cycles
    763          
    764                  OSIdleTaskHook();                                   /* Call user definable HOOK                               */
   \                     ??CrossCallReturnLabel_29:
   \   000024 FD....                CALL      OSIdleTaskHook     ;; 3 cycles
   \   000027 EFD9                  BR        S:??OS_IdleTask_0  ;; 3 cycles
   \   000029                       ; ------------------------------------- Block: 6 cycles
   \   000029                       ; ------------------------------------- Total: 32 cycles
   \   000029                       REQUIRE ?CLRL78_V1_0_L00
    765              }
    766          }
    767          
    768          /*$PAGE*/
    769          /*
    770          ************************************************************************************************************************
    771          *                                               INITIALIZE THE IDLE TASK
    772          *
    773          * Description: This function initializes the idle task
    774          *
    775          * Arguments  : p_err    is a pointer to a variable that will contain an error code returned by this function.
    776          *
    777          * Returns    : none
    778          *
    779          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    780          ************************************************************************************************************************
    781          */
    782          

   \                                 In  segment CODE, align 1, keep-with-next
    783          void  OS_IdleTaskInit (OS_ERR  *p_err)
   \                     OS_IdleTaskInit:
    784          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000 C3                    PUSH      BC                 ;; 1 cycle
   \   000001 C5                    PUSH      DE                 ;; 1 cycle
   \   000002                       ; Auto size: 0
   \   000002 14                    MOVW      DE, AX             ;; 1 cycle
    785          #ifdef OS_SAFETY_CRITICAL
    786              if (p_err == (OS_ERR *)0) {
    787                  OS_SAFETY_CRITICAL_EXCEPTION();
    788                  return;
    789              }
    790          #endif
    791          
    792              OSIdleTaskCtr = (OS_IDLE_CTR)0;
   \   000003 36....                MOVW      HL, #OSIdleTaskCtr  ;; 1 cycle
   \   000006 F6                    CLRW      AX                 ;; 1 cycle
   \   000007 BB                    MOVW      [HL], AX           ;; 1 cycle
   \   000008 BC02                  MOVW      [HL+0x02], AX      ;; 1 cycle
    793                                                                      /* ---------------- CREATE THE IDLE TASK ---------------- */
    794              OSTaskCreate((OS_TCB     *)&OSIdleTaskTCB,
    795                           (CPU_CHAR   *)((void *)"uC/OS-III Idle Task"),
    796                           (OS_TASK_PTR)OS_IdleTask,
    797                           (void       *)0,
    798                           (OS_PRIO     )(OS_CFG_PRIO_MAX - 1u),
    799                           (CPU_STK    *)OSCfg_IdleTaskStkBasePtr,
    800                           (CPU_STK_SIZE)OSCfg_IdleTaskStkLimit,
    801                           (CPU_STK_SIZE)OSCfg_IdleTaskStkSize,
    802                           (OS_MSG_QTY  )0u,
    803                           (OS_TICK     )0u,
    804                           (void       *)0,
    805                           (OS_OPT      )(OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR),
    806                           (OS_ERR     *)p_err);
   \   00000A C5                    PUSH      DE                 ;; 1 cycle
   \   00000B 5003                  MOV       X, #0x3            ;; 1 cycle
   \   00000D C1                    PUSH      AX                 ;; 1 cycle
   \   00000E F6                    CLRW      AX                 ;; 1 cycle
   \   00000F C1                    PUSH      AX                 ;; 1 cycle
   \   000010 C1                    PUSH      AX                 ;; 1 cycle
   \   000011 C1                    PUSH      AX                 ;; 1 cycle
   \   000012 C1                    PUSH      AX                 ;; 1 cycle
   \   000013 AF....                MOVW      AX, N:OSCfg_IdleTaskStkSize  ;; 1 cycle
   \   000016 C1                    PUSH      AX                 ;; 1 cycle
   \   000017 AF....                MOVW      AX, N:OSCfg_IdleTaskStkLimit  ;; 1 cycle
   \   00001A C1                    PUSH      AX                 ;; 1 cycle
   \   00001B AF....                MOVW      AX, N:OSCfg_IdleTaskStkBasePtr  ;; 1 cycle
   \   00001E C1                    PUSH      AX                 ;; 1 cycle
   \   00001F 300700                MOVW      AX, #0x7           ;; 1 cycle
   \   000022 C1                    PUSH      AX                 ;; 1 cycle
   \   000023 F6                    CLRW      AX                 ;; 1 cycle
   \   000024 C1                    PUSH      AX                 ;; 1 cycle
   \   000025 34....                MOVW      DE, #OS_IdleTask   ;; 1 cycle
   \   000028 32....                MOVW      BC, #`?<Constant "uC/OS-III Idle Task">`  ;; 1 cycle
   \   00002B 30....                MOVW      AX, #OSIdleTaskTCB  ;; 1 cycle
   \   00002E FD....                CALL      OSTaskCreate       ;; 3 cycles
    807          }
   \   000031 C4                    POP       DE                 ;; 1 cycle
   \   000032 C2                    POP       BC                 ;; 1 cycle
   \   000033 D7                    RET                          ;; 6 cycles
   \   000034                       ; ------------------------------------- Block: 39 cycles
   \   000034                       ; ------------------------------------- Total: 39 cycles
   \   000034                       REQUIRE ?CLRL78_V1_0_L00
    808          
    809          /*$PAGE*/
    810          /*
    811          ************************************************************************************************************************
    812          *                                             BLOCK A TASK PENDING ON EVENT
    813          *
    814          * Description: This function is called to place a task in the blocked state waiting for an event to occur. This function
    815          *              exist because it is common to a number of OSxxxPend() services.
    816          *
    817          * Arguments  : p_pend_data    is a pointer to an object used to link the task being blocked to the list of task(s)
    818          *              -----------    pending on the desired object.
    819          
    820          *              p_obj          is a pointer to the object to pend on.  If there are no object used to pend on then
    821          *              -----          the caller must pass a NULL pointer.
    822          *
    823          *              pending_on     Specifies what the task will be pending on:
    824          *
    825          *                                 OS_TASK_PEND_ON_FLAG
    826          *                                 OS_TASK_PEND_ON_TASK_Q     <- No object (pending for a message sent to the task)
    827          *                                 OS_TASK_PEND_ON_MUTEX
    828          *                                 OS_TASK_PEND_ON_Q
    829          *                                 OS_TASK_PEND_ON_SEM
    830          *                                 OS_TASK_PEND_ON_TASK_SEM   <- No object (pending on a signal sent to the task)
    831          *
    832          *              timeout        Is the amount of time the task will wait for the event to occur.
    833          *
    834          * Returns    : none
    835          *
    836          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    837          ************************************************************************************************************************
    838          */
    839          

   \                                 In  segment CODE, align 1, keep-with-next
    840          void  OS_Pend (OS_PEND_DATA  *p_pend_data,
   \                     OS_Pend:
    841                         OS_PEND_OBJ   *p_obj,
    842                         OS_STATE       pending_on,
    843                         OS_TICK        timeout)
    844          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 4
   \   000000 C5                    PUSH      DE                 ;; 1 cycle
   \   000001 C1                    PUSH      AX                 ;; 1 cycle
   \   000002 C3                    PUSH      BC                 ;; 1 cycle
   \   000003                       ; Auto size: 4
    845              OS_PEND_LIST  *p_pend_list;
    846          
    847          
    848          
    849              OSTCBCurPtr->PendOn     = pending_on;                    /* Resource not available, wait until it is              */
   \   000003 FB....                MOVW      HL, N:OSTCBCurPtr  ;; 1 cycle
   \   000006 65                    MOV       A, D               ;; 1 cycle
   \   000007 9C1A                  MOV       [HL+0x1A], A       ;; 1 cycle
    850              OSTCBCurPtr->PendStatus = OS_STATUS_PEND_OK;
   \   000009 FB....                MOVW      HL, N:OSTCBCurPtr  ;; 1 cycle
   \   00000C F1                    CLRB      A                  ;; 1 cycle
   \   00000D 9C1B                  MOV       [HL+0x1B], A       ;; 1 cycle
    851          
    852              OS_TaskBlock(OSTCBCurPtr,                                /* Block the task and add it to the tick list if needed  */
    853                           timeout);
   \   00000F A80C                  MOVW      AX, [SP+0x0C]      ;; 1 cycle
   \   000011 12                    MOVW      BC, AX             ;; 1 cycle
   \   000012 A80A                  MOVW      AX, [SP+0x0A]      ;; 1 cycle
   \   000014 C3                    PUSH      BC                 ;; 1 cycle
   \   000015 C1                    PUSH      AX                 ;; 1 cycle
   \   000016 AF....                MOVW      AX, N:OSTCBCurPtr  ;; 1 cycle
   \   000019 FD....                CALL      OS_TaskBlock       ;; 3 cycles
    854          
    855              if (p_obj != (OS_PEND_OBJ *)0) {                         /* Add the current task to the pend list ...             */
   \   00001C A800                  MOVW      AX, [SP]           ;; 1 cycle
   \   00001E 440000                CMPW      AX, #0x0           ;; 1 cycle
   \   000021 DD1F                  BZ        ??OS_TaskRdy_15    ;; 4 cycles
   \   000023                       ; ------------------------------------- Block: 24 cycles
    856                  p_pend_list             = &p_obj->PendList;          /* ... if there is an object to pend on                  */
    857                  p_pend_data->PendObjPtr = p_obj;                     /* Save the pointer to the object pending on             */
   \   000023 16                    MOVW      HL, AX             ;; 1 cycle
   \   000024 A802                  MOVW      AX, [SP+0x02]      ;; 1 cycle
   \   000026 14                    MOVW      DE, AX             ;; 1 cycle
   \   000027 17                    MOVW      AX, HL             ;; 1 cycle
   \   000028 BA06                  MOVW      [DE+0x06], AX      ;; 1 cycle
    858                  OS_PendDataInit((OS_TCB       *)OSTCBCurPtr,         /* Initialize the remaining field                        */
    859                                  (OS_PEND_DATA *)p_pend_data,
    860                                  (OS_OBJ_QTY    )1);
   \   00002A E6                    ONEW      AX                 ;; 1 cycle
   \   00002B 14                    MOVW      DE, AX             ;; 1 cycle
   \   00002C A802                  MOVW      AX, [SP+0x02]      ;; 1 cycle
   \   00002E 12                    MOVW      BC, AX             ;; 1 cycle
   \   00002F AF....                MOVW      AX, N:OSTCBCurPtr  ;; 1 cycle
   \   000032 FD....                CALL      OS_PendDataInit    ;; 3 cycles
    861                  OS_PendListInsertPrio(p_pend_list,                   /* Insert in the pend list in priority order             */
    862                                        p_pend_data);
   \   000035 A802                  MOVW      AX, [SP+0x02]      ;; 1 cycle
   \   000037 12                    MOVW      BC, AX             ;; 1 cycle
   \   000038 A800                  MOVW      AX, [SP]           ;; 1 cycle
   \   00003A 040600                ADDW      AX, #0x6           ;; 1 cycle
   \   00003D FD....                CALL      OS_PendListInsertPrio  ;; 3 cycles
   \   000040 EF0B                  BR        S:??OS_TaskRdy_16  ;; 3 cycles
   \   000042                       ; ------------------------------------- Block: 23 cycles
    863              } else {
    864                  OSTCBCurPtr->PendDataTblEntries = (OS_OBJ_QTY    )0; /* If no object being pended on the clear these fields   */
   \                     ??OS_TaskRdy_15:
   \   000042 FB....                MOVW      HL, N:OSTCBCurPtr  ;; 1 cycle
   \   000045 F6                    CLRW      AX                 ;; 1 cycle
   \   000046 BC22                  MOVW      [HL+0x22], AX      ;; 1 cycle
    865                  OSTCBCurPtr->PendDataTblPtr     = (OS_PEND_DATA *)0; /* ... in the TCB                                        */
   \   000048 FB....                MOVW      HL, N:OSTCBCurPtr  ;; 1 cycle
   \   00004B BC18                  MOVW      [HL+0x18], AX      ;; 1 cycle
   \   00004D                       ; ------------------------------------- Block: 5 cycles
    866              }
    867          #if OS_CFG_DBG_EN > 0u
    868              OS_PendDbgNameAdd(p_obj,
    869                                OSTCBCurPtr);
    870          #endif
    871          }
   \                     ??OS_TaskRdy_16:
   \   00004D ED....                BR        N:?Subroutine3     ;; 3 cycles
   \   000050                       ; ------------------------------------- Block: 3 cycles
   \   000050                       ; ------------------------------------- Total: 55 cycles
   \   000050                       REQUIRE ?CLRL78_V1_0_L00

   \                                 In  segment CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000 1004                  ADDW      SP, #0x4           ;; 1 cycle
   \   000002                       ; ------------------------------------- Block: 1 cycles
   \   000002                       ; ------------------------------------- Total: 1 cycles
   \   000002                       REQUIRE ?CLRL78_V1_0_L00
   \   000002                       REQUIRE ??Subroutine16_0
   \   000002                       ; // Fall through to label ??Subroutine16_0

   \                                 In  segment CODE, align 1, keep-with-next
   \                     ??Subroutine16_0:
   \   000000 C4                    POP       DE                 ;; 1 cycle
   \   000001                       ; ------------------------------------- Block: 1 cycles
   \   000001                       ; ------------------------------------- Total: 1 cycles
   \   000001                       REQUIRE ?CLRL78_V1_0_L00
   \   000001                       REQUIRE ??Subroutine17_0
   \   000001                       ; // Fall through to label ??Subroutine17_0

   \                                 In  segment CODE, align 1, keep-with-next
   \                     ??Subroutine17_0:
   \   000000 FD....                CALL      N:?FUNC_LEAVE_L06
   \   000003 0400                  DW        0x4                ;; 3 cycles
   \   000005                       ; ------------------------------------- Block: 3 cycles
   \   000005                       ; ------------------------------------- Total: 3 cycles
   \   000005                       REQUIRE ?CLRL78_V1_0_L00
    872          
    873          /*$PAGE*/
    874          /*
    875          ************************************************************************************************************************
    876          *                                                     ABORT PENDING
    877          *
    878          * Description: This function is called by OSxxxPendAbort() functions to abort pending on an event.
    879          *
    880          * Arguments  : p_obj          Is a pointer to the object to pend abort.
    881          *              -----
    882          *
    883          *              p_tcb          Is a pointer to the OS_TCB of the task that we'll abort the pend for
    884          *              -----
    885          *
    886          *              ts             The is a timestamp as to when the pend abort occurred
    887          *
    888          * Returns    : none
    889          *
    890          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    891          ************************************************************************************************************************
    892          */
    893          

   \                                 In  segment CODE, align 1, keep-with-next
    894          void   OS_PendAbort (OS_PEND_OBJ *p_obj,
   \                     OS_PendAbort:
    895                               OS_TCB      *p_tcb,
    896                               CPU_TS       ts)
    897          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 4
   \   000000 C5                    PUSH      DE                 ;; 1 cycle
   \   000001 C1                    PUSH      AX                 ;; 1 cycle
   \   000002                       ; Auto size: 2
   \   000002 C3                    PUSH      BC                 ;; 1 cycle
   \   000003 C4                    POP       DE                 ;; 1 cycle
    898              switch (p_tcb->TaskState) {
   \   000004 8A1C                  MOV       A, [DE+0x1C]       ;; 1 cycle
   \   000006 2C02                  SUB       A, #0x2            ;; 1 cycle
   \   000008 4C02                  CMP       A, #0x2            ;; 1 cycle
   \   00000A DC08                  BC        ??OS_TaskRdy_17    ;; 4 cycles
   \   00000C                       ; ------------------------------------- Block: 11 cycles
   \   00000C 2C04                  SUB       A, #0x4            ;; 1 cycle
   \   00000E 4C02                  CMP       A, #0x2            ;; 1 cycle
   \   000010 DC33                  BC        ??OS_TaskRdy_18    ;; 4 cycles
   \   000012                       ; ------------------------------------- Block: 6 cycles
   \   000012 EF69                  BR        S:??OS_TaskRdy_19  ;; 3 cycles
   \   000014                       ; ------------------------------------- Block: 3 cycles
   \                     ??OS_TaskRdy_17:
   \   000014 8A1A                  MOV       A, [DE+0x1A]       ;; 1 cycle
   \   000016 4C03                  CMP       A, #0x3            ;; 1 cycle
   \   000018 DF0E                  BNZ       ??OS_TaskRdy_20    ;; 4 cycles
   \   00001A                       ; ------------------------------------- Block: 6 cycles
    899                  case OS_TASK_STATE_RDY:                             /* Cannot Pend Abort a task that is ready                 */
    900                  case OS_TASK_STATE_DLY:                             /* Cannot Pend Abort a task that is delayed               */
    901                  case OS_TASK_STATE_SUSPENDED:                       /* Cannot Pend Abort a suspended task                     */
    902                  case OS_TASK_STATE_DLY_SUSPENDED:                   /* Cannot Pend Abort a suspended task that was also dly'd */
    903                       break;
    904          
    905                  case OS_TASK_STATE_PEND:
    906                  case OS_TASK_STATE_PEND_TIMEOUT:
    907                       if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
    908                           OS_PendAbort1(p_obj,                            /* Indicate which object was pend aborted            */
    909                                         p_tcb,
    910                                         ts);
   \   00001A A80A                  MOVW      AX, [SP+0x0A]      ;; 1 cycle
   \   00001C 12                    MOVW      BC, AX             ;; 1 cycle
   \   00001D A808                  MOVW      AX, [SP+0x08]      ;; 1 cycle
   \   00001F C3                    PUSH      BC                 ;; 1 cycle
   \   000020 C1                    PUSH      AX                 ;; 1 cycle
   \   000021 C5                    PUSH      DE                 ;; 1 cycle
   \   000022 C2                    POP       BC                 ;; 1 cycle
   \   000023 A804                  MOVW      AX, [SP+0x04]      ;; 1 cycle
   \   000025 FD....                CALL      OS_PendAbort1      ;; 3 cycles
   \   000028                       ; ------------------------------------- Block: 11 cycles
    911                       }
    912          #if (OS_MSG_EN > 0u)
    913                       p_tcb->MsgPtr     = (void      *)0;
   \                     ??OS_TaskRdy_20:
   \   000028 FD....                CALL      N:?Subroutine6     ;; 3 cycles
   \   00002B                       ; ------------------------------------- Block: 3 cycles
    914                       p_tcb->MsgSize    = (OS_MSG_SIZE)0u;
    915          #endif
    916                       p_tcb->TS         = ts;
   \                     ??CrossCallReturnLabel_3:
   \   00002B A80A                  MOVW      AX, [SP+0x0A]      ;; 1 cycle
   \   00002D 12                    MOVW      BC, AX             ;; 1 cycle
   \   00002E A808                  MOVW      AX, [SP+0x08]      ;; 1 cycle
   \   000030 FD....                CALL      N:?Subroutine12    ;; 3 cycles
   \   000033                       ; ------------------------------------- Block: 6 cycles
    917                       if (p_obj != (OS_PEND_OBJ *)0) {
   \                     ??CrossCallReturnLabel_16:
   \   000033 A800                  MOVW      AX, [SP]           ;; 1 cycle
   \   000035 440000                CMPW      AX, #0x0           ;; 1 cycle
   \   000038 DD04                  BZ        ??OS_TaskRdy_21    ;; 4 cycles
   \   00003A                       ; ------------------------------------- Block: 6 cycles
    918                           OS_PendListRemove(p_tcb);                       /* Remove task from all pend lists                   */
   \   00003A 15                    MOVW      AX, DE             ;; 1 cycle
   \   00003B FD....                CALL      OS_PendListRemove  ;; 3 cycles
   \   00003E                       ; ------------------------------------- Block: 4 cycles
    919                       }
    920                       OS_TaskRdy(p_tcb);
   \                     ??OS_TaskRdy_21:
   \   00003E 15                    MOVW      AX, DE             ;; 1 cycle
   \   00003F FD....                CALL      OS_TaskRdy         ;; 3 cycles
    921                       p_tcb->TaskState  = OS_TASK_STATE_RDY;              /* Task will be ready                                */
   \   000042 F1                    CLRB      A                  ;; 1 cycle
   \   000043 EF30                  BR        S:??OS_TaskRdy_22  ;; 3 cycles
   \   000045                       ; ------------------------------------- Block: 8 cycles
   \                     ??OS_TaskRdy_18:
   \   000045 8A1A                  MOV       A, [DE+0x1A]       ;; 1 cycle
   \   000047 4C03                  CMP       A, #0x3            ;; 1 cycle
   \   000049 DF0E                  BNZ       ??OS_TaskRdy_23    ;; 4 cycles
   \   00004B                       ; ------------------------------------- Block: 6 cycles
    922                       p_tcb->PendStatus = OS_STATUS_PEND_ABORT;           /* Indicate pend was aborted                         */
    923                       p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
    924                       break;
    925          
    926                  case OS_TASK_STATE_PEND_SUSPENDED:
    927                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
    928                       if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
    929                           OS_PendAbort1(p_obj,                            /* Indicate which object was pend aborted            */
    930                                         p_tcb,
    931                                         ts);
   \   00004B A80A                  MOVW      AX, [SP+0x0A]      ;; 1 cycle
   \   00004D 12                    MOVW      BC, AX             ;; 1 cycle
   \   00004E A808                  MOVW      AX, [SP+0x08]      ;; 1 cycle
   \   000050 C3                    PUSH      BC                 ;; 1 cycle
   \   000051 C1                    PUSH      AX                 ;; 1 cycle
   \   000052 C5                    PUSH      DE                 ;; 1 cycle
   \   000053 C2                    POP       BC                 ;; 1 cycle
   \   000054 A804                  MOVW      AX, [SP+0x04]      ;; 1 cycle
   \   000056 FD....                CALL      OS_PendAbort1      ;; 3 cycles
   \   000059                       ; ------------------------------------- Block: 11 cycles
    932                       }
    933          #if (OS_MSG_EN > 0u)
    934                       p_tcb->MsgPtr     = (void      *)0;
   \                     ??OS_TaskRdy_23:
   \   000059 FD....                CALL      N:?Subroutine6     ;; 3 cycles
   \   00005C                       ; ------------------------------------- Block: 3 cycles
    935                       p_tcb->MsgSize    = (OS_MSG_SIZE)0u;
    936          #endif
    937                       p_tcb->TS         = ts;
   \                     ??CrossCallReturnLabel_4:
   \   00005C A80A                  MOVW      AX, [SP+0x0A]      ;; 1 cycle
   \   00005E 12                    MOVW      BC, AX             ;; 1 cycle
   \   00005F A808                  MOVW      AX, [SP+0x08]      ;; 1 cycle
   \   000061 FD....                CALL      N:?Subroutine12    ;; 3 cycles
   \   000064                       ; ------------------------------------- Block: 6 cycles
    938                       if (p_obj != (OS_PEND_OBJ *)0) {
   \                     ??CrossCallReturnLabel_17:
   \   000064 A800                  MOVW      AX, [SP]           ;; 1 cycle
   \   000066 440000                CMPW      AX, #0x0           ;; 1 cycle
   \   000069 DD04                  BZ        ??OS_TaskRdy_24    ;; 4 cycles
   \   00006B                       ; ------------------------------------- Block: 6 cycles
    939                           OS_PendListRemove(p_tcb);                       /* Remove task from all pend lists                   */
   \   00006B 15                    MOVW      AX, DE             ;; 1 cycle
   \   00006C FD....                CALL      OS_PendListRemove  ;; 3 cycles
   \   00006F                       ; ------------------------------------- Block: 4 cycles
    940                       }
    941                       OS_TickListRemove(p_tcb);                           /* Cancel the timeout                                */
   \                     ??OS_TaskRdy_24:
   \   00006F 15                    MOVW      AX, DE             ;; 1 cycle
   \   000070 FD....                CALL      OS_TickListRemove  ;; 3 cycles
    942                       p_tcb->TaskState  = OS_TASK_STATE_SUSPENDED;        /* Pend Aborted task is still suspended              */
   \   000073 5104                  MOV       A, #0x4            ;; 1 cycle
   \   000075                       ; ------------------------------------- Block: 5 cycles
   \                     ??OS_TaskRdy_22:
   \   000075 9A1C                  MOV       [DE+0x1C], A       ;; 1 cycle
    943                       p_tcb->PendStatus = OS_STATUS_PEND_ABORT;           /* Indicate pend was aborted                         */
   \   000077 E1                    ONEB      A                  ;; 1 cycle
   \   000078 9A1B                  MOV       [DE+0x1B], A       ;; 1 cycle
    944                       p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
   \   00007A F1                    CLRB      A                  ;; 1 cycle
   \   00007B 9A1A                  MOV       [DE+0x1A], A       ;; 1 cycle
    945                       break;
   \   00007D                       ; ------------------------------------- Block: 5 cycles
    946          
    947                  default:
    948                       break;
    949              }
    950          }
   \                     ??OS_TaskRdy_19:
   \   00007D                       REQUIRE ?CLRL78_V1_0_L00
   \   00007D                       REQUIRE ?Subroutine14
   \   00007D                       ; // Fall through to label ?Subroutine14

   \                                 In  segment CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000 1002                  ADDW      SP, #0x2           ;; 1 cycle
   \   000002 ED....                BR        N:??Subroutine16_0  ;; 3 cycles
   \   000005                       ; ------------------------------------- Block: 4 cycles
   \   000005                       ; ------------------------------------- Total: 4 cycles
   \   000005                       REQUIRE ?CLRL78_V1_0_L00

   \                                 In  segment CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000 BA24                  MOVW      [DE+0x24], AX      ;; 1 cycle
   \   000002 13                    MOVW      AX, BC             ;; 1 cycle
   \   000003 BA26                  MOVW      [DE+0x26], AX      ;; 1 cycle
   \   000005 D7                    RET                          ;; 6 cycles
   \   000006                       ; ------------------------------------- Block: 9 cycles
   \   000006                       ; ------------------------------------- Total: 9 cycles
   \   000006                       REQUIRE ?CLRL78_V1_0_L00

   \                                 In  segment CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000 F6                    CLRW      AX                 ;; 1 cycle
   \   000001 BA40                  MOVW      [DE+0x40], AX      ;; 1 cycle
   \   000003 BA42                  MOVW      [DE+0x42], AX      ;; 1 cycle
   \   000005 D7                    RET                          ;; 6 cycles
   \   000006                       ; ------------------------------------- Block: 9 cycles
   \   000006                       ; ------------------------------------- Total: 9 cycles
   \   000006                       REQUIRE ?CLRL78_V1_0_L00
    951          
    952          /*$PAGE*/
    953          /*
    954          ************************************************************************************************************************
    955          *                                           PEND ABORT A TASK PENDING ON MULTIPLE OBJECTS
    956          *
    957          * Description: This function is called when a task is pending on multiple objects and one of the objects has been pend
    958          *              aborted.  This function needs to indicate to the caller which object was pend aborted by placing the
    959          *              address of the object in the OS_PEND_DATA table corresponding to the pend aborted object.
    960          *
    961          *              For example, if the task pends on six (6) objects, the address of those 6 objects are placed in the
    962          *              .PendObjPtr field of the OS_PEND_DATA table as shown below.  Note that the .PendDataTblEntries of the
    963          *              OS_TCB would be set to six (6) in this case.  As shown, when the pend call returns because a task pend
    964          *              aborted 'Obj C' then, only the one entry contains the .RdyObjPtr filled in data and the other entries
    965          *              contains NULL pointers and zero data.
    966          *
    967          *              You should note that the NULL pointers are zero data values are actually filled in by the pend call.
    968          *
    969          *
    970          *                                           .PendObjPtr    .RdyObjPtr     .RdyMsgPtr     .RdyMsgSize    .RdyTS
    971          *                                         +--------------+--------------+--------------+--------------+--------------+
    972          *              p_tcb->PendDataTblPtr  ->  |  Obj A       |  0           | 0            | 0            | 0            |
    973          *                                         +--------------+--------------+--------------+--------------+--------------+
    974          *                                         |  Obj B       |  0           | 0            | 0            | 0            |
    975          *                                         +--------------+--------------+--------------+--------------+--------------+
    976          *                                         |  Obj C       |  Obj C       | 0            | 0            | TS           |
    977          *                                         +--------------+--------------+--------------+--------------+--------------+
    978          *                                         |  Obj D       |  0           | 0            | 0            | 0            |
    979          *                                         +--------------+--------------+--------------+--------------+--------------+
    980          *                                         |  Obj E       |  0           | 0            | 0            | 0            |
    981          *                                         +--------------+--------------+--------------+--------------+--------------+
    982          *                                         |  Obj F       |  0           | 0            | 0            | 0            |
    983          *                                         +--------------+--------------+--------------+--------------+--------------+
    984          *
    985          *
    986          * Arguments  : p_obj        is a pointer to the object being pend aborted to
    987          *              -----
    988          *
    989          *              p_tcb        is a pointer to the OS_TCB of the task that we'll abort he pend for
    990          *              -----
    991          *
    992          *              ts           is the time stamp of when the pend abort occurred
    993          *
    994          * Returns    : none
    995          *
    996          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    997          ************************************************************************************************************************
    998          */
    999          

   \                                 In  segment CODE, align 1, keep-with-next
   1000          void  OS_PendAbort1 (OS_PEND_OBJ  *p_obj,
   \                     OS_PendAbort1:
   1001                               OS_TCB       *p_tcb,
   1002                               CPU_TS        ts)
   1003          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 4
   \   000000 C5                    PUSH      DE                 ;; 1 cycle
   \   000001 C1                    PUSH      AX                 ;; 1 cycle
   \   000002 C3                    PUSH      BC                 ;; 1 cycle
   \   000003                       ; Auto size: 4
   1004              OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
   1005              OS_PEND_DATA   *p_pend_data;
   1006          
   1007          
   1008          
   1009              p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
   \   000003 C3                    PUSH      BC                 ;; 1 cycle
   \   000004 C6                    POP       HL                 ;; 1 cycle
   \   000005 AC18                  MOVW      AX, [HL+0x18]      ;; 1 cycle
   \   000007 14                    MOVW      DE, AX             ;; 1 cycle
   1010              n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */
   \   000008 C3                    PUSH      BC                 ;; 1 cycle
   \   000009 C6                    POP       HL                 ;; 1 cycle
   \   00000A AC22                  MOVW      AX, [HL+0x22]      ;; 1 cycle
   \   00000C 16                    MOVW      HL, AX             ;; 1 cycle
   \   00000D EF03                  BR        S:??CrossCallReturnLabel_11  ;; 3 cycles
   \   00000F                       ; ------------------------------------- Block: 14 cycles
   1011          
   1012              while (n_pend_list > (OS_OBJ_QTY)0) {                           /* Mark posted object in OS_PEND_DATA table       */
   1013                  if (p_obj == p_pend_data->PendObjPtr) {                     /* Did we find the object pend aborted?           */
   1014                      p_pend_data->RdyObjPtr = p_obj;                         /* Yes, indicate the object in the .RdyObjPtr     */
   1015                      p_pend_data->RdyTS     = ts;                            /*      save the timestamp of the pend abort      */
   1016                      break;
   1017                  }
   1018                  p_pend_data++;
   \                     ??OS_PendAbort1_0:
   \   00000F FD....                CALL      N:?Subroutine9     ;; 3 cycles
   1019                  n_pend_list--;
   \   000012                       ; ------------------------------------- Block: 3 cycles
   \                     ??CrossCallReturnLabel_11:
   \   000012 17                    MOVW      AX, HL             ;; 1 cycle
   \   000013 F7                    CLRW      BC                 ;; 1 cycle
   \   000014 43                    CMPW      AX, BC             ;; 1 cycle
   \   000015 DD14                  BZ        ??OS_TaskRdy_25    ;; 4 cycles
   \   000017                       ; ------------------------------------- Block: 7 cycles
   \   000017 AA06                  MOVW      AX, [DE+0x06]      ;; 1 cycle
   \   000019 12                    MOVW      BC, AX             ;; 1 cycle
   \   00001A A802                  MOVW      AX, [SP+0x02]      ;; 1 cycle
   \   00001C 43                    CMPW      AX, BC             ;; 1 cycle
   \   00001D DFF0                  BNZ       ??OS_PendAbort1_0  ;; 4 cycles
   \   00001F                       ; ------------------------------------- Block: 8 cycles
   \   00001F BA08                  MOVW      [DE+0x08], AX      ;; 1 cycle
   \   000021 A80C                  MOVW      AX, [SP+0x0C]      ;; 1 cycle
   \   000023 12                    MOVW      BC, AX             ;; 1 cycle
   \   000024 A80A                  MOVW      AX, [SP+0x0A]      ;; 1 cycle
   \   000026 BA0E                  MOVW      [DE+0x0E], AX      ;; 1 cycle
   \   000028 13                    MOVW      AX, BC             ;; 1 cycle
   \   000029 BA10                  MOVW      [DE+0x10], AX      ;; 1 cycle
   \   00002B                       ; ------------------------------------- Block: 7 cycles
   1020              }
   1021          }
   \                     ??OS_TaskRdy_25:
   \   00002B ED....                BR        N:?Subroutine3     ;; 3 cycles
   \   00002E                       ; ------------------------------------- Block: 3 cycles
   \   00002E                       ; ------------------------------------- Total: 42 cycles
   \   00002E                       REQUIRE ?CLRL78_V1_0_L00

   \                                 In  segment CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000 15                    MOVW      AX, DE             ;; 1 cycle
   \   000001 041200                ADDW      AX, #0x12          ;; 1 cycle
   \   000004 14                    MOVW      DE, AX             ;; 1 cycle
   \   000005 B7                    DECW      HL                 ;; 1 cycle
   \   000006 D7                    RET                          ;; 6 cycles
   \   000007                       ; ------------------------------------- Block: 10 cycles
   \   000007                       ; ------------------------------------- Total: 10 cycles
   \   000007                       REQUIRE ?CLRL78_V1_0_L00
   1022          
   1023          /*$PAGE*/
   1024          /*
   1025          ************************************************************************************************************************
   1026          *                                              INITIALIZE A WAIT LIST TABLE
   1027          *
   1028          * Description: This function is called to initialize the fields of a table of OS_PEND_DATA entries.  It's assumed that
   1029          *              the .PendObjPtr field of each entry in the table is set by the caller and thus will NOT be touched by
   1030          *              this function.
   1031          *
   1032          * Arguments  : p_tcb              is a pointer to the TCB of the task that we want to pend abort.
   1033          *              -----
   1034          *
   1035          *              p_pend_data_tbl    is a pointer to a table (see below) of OS_PEND_DATA elements to initialize.
   1036          *              ---------------
   1037          *
   1038          *                                  .PendObjPtr .RdyObjPtr .RdyMsgPtr .RdyMsgSize .RdyTS .TCBPtr .NextPtr .PrevPtr
   1039          *                                 +-----------+----------+----------+-----------+------+-------+--------+--------+    ^
   1040          *               p_pend_data_tbl-> |     ?     |  0       | 0        | 0         | 0    | p_tcb | 0      | 0      |    |
   1041          *                                 +-----------+----------+----------+-----------+------+-------+--------+--------+    |
   1042          *                                 |     ?     |  0       | 0        | 0         | 0    | p_tcb | 0      | 0      |    |
   1043          *                                 +-----------+----------+----------+-----------+------+-------+--------+--------+    |
   1044          *                                 |     ?     |  0       | 0        | 0         | 0    | p_tcb | 0      | 0      |    |
   1045          *                                 +-----------+----------+----------+-----------+------+-------+--------+--------+  size
   1046          *                                 |     ?     |  0       | 0        | 0         | 0    | p_tcb | 0      | 0      |    |
   1047          *                                 +-----------+----------+----------+-----------+------+-------+--------+--------+    |
   1048          *                                 |     ?     |  0       | 0        | 0         | 0    | p_tcb | 0      | 0      |    |
   1049          *                                 +-----------+----------+----------+-----------+------+-------+--------+--------+    |
   1050          *                                 |     ?     |  0       | 0        | 0         | 0    | p_tcb | 0      | 0      |    |
   1051          *                                 +-----------+----------+----------+-----------+------+-------+--------+--------+    V
   1052          *
   1053          *              tbl_size           is the size of the table in number of entries
   1054          *
   1055          * Returns    : none
   1056          *
   1057          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application must not call it.
   1058          *
   1059          *              2) It's possible for the table to be of size 1 when multi-pend is not used
   1060          *
   1061          *              3) Note that the .PendObjPtr is NOT touched because it's assumed to be set by the caller.
   1062          ************************************************************************************************************************
   1063          */
   1064          

   \                                 In  segment CODE, align 1, keep-with-next
   1065          void  OS_PendDataInit (OS_TCB        *p_tcb,
   \                     OS_PendDataInit:
   1066                                 OS_PEND_DATA  *p_pend_data_tbl,
   1067                                 OS_OBJ_QTY     tbl_size)
   1068          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000 C1                    PUSH      AX                 ;; 1 cycle
   \   000001                       ; Auto size: 2
   \   000001 C3                    PUSH      BC                 ;; 1 cycle
   \   000002 C6                    POP       HL                 ;; 1 cycle
   \   000003 C5                    PUSH      DE                 ;; 1 cycle
   \   000004 C2                    POP       BC                 ;; 1 cycle
   1069              OS_OBJ_QTY  i;
   1070          
   1071          
   1072          
   1073              p_tcb->PendDataTblEntries = tbl_size;                   /* Link the TCB to the beginning of the table             */
   \   000005 14                    MOVW      DE, AX             ;; 1 cycle
   \   000006 13                    MOVW      AX, BC             ;; 1 cycle
   \   000007 BA22                  MOVW      [DE+0x22], AX      ;; 1 cycle
   1074              p_tcb->PendDataTblPtr     = p_pend_data_tbl;
   \   000009 17                    MOVW      AX, HL             ;; 1 cycle
   \   00000A BA18                  MOVW      [DE+0x18], AX      ;; 1 cycle
   1075          
   1076              for (i = 0u; i < tbl_size; i++) {
   \   00000C F6                    CLRW      AX                 ;; 1 cycle
   \   00000D 14                    MOVW      DE, AX             ;; 1 cycle
   \   00000E EF18                  BR        S:??OS_TaskRdy_26  ;; 3 cycles
   \   000010                       ; ------------------------------------- Block: 15 cycles
   1077                  p_pend_data_tbl->NextPtr    = (OS_PEND_DATA *)0;    /* Initialize all the fields                              */
   \                     ??OS_PendDataInit_0:
   \   000010 F6                    CLRW      AX                 ;; 1 cycle
   \   000011 BC02                  MOVW      [HL+0x02], AX      ;; 1 cycle
   1078                  p_pend_data_tbl->PrevPtr    = (OS_PEND_DATA *)0;
   \   000013 BB                    MOVW      [HL], AX           ;; 1 cycle
   1079                  p_pend_data_tbl->RdyObjPtr  = (void         *)0;
   \   000014 BC08                  MOVW      [HL+0x08], AX      ;; 1 cycle
   1080                  p_pend_data_tbl->RdyMsgPtr  = (void         *)0;
   \   000016 BC0A                  MOVW      [HL+0x0A], AX      ;; 1 cycle
   1081                  p_pend_data_tbl->RdyMsgSize = (OS_MSG_SIZE   )0;
   \   000018 BC0C                  MOVW      [HL+0x0C], AX      ;; 1 cycle
   1082                  p_pend_data_tbl->RdyTS      = (CPU_TS        )0;
   \   00001A BC0E                  MOVW      [HL+0x0E], AX      ;; 1 cycle
   \   00001C BC10                  MOVW      [HL+0x10], AX      ;; 1 cycle
   1083                  p_pend_data_tbl->TCBPtr     = p_tcb;                /* Every entry points back to the TCB of the task         */
   \   00001E A800                  MOVW      AX, [SP]           ;; 1 cycle
   \   000020 BC04                  MOVW      [HL+0x04], AX      ;; 1 cycle
   1084                  p_pend_data_tbl++;
   \   000022 17                    MOVW      AX, HL             ;; 1 cycle
   \   000023 041200                ADDW      AX, #0x12          ;; 1 cycle
   \   000026 16                    MOVW      HL, AX             ;; 1 cycle
   1085              }
   \   000027 A5                    INCW      DE                 ;; 1 cycle
   \   000028                       ; ------------------------------------- Block: 14 cycles
   \                     ??OS_TaskRdy_26:
   \   000028 15                    MOVW      AX, DE             ;; 1 cycle
   \   000029 43                    CMPW      AX, BC             ;; 1 cycle
   \   00002A DCE4                  BC        ??OS_PendDataInit_0  ;; 4 cycles
   \   00002C                       ; ------------------------------------- Block: 6 cycles
   1086          }
   \   00002C 1002                  ADDW      SP, #0x2           ;; 1 cycle
   \   00002E D7                    RET                          ;; 6 cycles
   \   00002F                       ; ------------------------------------- Block: 7 cycles
   \   00002F                       ; ------------------------------------- Total: 42 cycles
   \   00002F                       REQUIRE ?CLRL78_V1_0_L00
   1087          
   1088          /*$PAGE*/
   1089          /*
   1090          ************************************************************************************************************************
   1091          *                                     ADD/REMOVE DEBUG NAMES TO PENDED OBJECT AND OS_TCB
   1092          *
   1093          * Description: These functions are used to add pointers to ASCII 'names' of objects so they can easily be displayed
   1094          *              using a kernel aware tool.
   1095          *
   1096          * Arguments  : p_obj              is a pointer to the object being pended on
   1097          *
   1098          *              p_tcb              is a pointer to the OS_TCB of the task pending on the object
   1099          *
   1100          * Returns    : none
   1101          *
   1102          * Note(s)    : 1) These functions are INTERNAL to uC/OS-III and your application must not call it.
   1103          ************************************************************************************************************************
   1104          */
   1105          
   1106          
   1107          #if OS_CFG_DBG_EN > 0u
   1108          void  OS_PendDbgNameAdd (OS_PEND_OBJ  *p_obj,
   1109                                   OS_TCB       *p_tcb)
   1110          {
   1111              OS_PEND_LIST  *p_pend_list;
   1112              OS_PEND_DATA  *p_pend_data;
   1113              OS_TCB        *p_tcb1;
   1114          
   1115          
   1116              if (p_obj != (OS_PEND_OBJ *)0) {
   1117                  p_tcb->DbgNamePtr =  p_obj->NamePtr;                /* Task pending on this object ... save name in TCB       */
   1118                  p_pend_list       = &p_obj->PendList;               /* Find name of HP task pending on this object ...        */
   1119                  p_pend_data       =  p_pend_list->HeadPtr;
   1120                  p_tcb1            =  p_pend_data->TCBPtr;
   1121                  p_obj->DbgNamePtr = p_tcb1->NamePtr;                /* ... Save in object                                     */
   1122              } else {
   1123                  switch (p_tcb->PendOn) {
   1124                      case OS_TASK_PEND_ON_TASK_Q:
   1125                           p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)"Task Q");
   1126                           break;
   1127          
   1128                      case OS_TASK_PEND_ON_TASK_SEM:
   1129                           p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)"Task Sem");
   1130                           break;
   1131          
   1132                      default:
   1133                           p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)" ");
   1134                           break;
   1135                  }
   1136              }
   1137          }
   1138          
   1139          
   1140          
   1141          void  OS_PendDbgNameRemove (OS_PEND_OBJ  *p_obj,
   1142                                      OS_TCB       *p_tcb)
   1143          {
   1144              OS_PEND_LIST  *p_pend_list;
   1145              OS_PEND_DATA  *p_pend_data;
   1146              OS_TCB        *p_tcb1;
   1147          
   1148          
   1149              p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)" ");          /* Remove name of object pended on for readied task       */
   1150              p_pend_list       = &p_obj->PendList;
   1151              p_pend_data       =  p_pend_list->HeadPtr;
   1152              if (p_pend_data  != (OS_PEND_DATA *)0) {
   1153                  p_tcb1            = p_pend_data->TCBPtr;
   1154                  p_obj->DbgNamePtr = p_tcb1->NamePtr;
   1155              } else {
   1156                  p_obj->DbgNamePtr = (CPU_CHAR *)((void *)" ");      /* No other task pending on object                        */
   1157              }
   1158          }
   1159          #endif
   1160          
   1161          /*$PAGE*/
   1162          /*
   1163          ************************************************************************************************************************
   1164          *                               CHANGE THE PRIORITY OF A TASK WAITING IN ONE OR MORE PEND LISTS
   1165          *
   1166          * Description: This function is called to change the position of a task waiting in one or more pend lists.  Because a
   1167          *              task can be waiting on multiple objects then each pend list needs to be updated.  Specifically, the
   1168          *              task can be the highest priority task waiting on one pend list, the lowest priority task waiting in yet
   1169          *              another pend list or somewhere else in another pend list.  Because of this, we need to be able to change
   1170          *              each of those pend lists individually.
   1171          *
   1172          *              The drawing below shows an example of a task (OS_TCB) that belongs to 3 separate pend lists.  Each
   1173          *              pend list can contain multiple tasks (the .PrevPtr and .NextPtr show a '?' to indicate this).  The OS_TCB
   1174          *              contains a pointer (.PendDataTblPtr) to the first entry in the list of pend lists.
   1175          *
   1176          *                                                                                                          OS_TCB
   1177          *                                                                                                   +--------------------+
   1178          *                                                                                                   |                    |
   1179          *                                                                                                   +--------------------+
   1180          *                                                                                                   | PendDataTblEntries |
   1181          *                                      Point to first entry in the OS_PEND_DATA table (i.e. [0])    +--------------------+
   1182          *                                          /-----------------------------<------------------------- | PendDataTblPtr     |
   1183          *                                          |                                                        +--------------------+
   1184          *                                          |                                                                 ^
   1185          *              OS_PEND_LIST                |                                                                 |
   1186          *              +------------+              |                                                                 |
   1187          *              | TailPtr    |              |                                                                 |
   1188          *              +------------+              |                                                                 |
   1189          *              | HeadPtr    |              |                                                                 |
   1190          *              +------------+              |                                        /---------->-------------/
   1191          *              | NbrEntries |              |                                        |                        |
   1192          *              +------------+     [0]      V   OS_PEND_DATA                         |                        |
   1193          *                                     +---------+------------+-------+---------+--------+---------+          |
   1194          *                             ? <---- | PrevPtr | PendObjPtr |       |         | TCBPtr | NextPtr | --> ?    |
   1195          *                                     +---------+------------+-------+---------+--------+---------+          |
   1196          *                                                                                                            |
   1197          *                                                                                                            |
   1198          *                                                                                                            |
   1199          *                                                                                                            |
   1200          *                                                                                                            |
   1201          *              OS_PEND_LIST                                                                Point back to TCB |
   1202          *              +------------+                                                                                |
   1203          *              | TailPtr    |                                                                                |
   1204          *              +------------+                                                                                |
   1205          *              | HeadPtr    |                                                                                |
   1206          *              +------------+                                                      /----------->-------------/
   1207          *              | NbrEntries |                                                      |                         |
   1208          *              +------------+     [1]          OS_PEND_DATA                        |                         |
   1209          *                                     +---------+------------+-------+---------+--------+---------+          |
   1210          *                             ? <---- | PrevPtr | PendObjPtr |       |         | TCBPtr | NextPtr | --> ?    |
   1211          *                                     +---------+------------+-------+---------+--------+---------+          |
   1212          *                                                                                                            |
   1213          *                                                                                                            |
   1214          *                                                                                                            |
   1215          *                                                                                                            |
   1216          *                                                                                                            |
   1217          *              OS_PEND_LIST                                                                                  |
   1218          *              +------------+                                                                                |
   1219          *              | TailPtr    |                                                                                |
   1220          *              +------------+                                                                                |
   1221          *              | HeadPtr    |                                                                                |
   1222          *              +------------+                                                      /----------->-------------/
   1223          *              | NbrEntries |                                                      |
   1224          *              +------------+     [2]          OS_PEND_DATA                        |
   1225          *                                     +---------+------------+-------+---------+--------+---------+
   1226          *                             ? <---- | PrevPtr | PendObjPtr |       |         | TCBPtr | NextPtr | ----> ?
   1227          *                                     +---------+------------+-------+---------+--------+---------+
   1228          *
   1229          *
   1230          * Arguments  : p_tcb       is a pointer to the TCB of the task to move
   1231          *              -----
   1232          *
   1233          *              prio_new    is the new priority for the task
   1234          *
   1235          * Returns    : none
   1236          *
   1237          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1238          *
   1239          *              2) It's assumed that the TCB contains the NEW priority in its .Prio field.
   1240          ************************************************************************************************************************
   1241          */
   1242          

   \                                 In  segment CODE, align 1, keep-with-next
   1243          void  OS_PendListChangePrio (OS_TCB  *p_tcb,
   \                     OS_PendListChangePrio:
   1244                                       OS_PRIO  prio_new)
   1245          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000 C3                    PUSH      BC                 ;; 1 cycle
   \   000001 C5                    PUSH      DE                 ;; 1 cycle
   \   000002                       ; Auto size: 4
   \   000002 2004                  SUBW      SP, #0x4           ;; 1 cycle
   \   000004 16                    MOVW      HL, AX             ;; 1 cycle
   1246              OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
   1247              OS_PEND_DATA   *p_pend_data;
   1248              OS_PEND_LIST   *p_pend_list;
   1249              OS_PEND_OBJ    *p_obj;
   1250          
   1251          
   1252              p_tcb->Prio = prio_new;
   \   000005 63                    MOV       A, B               ;; 1 cycle
   \   000006 9C1D                  MOV       [HL+0x1D], A       ;; 1 cycle
   1253              p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to first wait list entry                 */
   \   000008 AC18                  MOVW      AX, [HL+0x18]      ;; 1 cycle
   \   00000A 14                    MOVW      DE, AX             ;; 1 cycle
   1254              n_pend_list = p_tcb->PendDataTblEntries;                        /* Get the number of pend list task is in         */
   \   00000B AC22                  MOVW      AX, [HL+0x22]      ;; 1 cycle
   \   00000D EF24                  BR        S:??OS_TaskRdy_27  ;; 3 cycles
   \   00000F                       ; ------------------------------------- Block: 12 cycles
   1255          
   1256              while (n_pend_list > 0u) {
   1257                  p_obj       =  p_pend_data->PendObjPtr;                     /* Get pointer to pend list                       */
   1258                  p_pend_list = &p_obj->PendList;
   \                     ??OS_PendListChangePrio_0:
   \   00000F AA06                  MOVW      AX, [DE+0x06]      ;; 1 cycle
   \   000011 040600                ADDW      AX, #0x6           ;; 1 cycle
   \   000014 B800                  MOVW      [SP], AX           ;; 1 cycle
   1259                  if (p_pend_list->NbrEntries > 1u) {                         /* Only move if multiple entries in the list      */
   \   000016 16                    MOVW      HL, AX             ;; 1 cycle
   \   000017 AC04                  MOVW      AX, [HL+0x04]      ;; 1 cycle
   \   000019 440200                CMPW      AX, #0x2           ;; 1 cycle
   \   00001C DC0D                  BC        ??OS_TaskRdy_28    ;; 4 cycles
   \   00001E                       ; ------------------------------------- Block: 10 cycles
   1260                      OS_PendListRemove1(p_pend_list,                         /* Remove entry from current position             */
   1261                                         p_pend_data);
   \   00001E C5                    PUSH      DE                 ;; 1 cycle
   \   00001F C2                    POP       BC                 ;; 1 cycle
   \   000020 17                    MOVW      AX, HL             ;; 1 cycle
   \   000021 FD....                CALL      OS_PendListRemove1  ;; 3 cycles
   1262                      OS_PendListInsertPrio(p_pend_list,                      /* INSERT it back in the list                     */
   1263                                            p_pend_data);
   \   000024 C5                    PUSH      DE                 ;; 1 cycle
   \   000025 C2                    POP       BC                 ;; 1 cycle
   \   000026 A800                  MOVW      AX, [SP]           ;; 1 cycle
   \   000028 FD....                CALL      OS_PendListInsertPrio  ;; 3 cycles
   \   00002B                       ; ------------------------------------- Block: 12 cycles
   1264                  }
   1265                  p_pend_data++;                                              /* Point to next wait list                        */
   \                     ??OS_TaskRdy_28:
   \   00002B 15                    MOVW      AX, DE             ;; 1 cycle
   \   00002C 041200                ADDW      AX, #0x12          ;; 1 cycle
   \   00002F 14                    MOVW      DE, AX             ;; 1 cycle
   1266                  n_pend_list--;
   \   000030 A802                  MOVW      AX, [SP+0x02]      ;; 1 cycle
   \   000032 B1                    DECW      AX                 ;; 1 cycle
   \   000033                       ; ------------------------------------- Block: 5 cycles
   \                     ??OS_TaskRdy_27:
   \   000033 B802                  MOVW      [SP+0x02], AX      ;; 1 cycle
   1267              }
   \   000035 F7                    CLRW      BC                 ;; 1 cycle
   \   000036 43                    CMPW      AX, BC             ;; 1 cycle
   \   000037 DFD6                  BNZ       ??OS_PendListChangePrio_0  ;; 4 cycles
   \   000039                       ; ------------------------------------- Block: 7 cycles
   1268          }
   \   000039 ED....                BR        N:?Subroutine0     ;; 3 cycles
   \   00003C                       ; ------------------------------------- Block: 3 cycles
   \   00003C                       ; ------------------------------------- Total: 49 cycles
   \   00003C                       REQUIRE ?CLRL78_V1_0_L00
   1269          
   1270          /*$PAGE*/
   1271          /*
   1272          ************************************************************************************************************************
   1273          *                                                INITIALIZE A WAIT LIST
   1274          *
   1275          * Description: This function is called to initialize the fields of an OS_PEND_LIST.
   1276          *
   1277          * Arguments  : p_pend_list   is a pointer to an OS_PEND_LIST
   1278          *              -----------
   1279          *
   1280          * Returns    : none
   1281          *
   1282          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application must not call it.
   1283          ************************************************************************************************************************
   1284          */
   1285          

   \                                 In  segment CODE, align 1, keep-with-next
   1286          void  OS_PendListInit (OS_PEND_LIST  *p_pend_list)
   \                     OS_PendListInit:
   1287          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000                       ; Auto size: 0
   \   000000 16                    MOVW      HL, AX             ;; 1 cycle
   1288              p_pend_list->HeadPtr    = (OS_PEND_DATA *)0;
   \   000001 F6                    CLRW      AX                 ;; 1 cycle
   \   000002 BB                    MOVW      [HL], AX           ;; 1 cycle
   1289              p_pend_list->TailPtr    = (OS_PEND_DATA *)0;
   \   000003 BC02                  MOVW      [HL+0x02], AX      ;; 1 cycle
   1290              p_pend_list->NbrEntries = (OS_OBJ_QTY    )0;
   \   000005 BC04                  MOVW      [HL+0x04], AX      ;; 1 cycle
   1291          }
   \   000007 D7                    RET                          ;; 6 cycles
   \   000008                       ; ------------------------------------- Block: 11 cycles
   \   000008                       ; ------------------------------------- Total: 11 cycles
   \   000008                       REQUIRE ?CLRL78_V1_0_L00
   1292          
   1293          /*$PAGE*/
   1294          /*
   1295          ************************************************************************************************************************
   1296          *                                     INSERT PEND DATA AT THE BEGINNING OF A WAIT LIST
   1297          *
   1298          * Description: This function is called to place an OS_PEND_DATA entry at the beginning of a linked list as follows:
   1299          *
   1300          *              CASE 0: Insert in an empty list.
   1301          *
   1302          *                     OS_PEND_LIST
   1303          *                     +--------------+
   1304          *                     | TailPtr      |-> 0
   1305          *                     +--------------+
   1306          *                     | HeadPtr      |-> 0
   1307          *                     +--------------+
   1308          *                     | NbrEntries=0 |
   1309          *                     +--------------+
   1310          *
   1311          *
   1312          *
   1313          *              CASE 1: Insert BEFORE the current head of list
   1314          *
   1315          *                     OS_PEND_LIST
   1316          *                     +--------------+         OS_PEND_DATA
   1317          *                     | TailPtr      |--+---> +------------+
   1318          *                     +--------------+  |     | NextPtr    |->0
   1319          *                     | HeadPtr      |--/     +------------+
   1320          *                     +--------------+     0<-| PrevPtr    |
   1321          *                     | NbrEntries=1 |        +------------+
   1322          *                     +--------------+        |            |
   1323          *                                             +------------+
   1324          *                                             |            |
   1325          *                                             +------------+
   1326          *
   1327          *
   1328          * Arguments  : p_pend_list    is a pointer to a wait list found inside an object.  The OS_PEND_DATA entry will be
   1329          *              -----------    inserted at the head of the list.
   1330          *
   1331          *              p_pend_data    is a pointer to the OS_PEND_DATA entry to add to the list
   1332          *              -----------
   1333          *
   1334          * Returns    : none
   1335          *
   1336          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1337          ************************************************************************************************************************
   1338          */
   1339          

   \                                 In  segment CODE, align 1, keep-with-next
   1340          void  OS_PendListInsertHead (OS_PEND_LIST  *p_pend_list,
   \                     OS_PendListInsertHead:
   1341                                       OS_PEND_DATA  *p_pend_data)
   1342          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000 C5                    PUSH      DE                 ;; 1 cycle
   \   000001 C3                    PUSH      BC                 ;; 1 cycle
   \   000002                       ; Auto size: 4
   \   000002 C1                    PUSH      AX                 ;; 1 cycle
   \   000003 16                    MOVW      HL, AX             ;; 1 cycle
   1343              OS_PEND_DATA  *p_pend_data_next;
   1344          
   1345          
   1346          
   1347              p_pend_list->NbrEntries++;                              /* One more entry in the list                             */
   \   000004 AC04                  MOVW      AX, [HL+0x04]      ;; 1 cycle
   \   000006 A1                    INCW      AX                 ;; 1 cycle
   \   000007 BC04                  MOVW      [HL+0x04], AX      ;; 1 cycle
   1348              p_pend_data->NextPtr  = p_pend_list->HeadPtr;           /* Adjust new entry's links                               */
   \   000009 AB                    MOVW      AX, [HL]           ;; 1 cycle
   \   00000A 12                    MOVW      BC, AX             ;; 1 cycle
   \   00000B A802                  MOVW      AX, [SP+0x02]      ;; 1 cycle
   \   00000D 14                    MOVW      DE, AX             ;; 1 cycle
   \   00000E 33                    XCHW      AX, BC             ;; 1 cycle
   \   00000F BA02                  MOVW      [DE+0x02], AX      ;; 1 cycle
   1349              p_pend_data->PrevPtr  = (OS_PEND_DATA  *)0;
   \   000011 F6                    CLRW      AX                 ;; 1 cycle
   \   000012 B9                    MOVW      [DE], AX           ;; 1 cycle
   1350              p_pend_data_next      = p_pend_list->HeadPtr;           /* Adjust old head of list's links                        */
   \   000013 AB                    MOVW      AX, [HL]           ;; 1 cycle
   \   000014 B800                  MOVW      [SP], AX           ;; 1 cycle
   1351              if (p_pend_data_next != (OS_PEND_DATA *)0) {            /* See if we already have a head to replace               */
   \   000016 440000                CMPW      AX, #0x0           ;; 1 cycle
   \   000019 DD03                  BZ        ??OS_TaskRdy_29    ;; 4 cycles
   \   00001B                       ; ------------------------------------- Block: 22 cycles
   1352                  p_pend_data_next->PrevPtr = p_pend_data;            /* Yes, point to new entry                                */
   \   00001B 14                    MOVW      DE, AX             ;; 1 cycle
   \   00001C 13                    MOVW      AX, BC             ;; 1 cycle
   \   00001D B9                    MOVW      [DE], AX           ;; 1 cycle
   \   00001E                       ; ------------------------------------- Block: 3 cycles
   1353              }
   1354              p_pend_list->HeadPtr = p_pend_data;                     /* We have a new list head                                */
   \                     ??OS_TaskRdy_29:
   \   00001E 13                    MOVW      AX, BC             ;; 1 cycle
   \   00001F BB                    MOVW      [HL], AX           ;; 1 cycle
   1355              if (p_pend_list->NbrEntries == 1u) {
   \   000020 AC04                  MOVW      AX, [HL+0x04]      ;; 1 cycle
   \   000022 E7                    ONEW      BC                 ;; 1 cycle
   \   000023 43                    CMPW      AX, BC             ;; 1 cycle
   \   000024 DF04                  BNZ       ??OS_TaskRdy_30    ;; 4 cycles
   \   000026                       ; ------------------------------------- Block: 9 cycles
   1356                  p_pend_list->TailPtr = p_pend_data;
   \   000026 A802                  MOVW      AX, [SP+0x02]      ;; 1 cycle
   \   000028 BC02                  MOVW      [HL+0x02], AX      ;; 1 cycle
   \   00002A                       ; ------------------------------------- Block: 2 cycles
   1357              }
   1358          }
   \                     ??OS_TaskRdy_30:
   \   00002A 1004                  ADDW      SP, #0x4           ;; 1 cycle
   \   00002C C4                    POP       DE                 ;; 1 cycle
   \   00002D D7                    RET                          ;; 6 cycles
   \   00002E                       ; ------------------------------------- Block: 8 cycles
   \   00002E                       ; ------------------------------------- Total: 44 cycles
   \   00002E                       REQUIRE ?CLRL78_V1_0_L00
   1359          
   1360          /*$PAGE*/
   1361          /*
   1362          ************************************************************************************************************************
   1363          *                                   INSERT PEND DATA BASED ON IT'S PRIORITY IN A LIST
   1364          *
   1365          * Description: This function is called to place an OS_PEND_DATA entry in a linked list based on its priority.  The
   1366          *              highest priority being placed at the head of the list.  It's assumed that the OS_PEND_DATA entry to
   1367          *              insert points to the TCB of the task being inserted.  The TCB is also assumed to contain the priority
   1368          *              of the task in its .Prio field.
   1369          *
   1370          *              CASE 0: Insert in an empty list.
   1371          *
   1372          *                     OS_PEND_LIST
   1373          *                     +---------------+
   1374          *                     | TailPtr       |-> 0
   1375          *                     +---------------+
   1376          *                     | HeadPtr       |-> 0
   1377          *                     +---------------+
   1378          *                     | NbrEntries=0  |
   1379          *                     +---------------+
   1380          *
   1381          *
   1382          *
   1383          *              CASE 1: Insert BEFORE or AFTER an OS_TCB
   1384          *
   1385          *                     OS_PEND_LIST
   1386          *                     +--------------+         OS_PEND_DATA
   1387          *                     | TailPtr      |--+---> +------------+
   1388          *                     +--------------+  |     | NextPtr    |->0
   1389          *                     | HeadPtr      |--/     +------------+
   1390          *                     +--------------+     0<-| PrevPtr    |
   1391          *                     | NbrEntries=1 |        +------------+
   1392          *                     +--------------+        |            |
   1393          *                                             +------------+
   1394          *                                             |            |
   1395          *                                             +------------+
   1396          *
   1397          *
   1398          *                     OS_PEND_LIST
   1399          *                     +--------------+
   1400          *                     | TailPtr      |-----------------------------------------------+
   1401          *                     +--------------+         OS_PEND_DATA         OS_PEND_DATA     |    OS_PEND_DATA
   1402          *                     | HeadPtr      |------> +------------+       +------------+    +-> +------------+
   1403          *                     +--------------+        | NextPtr    |------>| NextPtr    | ...... | NextPtr    |->0
   1404          *                     | NbrEntries=N |        +------------+       +------------+        +------------+
   1405          *                     +--------------+     0<-| PrevPtr    |<------| PrevPtr    | ...... | PrevPtr    |
   1406          *                                             +------------+       +------------+        +------------+
   1407          *                                             |            |       |            |        |            |
   1408          *                                             +------------+       +------------+        +------------+
   1409          *                                             |            |       |            |        |            |
   1410          *                                             +------------+       +------------+        +------------+
   1411          *
   1412          *
   1413          * Arguments  : p_pend_list    is a pointer to the OS_PEND_LIST where the OS_PEND_DATA entry will be inserted
   1414          *              -----------
   1415          *
   1416          *              p_pend_data    is the OS_PEND_DATA to insert in the list
   1417          *              -----------
   1418          *
   1419          * Returns    : none
   1420          *
   1421          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1422          *
   1423          *              2) 'p_pend_data->TCBPtr->Prio' contains the priority of the TCB associated with the entry to insert.
   1424          *                 We can compare this priority with the priority of other entries in the list.
   1425          ************************************************************************************************************************
   1426          */
   1427          

   \                                 In  segment CODE, align 1, keep-with-next
   1428          void  OS_PendListInsertPrio (OS_PEND_LIST  *p_pend_list,
   \                     OS_PendListInsertPrio:
   1429                                       OS_PEND_DATA  *p_pend_data)
   1430          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000 C5                    PUSH      DE                 ;; 1 cycle
   \   000001 C1                    PUSH      AX                 ;; 1 cycle
   \   000002 C3                    PUSH      BC                 ;; 1 cycle
   \   000003                       ; Auto size: 8
   \   000003 2004                  SUBW      SP, #0x4           ;; 1 cycle
   1431              OS_PRIO        prio;
   1432              OS_TCB        *p_tcb;
   1433              OS_TCB        *p_tcb_next;
   1434              OS_PEND_DATA  *p_pend_data_prev;
   1435              OS_PEND_DATA  *p_pend_data_next;
   1436          
   1437          
   1438          
   1439              p_tcb = p_pend_data->TCBPtr;                                      /* Obtain the priority of the task to insert    */
   1440              prio  = p_tcb->Prio;
   \   000005 C3                    PUSH      BC                 ;; 1 cycle
   \   000006 C6                    POP       HL                 ;; 1 cycle
   \   000007 AC04                  MOVW      AX, [HL+0x04]      ;; 1 cycle
   \   000009 16                    MOVW      HL, AX             ;; 1 cycle
   \   00000A 8C1D                  MOV       A, [HL+0x1D]       ;; 1 cycle
   \   00000C 73                    MOV       B, A               ;; 1 cycle
   1441              if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0) {                   /* CASE 0: Insert when there are no entries     */
   \   00000D A806                  MOVW      AX, [SP+0x06]      ;; 1 cycle
   \   00000F 16                    MOVW      HL, AX             ;; 1 cycle
   \   000010 A7                    INCW      HL                 ;; 1 cycle
   \   000011 A7                    INCW      HL                 ;; 1 cycle
   \   000012 A7                    INCW      HL                 ;; 1 cycle
   \   000013 A7                    INCW      HL                 ;; 1 cycle
   \   000014 AB                    MOVW      AX, [HL]           ;; 1 cycle
   \   000015 440000                CMPW      AX, #0x0           ;; 1 cycle
   \   000018 DF10                  BNZ       ??OS_TaskRdy_31    ;; 4 cycles
   \   00001A                       ; ------------------------------------- Block: 22 cycles
   1442                  p_pend_list->NbrEntries = (OS_OBJ_QTY)1;                      /*         This is the first entry              */
   \   00001A E6                    ONEW      AX                 ;; 1 cycle
   \   00001B BB                    MOVW      [HL], AX           ;; 1 cycle
   1443                  p_pend_data->NextPtr    = (OS_PEND_DATA *)0;                  /*         No other OS_PEND_DATAs in the list   */
   \   00001C A804                  MOVW      AX, [SP+0x04]      ;; 1 cycle
   \   00001E 16                    MOVW      HL, AX             ;; 1 cycle
   \   00001F F6                    CLRW      AX                 ;; 1 cycle
   \   000020 BC02                  MOVW      [HL+0x02], AX      ;; 1 cycle
   1444                  p_pend_data->PrevPtr    = (OS_PEND_DATA *)0;
   \   000022 BB                    MOVW      [HL], AX           ;; 1 cycle
   1445                  p_pend_list->HeadPtr    = p_pend_data;                        /*                                              */
   \   000023 A806                  MOVW      AX, [SP+0x06]      ;; 1 cycle
   \   000025 14                    MOVW      DE, AX             ;; 1 cycle
   \   000026 17                    MOVW      AX, HL             ;; 1 cycle
   \   000027 B9                    MOVW      [DE], AX           ;; 1 cycle
   1446                  p_pend_list->TailPtr    = p_pend_data;
   \   000028 EF36                  BR        S:??OS_TaskRdy_32  ;; 3 cycles
   \   00002A                       ; ------------------------------------- Block: 14 cycles
   1447              } else {
   1448                  p_pend_list->NbrEntries++;                                    /* CASE 1: One more OS_PEND_DATA in the list    */
   \                     ??OS_TaskRdy_31:
   \   00002A A1                    INCW      AX                 ;; 1 cycle
   \   00002B BB                    MOVW      [HL], AX           ;; 1 cycle
   1449                  p_pend_data_next = p_pend_list->HeadPtr;
   \   00002C A806                  MOVW      AX, [SP+0x06]      ;; 1 cycle
   \   00002E 16                    MOVW      HL, AX             ;; 1 cycle
   \   00002F AB                    MOVW      AX, [HL]           ;; 1 cycle
   \   000030 EF0B                  BR        S:??OS_TaskRdy_33  ;; 3 cycles
   \   000032                       ; ------------------------------------- Block: 8 cycles
   1450                  while (p_pend_data_next != (OS_PEND_DATA *)0) {               /*         Find the position where to insert    */
   1451                      p_tcb_next   = p_pend_data_next->TCBPtr;
   1452                      if (prio < p_tcb_next->Prio) {
   \                     ??OS_PendListInsertPrio_0:
   \   000032 AC04                  MOVW      AX, [HL+0x04]      ;; 1 cycle
   \   000034 14                    MOVW      DE, AX             ;; 1 cycle
   \   000035 8A1D                  MOV       A, [DE+0x1D]       ;; 1 cycle
   \   000037 6143                  CMP       B, A               ;; 1 cycle
   \   000039 DC29                  BC        ??OS_TaskRdy_34    ;; 4 cycles
   \   00003B                       ; ------------------------------------- Block: 8 cycles
   1453                          break;                                                /*         Found! ... insert BEFORE current     */
   1454                      } else {
   1455                          p_pend_data_next = p_pend_data_next->NextPtr;         /*         Not Found, follow the list           */
   \   00003B AC02                  MOVW      AX, [HL+0x02]      ;; 1 cycle
   \   00003D                       ; ------------------------------------- Block: 1 cycles
   \                     ??OS_TaskRdy_33:
   \   00003D 16                    MOVW      HL, AX             ;; 1 cycle
   1456                      }
   1457                  }
   \   00003E 440000                CMPW      AX, #0x0           ;; 1 cycle
   \   000041 DFEF                  BNZ       ??OS_PendListInsertPrio_0  ;; 4 cycles
   \   000043                       ; ------------------------------------- Block: 6 cycles
   1458                  if (p_pend_data_next == (OS_PEND_DATA *)0) {                  /*         TCB to insert is lower in prio       */
   1459                      p_pend_data->NextPtr      = (OS_PEND_DATA *)0;            /*         ... insert at the tail.              */
   \   000043 A804                  MOVW      AX, [SP+0x04]      ;; 1 cycle
   \   000045 16                    MOVW      HL, AX             ;; 1 cycle
   \   000046 F6                    CLRW      AX                 ;; 1 cycle
   \   000047 BC02                  MOVW      [HL+0x02], AX      ;; 1 cycle
   1460                      p_pend_data_prev          = p_pend_list->TailPtr;
   \   000049 A806                  MOVW      AX, [SP+0x06]      ;; 1 cycle
   \   00004B 16                    MOVW      HL, AX             ;; 1 cycle
   \   00004C AC02                  MOVW      AX, [HL+0x02]      ;; 1 cycle
   \   00004E B800                  MOVW      [SP], AX           ;; 1 cycle
   1461                      p_pend_data->PrevPtr      = p_pend_data_prev;
   \   000050 16                    MOVW      HL, AX             ;; 1 cycle
   \   000051 A804                  MOVW      AX, [SP+0x04]      ;; 1 cycle
   \   000053 14                    MOVW      DE, AX             ;; 1 cycle
   \   000054 17                    MOVW      AX, HL             ;; 1 cycle
   \   000055 B9                    MOVW      [DE], AX           ;; 1 cycle
   1462                      p_pend_data_prev->NextPtr = p_pend_data;
   \   000056 C5                    PUSH      DE                 ;; 1 cycle
   \   000057 C6                    POP       HL                 ;; 1 cycle
   \   000058 14                    MOVW      DE, AX             ;; 1 cycle
   \   000059 17                    MOVW      AX, HL             ;; 1 cycle
   \   00005A BA02                  MOVW      [DE+0x02], AX      ;; 1 cycle
   1463                      p_pend_list->TailPtr      = p_pend_data;
   \   00005C A806                  MOVW      AX, [SP+0x06]      ;; 1 cycle
   \   00005E 14                    MOVW      DE, AX             ;; 1 cycle
   \   00005F 17                    MOVW      AX, HL             ;; 1 cycle
   \   000060                       ; ------------------------------------- Block: 21 cycles
   \                     ??OS_TaskRdy_32:
   \   000060 BA02                  MOVW      [DE+0x02], AX      ;; 1 cycle
   \   000062 EF33                  BR        S:??OS_TaskRdy_35  ;; 3 cycles
   \   000064                       ; ------------------------------------- Block: 4 cycles
   1464                  } else {
   1465                      if (p_pend_data_next->PrevPtr == (OS_PEND_DATA *)0) {     /*         Is new TCB highest priority?         */
   \                     ??OS_TaskRdy_34:
   \   000064 A804                  MOVW      AX, [SP+0x04]      ;; 1 cycle
   \   000066 A1                    INCW      AX                 ;; 1 cycle
   \   000067 A1                    INCW      AX                 ;; 1 cycle
   \   000068 B802                  MOVW      [SP+0x02], AX      ;; 1 cycle
   \   00006A AB                    MOVW      AX, [HL]           ;; 1 cycle
   \   00006B 440000                CMPW      AX, #0x0           ;; 1 cycle
   \   00006E DF14                  BNZ       ??OS_TaskRdy_36    ;; 4 cycles
   \   000070                       ; ------------------------------------- Block: 10 cycles
   1466                          p_pend_data_next->PrevPtr  = p_pend_data;             /*         Yes, insert as new Head of list      */
   \   000070 A804                  MOVW      AX, [SP+0x04]      ;; 1 cycle
   \   000072 BB                    MOVW      [HL], AX           ;; 1 cycle
   1467                          p_pend_data->PrevPtr       = (OS_PEND_DATA *)0;
   \   000073 14                    MOVW      DE, AX             ;; 1 cycle
   \   000074 F6                    CLRW      AX                 ;; 1 cycle
   \   000075 B9                    MOVW      [DE], AX           ;; 1 cycle
   1468                          p_pend_data->NextPtr       = p_pend_data_next;
   \   000076 A5                    INCW      DE                 ;; 1 cycle
   \   000077 A5                    INCW      DE                 ;; 1 cycle
   \   000078 17                    MOVW      AX, HL             ;; 1 cycle
   \   000079 B9                    MOVW      [DE], AX           ;; 1 cycle
   1469                          p_pend_list->HeadPtr       = p_pend_data;
   \   00007A A804                  MOVW      AX, [SP+0x04]      ;; 1 cycle
   \   00007C 16                    MOVW      HL, AX             ;; 1 cycle
   \   00007D A806                  MOVW      AX, [SP+0x06]      ;; 1 cycle
   \   00007F 14                    MOVW      DE, AX             ;; 1 cycle
   \   000080 17                    MOVW      AX, HL             ;; 1 cycle
   \   000081 B9                    MOVW      [DE], AX           ;; 1 cycle
   \   000082 EF13                  BR        S:??OS_TaskRdy_35  ;; 3 cycles
   \   000084                       ; ------------------------------------- Block: 18 cycles
   1470                      } else {
   1471                          p_pend_data_prev           = p_pend_data_next->PrevPtr;/*        No,  insert in between two entries   */
   \                     ??OS_TaskRdy_36:
   \   000084 B800                  MOVW      [SP], AX           ;; 1 cycle
   1472                          p_pend_data->PrevPtr       = p_pend_data_prev;
   \   000086 12                    MOVW      BC, AX             ;; 1 cycle
   \   000087 A804                  MOVW      AX, [SP+0x04]      ;; 1 cycle
   \   000089 14                    MOVW      DE, AX             ;; 1 cycle
   \   00008A 33                    XCHW      AX, BC             ;; 1 cycle
   \   00008B B9                    MOVW      [DE], AX           ;; 1 cycle
   1473                          p_pend_data->NextPtr       = p_pend_data_next;
   \   00008C A5                    INCW      DE                 ;; 1 cycle
   \   00008D A5                    INCW      DE                 ;; 1 cycle
   \   00008E 17                    MOVW      AX, HL             ;; 1 cycle
   \   00008F B9                    MOVW      [DE], AX           ;; 1 cycle
   1474                          p_pend_data_prev->NextPtr  = p_pend_data;
   \   000090 A800                  MOVW      AX, [SP]           ;; 1 cycle
   \   000092 14                    MOVW      DE, AX             ;; 1 cycle
   \   000093 13                    MOVW      AX, BC             ;; 1 cycle
   \   000094 BA02                  MOVW      [DE+0x02], AX      ;; 1 cycle
   1475                          p_pend_data_next->PrevPtr  = p_pend_data;
   \   000096 BB                    MOVW      [HL], AX           ;; 1 cycle
   \   000097                       ; ------------------------------------- Block: 15 cycles
   1476                      }
   1477                  }
   1478              }
   1479          }
   \                     ??OS_TaskRdy_35:
   \   000097 1008                  ADDW      SP, #0x8           ;; 1 cycle
   \   000099 C4                    POP       DE                 ;; 1 cycle
   \   00009A D7                    RET                          ;; 6 cycles
   \   00009B                       ; ------------------------------------- Block: 8 cycles
   \   00009B                       ; ------------------------------------- Total: 135 cycles
   \   00009B                       REQUIRE ?CLRL78_V1_0_L00
   1480          
   1481          /*$PAGE*/
   1482          /*
   1483          ************************************************************************************************************************
   1484          *                           REMOVE TASK FROM PEND LIST(s) KNOWING ONLY WHICH TCB TO REMOVE
   1485          *
   1486          * Description: This function is called to remove a task from a pend list knowing only the TCB of the task to remove
   1487          *
   1488          *
   1489          *              CASE 0: OS_PEND_DATA list is empty, nothing to do.
   1490          *
   1491          *              CASE 1: Only 1 OS_PEND_DATA in the list.
   1492          *
   1493          *                     OS_PEND_LIST
   1494          *                     +--------------+         OS_PEND_DATA
   1495          *                     | TailPtr      |--+---> +------------+
   1496          *                     +--------------+  |     | NextPtr    |->0
   1497          *                     | HeadPtr      |--/     +------------+
   1498          *                     +--------------+     0<-| PrevPtr    |
   1499          *                     | NbrEntries=1 |        +------------+
   1500          *                     +--------------+        |            |
   1501          *                                             +------------+
   1502          *                                             |            |
   1503          *                                             +------------+
   1504          *
   1505          *              CASE N: Two or more OS_PEND_DATAs in the list.
   1506          *
   1507          *                     OS_PEND_LIST
   1508          *                     +--------------+
   1509          *                     | TailPtr      |-----------------------------------------------+
   1510          *                     +--------------+         OS_PEND_DATA         OS_PEND_DATA     |    OS_PEND_DATA
   1511          *                     | HeadPtr      |------> +------------+       +------------+    +-> +------------+
   1512          *                     +--------------+        | NextPtr    |------>| NextPtr    | ...... | NextPtr    |->0
   1513          *                     | NbrEntries=N |        +------------+       +------------+        +------------+
   1514          *                     +--------------+     0<-| PrevPtr    |<------| PrevPtr    | ...... | PrevPtr    |
   1515          *                                             +------------+       +------------+        +------------+
   1516          *                                             |            |       |            |        |            |
   1517          *                                             +------------+       +------------+        +------------+
   1518          *                                             |            |       |            |        |            |
   1519          *                                             +------------+       +------------+        +------------+
   1520          *
   1521          *
   1522          * Arguments  : p_tcb          is a pointer to the TCB of the task to remove from all pend lists
   1523          *              -----
   1524          *
   1525          * Returns    : none
   1526          *
   1527          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1528          ************************************************************************************************************************
   1529          */
   1530          

   \                                 In  segment CODE, align 1, keep-with-next
   1531          void  OS_PendListRemove (OS_TCB  *p_tcb)
   \                     OS_PendListRemove:
   1532          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000 C3                    PUSH      BC                 ;; 1 cycle
   \   000001 C5                    PUSH      DE                 ;; 1 cycle
   \   000002 C1                    PUSH      AX                 ;; 1 cycle
   \   000003                       ; Auto size: 4
   \   000003 C1                    PUSH      AX                 ;; 1 cycle
   1533              OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
   1534              OS_PEND_DATA   *p_pend_data;
   1535              OS_PEND_LIST   *p_pend_list;
   1536              OS_PEND_OBJ    *p_obj;
   1537          
   1538          
   1539          
   1540              p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
   \   000004 16                    MOVW      HL, AX             ;; 1 cycle
   \   000005 AC18                  MOVW      AX, [HL+0x18]      ;; 1 cycle
   \   000007 14                    MOVW      DE, AX             ;; 1 cycle
   1541              n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */
   \   000008 AC22                  MOVW      AX, [HL+0x22]      ;; 1 cycle
   \   00000A EF12                  BR        S:??OS_TaskRdy_37  ;; 3 cycles
   \   00000C                       ; ------------------------------------- Block: 11 cycles
   1542          
   1543              while (n_pend_list > (OS_OBJ_QTY)0) {
   1544                  p_obj       =  p_pend_data->PendObjPtr;                     /* Get pointer to pend list                       */
   1545                  p_pend_list = &p_obj->PendList;
   1546                  OS_PendListRemove1(p_pend_list,
   1547                                     p_pend_data);
   \                     ??OS_PendListRemove_0:
   \   00000C C5                    PUSH      DE                 ;; 1 cycle
   \   00000D C2                    POP       BC                 ;; 1 cycle
   \   00000E AA06                  MOVW      AX, [DE+0x06]      ;; 1 cycle
   \   000010 040600                ADDW      AX, #0x6           ;; 1 cycle
   \   000013 FD....                CALL      OS_PendListRemove1  ;; 3 cycles
   1548                  p_pend_data++;
   \   000016 15                    MOVW      AX, DE             ;; 1 cycle
   \   000017 041200                ADDW      AX, #0x12          ;; 1 cycle
   \   00001A 14                    MOVW      DE, AX             ;; 1 cycle
   1549                  n_pend_list--;
   \   00001B A800                  MOVW      AX, [SP]           ;; 1 cycle
   \   00001D B1                    DECW      AX                 ;; 1 cycle
   \   00001E                       ; ------------------------------------- Block: 12 cycles
   \                     ??OS_TaskRdy_37:
   \   00001E B800                  MOVW      [SP], AX           ;; 1 cycle
   1550              }
   \   000020 F7                    CLRW      BC                 ;; 1 cycle
   \   000021 43                    CMPW      AX, BC             ;; 1 cycle
   \   000022 DFE8                  BNZ       ??OS_PendListRemove_0  ;; 4 cycles
   \   000024                       ; ------------------------------------- Block: 7 cycles
   1551              p_tcb->PendDataTblEntries = (OS_OBJ_QTY    )0;
   \   000024 A802                  MOVW      AX, [SP+0x02]      ;; 1 cycle
   \   000026 16                    MOVW      HL, AX             ;; 1 cycle
   \   000027 F6                    CLRW      AX                 ;; 1 cycle
   \   000028 BC22                  MOVW      [HL+0x22], AX      ;; 1 cycle
   1552              p_tcb->PendDataTblPtr     = (OS_PEND_DATA *)0;
   \   00002A BC18                  MOVW      [HL+0x18], AX      ;; 1 cycle
   1553          }
   \   00002C ED....                BR        N:?Subroutine0     ;; 3 cycles
   \   00002F                       ; ------------------------------------- Block: 8 cycles
   \   00002F                       ; ------------------------------------- Total: 38 cycles
   \   00002F                       REQUIRE ?CLRL78_V1_0_L00
   1554          
   1555          /*$PAGE*/
   1556          /*
   1557          ************************************************************************************************************************
   1558          *                               REMOVE AN 'OS_PEND_DATA' ENTRY from a 'OS_PEND_LIST'
   1559          *
   1560          * Description: This function is called to remove a task from a wait list knowing only the TCB of the task to remove
   1561          *
   1562          *
   1563          *              CASE 1: Only 1 OS_PEND_DATA in the list.
   1564          *
   1565          *                     OS_PEND_LIST
   1566          *                     +--------------+         OS_PEND_DATA
   1567          *                     | TailPtr      |--+---> +------------+
   1568          *                     +--------------+  |     | NextPtr    |->0
   1569          *                     | HeadPtr      |--/      +------------+
   1570          *                     +--------------+     0<-| PrevPtr    |
   1571          *                     | NbrEntries=1 |        +------------+
   1572          *                     +--------------+        |            |
   1573          *                                             +------------+
   1574          *                                             |            |
   1575          *                                             +------------+
   1576          *
   1577          *              CASE N: Two or more OS_PEND_DATAs in the list.
   1578          *
   1579          *                     OS_PEND_LIST
   1580          *                     +--------------+
   1581          *                     | TailPtr      |-----------------------------------------------+
   1582          *                     +--------------+         OS_PEND_DATA         OS_PEND_DATA     |    OS_PEND_DATA
   1583          *                     | HeadPtr      |------> +------------+       +------------+    +-> +------------+
   1584          *                     +--------------+        | NextPtr    |------>| NextPtr    | ...... | NextPtr    |->0
   1585          *                     | NbrEntries=N |        +------------+       +------------+        +------------+
   1586          *                     +--------------+     0<-| PrevPtr    |<------| PrevPtr    | ...... | PrevPtr    |
   1587          *                                             +------------+       +------------+        +------------+
   1588          *                                             |            |       |            |        |            |
   1589          *                                             +------------+       +------------+        +------------+
   1590          *                                             |            |       |            |        |            |
   1591          *                                             +------------+       +------------+        +------------+
   1592          *
   1593          *
   1594          * Arguments  : p_pend_list     is a pointer to the pend list where 'p_pend_data' will be removed from
   1595          *              -----------
   1596          *
   1597          *              p_pend_data     is a pointer to the OS_PEND_DATA to remove from the pend list
   1598          *              -----------
   1599          *
   1600          * Returns    : none
   1601          *
   1602          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1603          ************************************************************************************************************************
   1604          */
   1605          

   \                                 In  segment CODE, align 1, keep-with-next
   1606          void  OS_PendListRemove1 (OS_PEND_LIST  *p_pend_list,
   \                     OS_PendListRemove1:
   1607                                    OS_PEND_DATA  *p_pend_data)
   1608          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000 C5                    PUSH      DE                 ;; 1 cycle
   \   000001 C3                    PUSH      BC                 ;; 1 cycle
   \   000002                       ; Auto size: 8
   \   000002 2006                  SUBW      SP, #0x6           ;; 1 cycle
   \   000004 16                    MOVW      HL, AX             ;; 1 cycle
   1609              OS_PEND_DATA  *p_prev;
   1610              OS_PEND_DATA  *p_next;
   1611          
   1612          
   1613          
   1614              if (p_pend_list->NbrEntries == 1u) {
   \   000005 13                    MOVW      AX, BC             ;; 1 cycle
   \   000006 A1                    INCW      AX                 ;; 1 cycle
   \   000007 A1                    INCW      AX                 ;; 1 cycle
   \   000008 B804                  MOVW      [SP+0x04], AX      ;; 1 cycle
   \   00000A AC04                  MOVW      AX, [HL+0x04]      ;; 1 cycle
   \   00000C E7                    ONEW      BC                 ;; 1 cycle
   \   00000D 43                    CMPW      AX, BC             ;; 1 cycle
   \   00000E DF04                  BNZ       ??OS_TaskRdy_38    ;; 4 cycles
   \   000010                       ; ------------------------------------- Block: 15 cycles
   1615                  p_pend_list->HeadPtr = (OS_PEND_DATA *)0;           /* Only one entry in the pend list                        */
   \   000010 F6                    CLRW      AX                 ;; 1 cycle
   \   000011 BB                    MOVW      [HL], AX           ;; 1 cycle
   1616                  p_pend_list->TailPtr = (OS_PEND_DATA *)0;
   \   000012 EF25                  BR        S:??OS_TaskRdy_39  ;; 3 cycles
   \   000014                       ; ------------------------------------- Block: 5 cycles
   1617          
   1618              } else if (p_pend_data->PrevPtr == (OS_PEND_DATA *)0) { /* See if entry is at the head of the list                */
   \                     ??OS_TaskRdy_38:
   \   000014 A806                  MOVW      AX, [SP+0x06]      ;; 1 cycle
   \   000016 14                    MOVW      DE, AX             ;; 1 cycle
   \   000017 A9                    MOVW      AX, [DE]           ;; 1 cycle
   \   000018 440000                CMPW      AX, #0x0           ;; 1 cycle
   \   00001B A5                    INCW      DE                 ;; 1 cycle
   \   00001C A5                    INCW      DE                 ;; 1 cycle
   \   00001D A9                    MOVW      AX, [DE]           ;; 1 cycle
   \   00001E DF09                  BNZ       ??OS_TaskRdy_40    ;; 4 cycles
   \   000020                       ; ------------------------------------- Block: 11 cycles
   1619                  p_next               = p_pend_data->NextPtr;        /* Yes                                                    */
   \   000020 B802                  MOVW      [SP+0x02], AX      ;; 1 cycle
   1620                  p_next->PrevPtr      = (OS_PEND_DATA *)0;
   \   000022 14                    MOVW      DE, AX             ;; 1 cycle
   \   000023 F6                    CLRW      AX                 ;; 1 cycle
   \   000024 B9                    MOVW      [DE], AX           ;; 1 cycle
   1621                  p_pend_list->HeadPtr = p_next;
   \   000025 15                    MOVW      AX, DE             ;; 1 cycle
   \   000026 BB                    MOVW      [HL], AX           ;; 1 cycle
   \   000027 EF23                  BR        S:??OS_TaskRdy_41  ;; 3 cycles
   \   000029                       ; ------------------------------------- Block: 9 cycles
   1622          
   1623              } else if (p_pend_data->NextPtr == (OS_PEND_DATA *)0) { /* See if entry is at the tail of the list                */
   \                     ??OS_TaskRdy_40:
   \   000029 440000                CMPW      AX, #0x0           ;; 1 cycle
   \   00002C A806                  MOVW      AX, [SP+0x06]      ;; 1 cycle
   \   00002E 14                    MOVW      DE, AX             ;; 1 cycle
   \   00002F A9                    MOVW      AX, [DE]           ;; 1 cycle
   \   000030 B800                  MOVW      [SP], AX           ;; 1 cycle
   \   000032 DF09                  BNZ       ??OS_TaskRdy_42    ;; 4 cycles
   \   000034                       ; ------------------------------------- Block: 9 cycles
   1624                  p_prev               = p_pend_data->PrevPtr;        /* Yes                                                    */
   1625                  p_prev->NextPtr      = (OS_PEND_DATA *)0;
   \   000034 14                    MOVW      DE, AX             ;; 1 cycle
   \   000035 F6                    CLRW      AX                 ;; 1 cycle
   \   000036 BA02                  MOVW      [DE+0x02], AX      ;; 1 cycle
   1626                  p_pend_list->TailPtr = p_prev;
   \   000038 15                    MOVW      AX, DE             ;; 1 cycle
   \   000039                       ; ------------------------------------- Block: 4 cycles
   \                     ??OS_TaskRdy_39:
   \   000039 BC02                  MOVW      [HL+0x02], AX      ;; 1 cycle
   \   00003B EF0F                  BR        S:??OS_TaskRdy_41  ;; 3 cycles
   \   00003D                       ; ------------------------------------- Block: 4 cycles
   1627          
   1628              } else {
   1629                  p_prev               = p_pend_data->PrevPtr;        /* Remove from inside the list                            */
   1630                  p_next               = p_pend_data->NextPtr;
   \                     ??OS_TaskRdy_42:
   \   00003D A5                    INCW      DE                 ;; 1 cycle
   \   00003E A5                    INCW      DE                 ;; 1 cycle
   \   00003F A9                    MOVW      AX, [DE]           ;; 1 cycle
   \   000040 B802                  MOVW      [SP+0x02], AX      ;; 1 cycle
   1631                  p_prev->NextPtr      = p_next;
   \   000042 12                    MOVW      BC, AX             ;; 1 cycle
   \   000043 A800                  MOVW      AX, [SP]           ;; 1 cycle
   \   000045 14                    MOVW      DE, AX             ;; 1 cycle
   \   000046 33                    XCHW      AX, BC             ;; 1 cycle
   \   000047 BA02                  MOVW      [DE+0x02], AX      ;; 1 cycle
   1632                  p_next->PrevPtr      = p_prev;
   \   000049 14                    MOVW      DE, AX             ;; 1 cycle
   \   00004A 13                    MOVW      AX, BC             ;; 1 cycle
   \   00004B B9                    MOVW      [DE], AX           ;; 1 cycle
   \   00004C                       ; ------------------------------------- Block: 12 cycles
   1633              }
   1634              p_pend_list->NbrEntries--;                              /* One less entry in the list                             */
   \                     ??OS_TaskRdy_41:
   \   00004C AC04                  MOVW      AX, [HL+0x04]      ;; 1 cycle
   \   00004E B1                    DECW      AX                 ;; 1 cycle
   \   00004F BC04                  MOVW      [HL+0x04], AX      ;; 1 cycle
   1635              p_pend_data->NextPtr = (OS_PEND_DATA *)0;
   \   000051 A804                  MOVW      AX, [SP+0x04]      ;; 1 cycle
   \   000053 16                    MOVW      HL, AX             ;; 1 cycle
   \   000054 F6                    CLRW      AX                 ;; 1 cycle
   \   000055 BB                    MOVW      [HL], AX           ;; 1 cycle
   1636              p_pend_data->PrevPtr = (OS_PEND_DATA *)0;
   \   000056 A806                  MOVW      AX, [SP+0x06]      ;; 1 cycle
   \   000058 16                    MOVW      HL, AX             ;; 1 cycle
   \   000059 F6                    CLRW      AX                 ;; 1 cycle
   \   00005A BB                    MOVW      [HL], AX           ;; 1 cycle
   1637          }
   \   00005B 1008                  ADDW      SP, #0x8           ;; 1 cycle
   \   00005D C4                    POP       DE                 ;; 1 cycle
   \   00005E D7                    RET                          ;; 6 cycles
   \   00005F                       ; ------------------------------------- Block: 19 cycles
   \   00005F                       ; ------------------------------------- Total: 88 cycles
   \   00005F                       REQUIRE ?CLRL78_V1_0_L00
   1638          
   1639          /*$PAGE*/
   1640          /*
   1641          ************************************************************************************************************************
   1642          *                                READY A TASK THAT WAS PENDING ON AN OBJECT BEING DELETED
   1643          *
   1644          * Description: This function is called when a object is to make a task ready-to-run.
   1645          *
   1646          * Arguments  : p_obj          is a pointer to the object being deleted
   1647          *              -----
   1648          *
   1649          *              p_tcb          is a pointer to the OS_TCB of the task to make ready-to-run
   1650          *              -----
   1651          *
   1652          *              ts             is a timestamp to indicate when the object was deleted
   1653          *
   1654          * Returns    : none
   1655          *
   1656          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   1657          ************************************************************************************************************************
   1658          */
   1659          

   \                                 In  segment CODE, align 1, keep-with-next
   1660          void   OS_PendObjDel (OS_PEND_OBJ *p_obj,
   \                     OS_PendObjDel:
   1661                                OS_TCB      *p_tcb,
   1662                                CPU_TS       ts)
   1663          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 4
   \   000000 C5                    PUSH      DE                 ;; 1 cycle
   \   000001 C1                    PUSH      AX                 ;; 1 cycle
   \   000002                       ; Auto size: 2
   \   000002 C3                    PUSH      BC                 ;; 1 cycle
   \   000003 C4                    POP       DE                 ;; 1 cycle
   1664              switch (p_tcb->TaskState) {
   \   000004 8A1C                  MOV       A, [DE+0x1C]       ;; 1 cycle
   \   000006 2C02                  SUB       A, #0x2            ;; 1 cycle
   \   000008 4C02                  CMP       A, #0x2            ;; 1 cycle
   \   00000A DC08                  BC        ??OS_TaskRdy_43    ;; 4 cycles
   \   00000C                       ; ------------------------------------- Block: 11 cycles
   \   00000C 2C04                  SUB       A, #0x4            ;; 1 cycle
   \   00000E 4C02                  CMP       A, #0x2            ;; 1 cycle
   \   000010 DC2C                  BC        ??OS_TaskRdy_44    ;; 4 cycles
   \   000012                       ; ------------------------------------- Block: 6 cycles
   \   000012 EF5C                  BR        S:??OS_TaskRdy_45  ;; 3 cycles
   \   000014                       ; ------------------------------------- Block: 3 cycles
   \                     ??OS_TaskRdy_43:
   \   000014 8A1A                  MOV       A, [DE+0x1A]       ;; 1 cycle
   \   000016 4C03                  CMP       A, #0x3            ;; 1 cycle
   \   000018 DF0E                  BNZ       ??OS_TaskRdy_46    ;; 4 cycles
   \   00001A                       ; ------------------------------------- Block: 6 cycles
   1665                  case OS_TASK_STATE_RDY:                                  /* These states should never occur                   */
   1666                  case OS_TASK_STATE_DLY:
   1667                  case OS_TASK_STATE_SUSPENDED:
   1668                  case OS_TASK_STATE_DLY_SUSPENDED:
   1669                       break;
   1670          
   1671                  case OS_TASK_STATE_PEND:
   1672                  case OS_TASK_STATE_PEND_TIMEOUT:
   1673                       if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
   1674                           OS_PendObjDel1(p_obj,                           /* Indicate which object was pend aborted            */
   1675                                          p_tcb,
   1676                                          ts);
   \   00001A A80A                  MOVW      AX, [SP+0x0A]      ;; 1 cycle
   \   00001C 12                    MOVW      BC, AX             ;; 1 cycle
   \   00001D A808                  MOVW      AX, [SP+0x08]      ;; 1 cycle
   \   00001F C3                    PUSH      BC                 ;; 1 cycle
   \   000020 C1                    PUSH      AX                 ;; 1 cycle
   \   000021 C5                    PUSH      DE                 ;; 1 cycle
   \   000022 C2                    POP       BC                 ;; 1 cycle
   \   000023 A804                  MOVW      AX, [SP+0x04]      ;; 1 cycle
   \   000025 FD....                CALL      OS_PendObjDel1     ;; 3 cycles
   \   000028                       ; ------------------------------------- Block: 11 cycles
   1677                       }
   1678          #if (OS_MSG_EN > 0u)
   1679                       p_tcb->MsgPtr     = (void *)0;
   \                     ??OS_TaskRdy_46:
   \   000028 FD....                CALL      N:?Subroutine6     ;; 3 cycles
   \   00002B                       ; ------------------------------------- Block: 3 cycles
   1680                       p_tcb->MsgSize    = (OS_MSG_SIZE)0u;
   1681          #endif
   1682                       p_tcb->TS         = ts;
   \                     ??CrossCallReturnLabel_5:
   \   00002B A80A                  MOVW      AX, [SP+0x0A]      ;; 1 cycle
   \   00002D 12                    MOVW      BC, AX             ;; 1 cycle
   \   00002E A808                  MOVW      AX, [SP+0x08]      ;; 1 cycle
   \   000030 FD....                CALL      N:?Subroutine12    ;; 3 cycles
   \   000033                       ; ------------------------------------- Block: 6 cycles
   1683                       OS_PendListRemove(p_tcb);                           /* Remove task from all wait lists                   */
   \                     ??CrossCallReturnLabel_18:
   \   000033 15                    MOVW      AX, DE             ;; 1 cycle
   \   000034 FD....                CALL      OS_PendListRemove  ;; 3 cycles
   1684                       OS_TaskRdy(p_tcb);
   \   000037 15                    MOVW      AX, DE             ;; 1 cycle
   \   000038 FD....                CALL      OS_TaskRdy         ;; 3 cycles
   1685                       p_tcb->TaskState  = OS_TASK_STATE_RDY;              /* Task is readied because object is deleted         */
   \   00003B F1                    CLRB      A                  ;; 1 cycle
   \   00003C EF29                  BR        S:??OS_TaskRdy_47  ;; 3 cycles
   \   00003E                       ; ------------------------------------- Block: 12 cycles
   \                     ??OS_TaskRdy_44:
   \   00003E 8A1A                  MOV       A, [DE+0x1A]       ;; 1 cycle
   \   000040 4C03                  CMP       A, #0x3            ;; 1 cycle
   \   000042 DF0E                  BNZ       ??OS_TaskRdy_48    ;; 4 cycles
   \   000044                       ; ------------------------------------- Block: 6 cycles
   1686                       p_tcb->PendStatus = OS_STATUS_PEND_DEL;             /* Indicate pend was aborted                         */
   1687                       p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;
   1688                       break;
   1689          
   1690                  case OS_TASK_STATE_PEND_SUSPENDED:
   1691                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
   1692                       if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
   1693                           OS_PendObjDel1(p_obj,                           /* Indicate which object was pend aborted            */
   1694                                          p_tcb,
   1695                                          ts);
   \   000044 A80A                  MOVW      AX, [SP+0x0A]      ;; 1 cycle
   \   000046 12                    MOVW      BC, AX             ;; 1 cycle
   \   000047 A808                  MOVW      AX, [SP+0x08]      ;; 1 cycle
   \   000049 C3                    PUSH      BC                 ;; 1 cycle
   \   00004A C1                    PUSH      AX                 ;; 1 cycle
   \   00004B C5                    PUSH      DE                 ;; 1 cycle
   \   00004C C2                    POP       BC                 ;; 1 cycle
   \   00004D A804                  MOVW      AX, [SP+0x04]      ;; 1 cycle
   \   00004F FD....                CALL      OS_PendObjDel1     ;; 3 cycles
   \   000052                       ; ------------------------------------- Block: 11 cycles
   1696                       }
   1697          #if (OS_MSG_EN > 0u)
   1698                       p_tcb->MsgPtr     = (void      *)0;
   \                     ??OS_TaskRdy_48:
   \   000052 FD....                CALL      N:?Subroutine6     ;; 3 cycles
   \   000055                       ; ------------------------------------- Block: 3 cycles
   1699                       p_tcb->MsgSize    = (OS_MSG_SIZE)0u;
   1700          #endif
   1701                       p_tcb->TS         = ts;
   \                     ??CrossCallReturnLabel_6:
   \   000055 A80A                  MOVW      AX, [SP+0x0A]      ;; 1 cycle
   \   000057 12                    MOVW      BC, AX             ;; 1 cycle
   \   000058 A808                  MOVW      AX, [SP+0x08]      ;; 1 cycle
   \   00005A FD....                CALL      N:?Subroutine12    ;; 3 cycles
   \   00005D                       ; ------------------------------------- Block: 6 cycles
   1702                       OS_TickListRemove(p_tcb);                           /* Cancel the timeout                                */
   \                     ??CrossCallReturnLabel_19:
   \   00005D 15                    MOVW      AX, DE             ;; 1 cycle
   \   00005E FD....                CALL      OS_TickListRemove  ;; 3 cycles
   1703                       OS_PendListRemove(p_tcb);                           /* Remove task from all wait lists                   */
   \   000061 15                    MOVW      AX, DE             ;; 1 cycle
   \   000062 FD....                CALL      OS_PendListRemove  ;; 3 cycles
   1704                       p_tcb->TaskState  = OS_TASK_STATE_SUSPENDED;        /* Task needs to remain suspended                    */
   \   000065 5104                  MOV       A, #0x4            ;; 1 cycle
   \   000067                       ; ------------------------------------- Block: 9 cycles
   \                     ??OS_TaskRdy_47:
   \   000067 9A1C                  MOV       [DE+0x1C], A       ;; 1 cycle
   1705                       p_tcb->PendStatus = OS_STATUS_PEND_DEL;             /* Indicate pend was aborted                         */
   \   000069 5102                  MOV       A, #0x2            ;; 1 cycle
   \   00006B 9A1B                  MOV       [DE+0x1B], A       ;; 1 cycle
   1706                       p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
   \   00006D F1                    CLRB      A                  ;; 1 cycle
   \   00006E 9A1A                  MOV       [DE+0x1A], A       ;; 1 cycle
   1707                       break;
   \   000070                       ; ------------------------------------- Block: 5 cycles
   1708          
   1709                  default:
   1710                       break;
   1711              }
   1712          }
   \                     ??OS_TaskRdy_45:
   \   000070 ED....                BR        N:?Subroutine14    ;; 3 cycles
   \   000073                       ; ------------------------------------- Block: 3 cycles
   \   000073                       ; ------------------------------------- Total: 101 cycles
   \   000073                       REQUIRE ?CLRL78_V1_0_L00
   1713          
   1714          /*$PAGE*/
   1715          /*
   1716          ************************************************************************************************************************
   1717          *                                    DELETE AN OBJECT FROM A TASK PENDING ON MULTIPLE OBJECTS
   1718          *
   1719          * Description: This function is called when a task is pending on multiple objects and the object is being deleted.
   1720          *              This function needs to indicate to the caller which object was deleted by placing the address of the
   1721          *              object in the OS_PEND_DATA table corresponding to the deleted object.
   1722          *
   1723          *              For example, if the task pends on six (6) objects, the address of those 6 objects are placed in the
   1724          *              .PendObjPtr field of the OS_PEND_DATA table as shown below.  Note that the .PendDataTblEntries would be
   1725          *              set to six (6) in this case.  As shown, when the pend call returns because a task deleted 'Obj C' then,
   1726          *              only the one entry contains the filled in data and the other entries contains NULL pointers and zero
   1727          *              data.
   1728          *
   1729          *              You should note that the NULL pointers are zero data values are actually filled in by the pend call.
   1730          *
   1731          *
   1732          *                                           .PendObjPtr    .RdyObjPtr     .RdyMsgPtr     .RdyMsgSize    .RdyTS
   1733          *                                         +--------------+--------------+--------------+--------------+--------------+
   1734          *              p_tcb->PendDataTblPtr  ->  |  Obj A       |  0           | 0            | 0            | 0            |
   1735          *                                         +--------------+--------------+--------------+--------------+--------------+
   1736          *                                         |  Obj B       |  0           | 0            | 0            | 0            |
   1737          *                                         +--------------+--------------+--------------+--------------+--------------+
   1738          *                                         |  Obj C       |  Obj C       | 0            | 0            | TS           |
   1739          *                                         +--------------+--------------+--------------+--------------+--------------+
   1740          *                                         |  Obj D       |  0           | 0            | 0            | 0            |
   1741          *                                         +--------------+--------------+--------------+--------------+--------------+
   1742          *                                         |  Obj E       |  0           | 0            | 0            | 0            |
   1743          *                                         +--------------+--------------+--------------+--------------+--------------+
   1744          *                                         |  Obj F       |  0           | 0            | 0            | 0            |
   1745          *                                         +--------------+--------------+--------------+--------------+--------------+
   1746          *
   1747          *
   1748          * Arguments  : p_obj        is a pointer to the object being deleted
   1749          *              -----
   1750          *
   1751          *              p_tcb        is the OS_TCB of the task pending on the object being deleted
   1752          *              -----
   1753          *
   1754          *              ts           is the time stamp of when the object was deleted
   1755          *
   1756          * Returns    : none
   1757          *
   1758          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1759          ************************************************************************************************************************
   1760          */
   1761          

   \                                 In  segment CODE, align 1, keep-with-next
   1762          void  OS_PendObjDel1 (OS_PEND_OBJ  *p_obj,
   \                     OS_PendObjDel1:
   1763                                OS_TCB       *p_tcb,
   1764                                CPU_TS        ts)
   1765          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 4
   \   000000 C5                    PUSH      DE                 ;; 1 cycle
   \   000001 C1                    PUSH      AX                 ;; 1 cycle
   \   000002 C3                    PUSH      BC                 ;; 1 cycle
   \   000003                       ; Auto size: 4
   1766              OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
   1767              OS_PEND_DATA   *p_pend_data;
   1768          
   1769          
   1770          
   1771              p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
   \   000003 C3                    PUSH      BC                 ;; 1 cycle
   \   000004 C6                    POP       HL                 ;; 1 cycle
   \   000005 AC18                  MOVW      AX, [HL+0x18]      ;; 1 cycle
   \   000007 14                    MOVW      DE, AX             ;; 1 cycle
   1772              n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */
   \   000008 C3                    PUSH      BC                 ;; 1 cycle
   \   000009 C6                    POP       HL                 ;; 1 cycle
   \   00000A AC22                  MOVW      AX, [HL+0x22]      ;; 1 cycle
   \   00000C 16                    MOVW      HL, AX             ;; 1 cycle
   \   00000D EF03                  BR        S:??CrossCallReturnLabel_12  ;; 3 cycles
   \   00000F                       ; ------------------------------------- Block: 14 cycles
   1773          
   1774              while (n_pend_list > (OS_OBJ_QTY)0) {                           /* Mark posted object in OS_PEND_DATA table       */
   1775                  if (p_obj == p_pend_data->PendObjPtr) {                     /* Did we find the object deleted?                */
   1776                      p_pend_data->RdyObjPtr = p_obj;                         /* Yes, indicate the object in the .RdyObjPtr     */
   1777                      p_pend_data->RdyTS     = ts;                            /*      save the timestamp                        */
   1778                      break;
   1779                  }
   1780                  p_pend_data++;
   \                     ??OS_PendObjDel1_0:
   \   00000F FD....                CALL      N:?Subroutine9     ;; 3 cycles
   1781                  n_pend_list--;
   \   000012                       ; ------------------------------------- Block: 3 cycles
   \                     ??CrossCallReturnLabel_12:
   \   000012 17                    MOVW      AX, HL             ;; 1 cycle
   \   000013 F7                    CLRW      BC                 ;; 1 cycle
   \   000014 43                    CMPW      AX, BC             ;; 1 cycle
   \   000015 DD14                  BZ        ??OS_TaskRdy_49    ;; 4 cycles
   \   000017                       ; ------------------------------------- Block: 7 cycles
   \   000017 AA06                  MOVW      AX, [DE+0x06]      ;; 1 cycle
   \   000019 12                    MOVW      BC, AX             ;; 1 cycle
   \   00001A A802                  MOVW      AX, [SP+0x02]      ;; 1 cycle
   \   00001C 43                    CMPW      AX, BC             ;; 1 cycle
   \   00001D DFF0                  BNZ       ??OS_PendObjDel1_0  ;; 4 cycles
   \   00001F                       ; ------------------------------------- Block: 8 cycles
   \   00001F BA08                  MOVW      [DE+0x08], AX      ;; 1 cycle
   \   000021 A80C                  MOVW      AX, [SP+0x0C]      ;; 1 cycle
   \   000023 12                    MOVW      BC, AX             ;; 1 cycle
   \   000024 A80A                  MOVW      AX, [SP+0x0A]      ;; 1 cycle
   \   000026 BA0E                  MOVW      [DE+0x0E], AX      ;; 1 cycle
   \   000028 13                    MOVW      AX, BC             ;; 1 cycle
   \   000029 BA10                  MOVW      [DE+0x10], AX      ;; 1 cycle
   \   00002B                       ; ------------------------------------- Block: 7 cycles
   1782              }
   1783          }
   \                     ??OS_TaskRdy_49:
   \   00002B ED....                BR        N:?Subroutine3     ;; 3 cycles
   \   00002E                       ; ------------------------------------- Block: 3 cycles
   \   00002E                       ; ------------------------------------- Total: 42 cycles
   \   00002E                       REQUIRE ?CLRL78_V1_0_L00
   1784          
   1785          /*$PAGE*/
   1786          /*
   1787          ************************************************************************************************************************
   1788          *                                                   POST TO A TASK
   1789          *
   1790          * Description: This function is called to post to a task.  This function exist because it is common to a number of
   1791          *              OSxxxPost() services.
   1792          *
   1793          * Arguments  : p_obj          Is a pointer to the object being posted to or NULL pointer if there is no object
   1794          *              -----
   1795          *
   1796          *              p_tcb          Is a pointer to the OS_TCB that will receive the 'post'
   1797          *              -----
   1798          *
   1799          *              p_void         If we are posting a message to a task, this is the message that the task will receive
   1800          *
   1801          *              msg_size       If we are posting a message to a task, this is the size of the message
   1802          *
   1803          *              ts             The timestamp as to when the post occurred
   1804          *
   1805          * Returns    : none
   1806          *
   1807          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   1808          ************************************************************************************************************************
   1809          */
   1810          

   \                                 In  segment CODE, align 1, keep-with-next
   1811          void   OS_Post (OS_PEND_OBJ  *p_obj,
   \                     OS_Post:
   1812                          OS_TCB       *p_tcb,
   1813                          void         *p_void,
   1814                          OS_MSG_SIZE   msg_size,
   1815                          CPU_TS        ts)
   1816          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 6
   \   000000 C1                    PUSH      AX                 ;; 1 cycle
   \   000001 C3                    PUSH      BC                 ;; 1 cycle
   \   000002 C5                    PUSH      DE                 ;; 1 cycle
   \   000003                       ; Auto size: 8
   \   000003 C1                    PUSH      AX                 ;; 1 cycle
   1817              switch (p_tcb->TaskState) {
   \   000004 13                    MOVW      AX, BC             ;; 1 cycle
   \   000005 16                    MOVW      HL, AX             ;; 1 cycle
   \   000006 8C1C                  MOV       A, [HL+0x1C]       ;; 1 cycle
   \   000008 2C02                  SUB       A, #0x2            ;; 1 cycle
   \   00000A 4C02                  CMP       A, #0x2            ;; 1 cycle
   \   00000C DC09                  BC        ??OS_TaskRdy_50    ;; 4 cycles
   \   00000E                       ; ------------------------------------- Block: 13 cycles
   \   00000E 2C04                  SUB       A, #0x4            ;; 1 cycle
   \   000010 4C02                  CMP       A, #0x2            ;; 1 cycle
   \   000012 DC4D                  BC        ??OS_TaskRdy_51    ;; 4 cycles
   \   000014                       ; ------------------------------------- Block: 6 cycles
   \   000014 ED....                BR        N:??OS_TaskRdy_52  ;; 3 cycles
   \   000017                       ; ------------------------------------- Block: 3 cycles
   1818                  case OS_TASK_STATE_RDY:                                  /* Cannot Pend Abort a task that is ready            */
   1819                  case OS_TASK_STATE_DLY:                                  /* Cannot Pend Abort a task that is delayed          */
   1820                  case OS_TASK_STATE_SUSPENDED:                            /* Cannot Post a suspended task                      */
   1821                  case OS_TASK_STATE_DLY_SUSPENDED:                        /* Cannot Post a suspended task that was also dly'd  */
   1822                       break;
   1823          
   1824                  case OS_TASK_STATE_PEND:
   1825                  case OS_TASK_STATE_PEND_TIMEOUT:
   1826                       if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
   \                     ??OS_TaskRdy_50:
   \   000017 13                    MOVW      AX, BC             ;; 1 cycle
   \   000018 041A00                ADDW      AX, #0x1A          ;; 1 cycle
   \   00001B B800                  MOVW      [SP], AX           ;; 1 cycle
   \   00001D 16                    MOVW      HL, AX             ;; 1 cycle
   \   00001E 8B                    MOV       A, [HL]            ;; 1 cycle
   \   00001F 4C03                  CMP       A, #0x3            ;; 1 cycle
   \   000021 DF14                  BNZ       ??OS_TaskRdy_53    ;; 4 cycles
   \   000023                       ; ------------------------------------- Block: 10 cycles
   1827                           OS_Post1(p_obj,                                 /* Indicate which object was posted to               */
   1828                                    p_tcb,
   1829                                    p_void,
   1830                                    msg_size,
   1831                                    ts);
   \   000023 A810                  MOVW      AX, [SP+0x10]      ;; 1 cycle
   \   000025 12                    MOVW      BC, AX             ;; 1 cycle
   \   000026 A80E                  MOVW      AX, [SP+0x0E]      ;; 1 cycle
   \   000028 C3                    PUSH      BC                 ;; 1 cycle
   \   000029 C1                    PUSH      AX                 ;; 1 cycle
   \   00002A A810                  MOVW      AX, [SP+0x10]      ;; 1 cycle
   \   00002C C1                    PUSH      AX                 ;; 1 cycle
   \   00002D A80A                  MOVW      AX, [SP+0x0A]      ;; 1 cycle
   \   00002F 12                    MOVW      BC, AX             ;; 1 cycle
   \   000030 A80C                  MOVW      AX, [SP+0x0C]      ;; 1 cycle
   \   000032 FD....                CALL      OS_Post1           ;; 3 cycles
   \   000035 EF11                  BR        S:??CrossCallReturnLabel_20  ;; 3 cycles
   \   000037                       ; ------------------------------------- Block: 16 cycles
   1832                       } else {
   1833          #if (OS_MSG_EN > 0u)
   1834                           p_tcb->MsgPtr  = p_void;                        /* Deposit message in OS_TCB of task waiting         */
   \                     ??OS_TaskRdy_53:
   \   000037 15                    MOVW      AX, DE             ;; 1 cycle
   \   000038 C3                    PUSH      BC                 ;; 1 cycle
   \   000039 C4                    POP       DE                 ;; 1 cycle
   \   00003A BA40                  MOVW      [DE+0x40], AX      ;; 1 cycle
   1835                           p_tcb->MsgSize = msg_size;                      /* ... assuming posting a message                    */
   \   00003C A80C                  MOVW      AX, [SP+0x0C]      ;; 1 cycle
   \   00003E BA42                  MOVW      [DE+0x42], AX      ;; 1 cycle
   1836          #endif
   1837                           p_tcb->TS      = ts;
   \   000040 A810                  MOVW      AX, [SP+0x10]      ;; 1 cycle
   \   000042 12                    MOVW      BC, AX             ;; 1 cycle
   \   000043 A80E                  MOVW      AX, [SP+0x0E]      ;; 1 cycle
   \   000045 FD....                CALL      N:?Subroutine12    ;; 3 cycles
   1838                       }
   \   000048                       ; ------------------------------------- Block: 12 cycles
   1839                       if (p_obj != (OS_PEND_OBJ *)0) {
   \                     ??CrossCallReturnLabel_20:
   \   000048 A806                  MOVW      AX, [SP+0x06]      ;; 1 cycle
   \   00004A 440000                CMPW      AX, #0x0           ;; 1 cycle
   \   00004D DD05                  BZ        ??OS_TaskRdy_54    ;; 4 cycles
   \   00004F                       ; ------------------------------------- Block: 6 cycles
   1840                           OS_PendListRemove(p_tcb);                       /* Remove task from wait list(s)                     */
   \   00004F A804                  MOVW      AX, [SP+0x04]      ;; 1 cycle
   \   000051 FD....                CALL      OS_PendListRemove  ;; 3 cycles
   \   000054                       ; ------------------------------------- Block: 4 cycles
   1841          #if OS_CFG_DBG_EN > 0u
   1842                           OS_PendDbgNameRemove(p_obj,
   1843                                                p_tcb);
   1844          #endif
   1845                       }
   1846                       OS_TaskRdy(p_tcb);                                  /* Make task ready to run                            */
   \                     ??OS_TaskRdy_54:
   \   000054 A804                  MOVW      AX, [SP+0x04]      ;; 1 cycle
   \   000056 FD....                CALL      OS_TaskRdy         ;; 3 cycles
   1847                       p_tcb->TaskState  = OS_TASK_STATE_RDY;
   \   000059 A804                  MOVW      AX, [SP+0x04]      ;; 1 cycle
   \   00005B 16                    MOVW      HL, AX             ;; 1 cycle
   \   00005C F1                    CLRB      A                  ;; 1 cycle
   \   00005D 9C1C                  MOV       [HL+0x1C], A       ;; 1 cycle
   1848                       p_tcb->PendStatus = OS_STATUS_PEND_OK;              /* Clear pend status                                 */
   \   00005F EF4A                  BR        S:??OS_TaskRdy_55  ;; 3 cycles
   \   000061                       ; ------------------------------------- Block: 11 cycles
   1849                       p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
   1850                       break;
   1851          
   1852                  case OS_TASK_STATE_PEND_SUSPENDED:
   1853                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
   1854                       if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
   \                     ??OS_TaskRdy_51:
   \   000061 13                    MOVW      AX, BC             ;; 1 cycle
   \   000062 041A00                ADDW      AX, #0x1A          ;; 1 cycle
   \   000065 B800                  MOVW      [SP], AX           ;; 1 cycle
   \   000067 16                    MOVW      HL, AX             ;; 1 cycle
   \   000068 8B                    MOV       A, [HL]            ;; 1 cycle
   \   000069 4C03                  CMP       A, #0x3            ;; 1 cycle
   \   00006B DF14                  BNZ       ??OS_TaskRdy_56    ;; 4 cycles
   \   00006D                       ; ------------------------------------- Block: 10 cycles
   1855                           OS_Post1(p_obj,                                 /* Indicate which object was posted to               */
   1856                                    p_tcb,
   1857                                    p_void,
   1858                                    msg_size,
   1859                                    ts);
   \   00006D A810                  MOVW      AX, [SP+0x10]      ;; 1 cycle
   \   00006F 12                    MOVW      BC, AX             ;; 1 cycle
   \   000070 A80E                  MOVW      AX, [SP+0x0E]      ;; 1 cycle
   \   000072 C3                    PUSH      BC                 ;; 1 cycle
   \   000073 C1                    PUSH      AX                 ;; 1 cycle
   \   000074 A810                  MOVW      AX, [SP+0x10]      ;; 1 cycle
   \   000076 C1                    PUSH      AX                 ;; 1 cycle
   \   000077 A80A                  MOVW      AX, [SP+0x0A]      ;; 1 cycle
   \   000079 12                    MOVW      BC, AX             ;; 1 cycle
   \   00007A A80C                  MOVW      AX, [SP+0x0C]      ;; 1 cycle
   \   00007C FD....                CALL      OS_Post1           ;; 3 cycles
   \   00007F EF11                  BR        S:??CrossCallReturnLabel_21  ;; 3 cycles
   \   000081                       ; ------------------------------------- Block: 16 cycles
   1860                       } else {
   1861          #if (OS_MSG_EN > 0u)
   1862                           p_tcb->MsgPtr  = p_void;                        /* Deposit message in OS_TCB of task waiting         */
   \                     ??OS_TaskRdy_56:
   \   000081 15                    MOVW      AX, DE             ;; 1 cycle
   \   000082 C3                    PUSH      BC                 ;; 1 cycle
   \   000083 C4                    POP       DE                 ;; 1 cycle
   \   000084 BA40                  MOVW      [DE+0x40], AX      ;; 1 cycle
   1863                           p_tcb->MsgSize = msg_size;                      /* ... assuming posting a message                    */
   \   000086 A80C                  MOVW      AX, [SP+0x0C]      ;; 1 cycle
   \   000088 BA42                  MOVW      [DE+0x42], AX      ;; 1 cycle
   1864          #endif
   1865                           p_tcb->TS      = ts;
   \   00008A A810                  MOVW      AX, [SP+0x10]      ;; 1 cycle
   \   00008C 12                    MOVW      BC, AX             ;; 1 cycle
   \   00008D A80E                  MOVW      AX, [SP+0x0E]      ;; 1 cycle
   \   00008F FD....                CALL      N:?Subroutine12    ;; 3 cycles
   1866                       }
   \   000092                       ; ------------------------------------- Block: 12 cycles
   1867                       OS_TickListRemove(p_tcb);                           /* Cancel any timeout                                */
   \                     ??CrossCallReturnLabel_21:
   \   000092 A804                  MOVW      AX, [SP+0x04]      ;; 1 cycle
   \   000094 FD....                CALL      OS_TickListRemove  ;; 3 cycles
   1868                       if (p_obj != (OS_PEND_OBJ *)0) {
   \   000097 A806                  MOVW      AX, [SP+0x06]      ;; 1 cycle
   \   000099 440000                CMPW      AX, #0x0           ;; 1 cycle
   \   00009C DD05                  BZ        ??OS_TaskRdy_57    ;; 4 cycles
   \   00009E                       ; ------------------------------------- Block: 10 cycles
   1869                           OS_PendListRemove(p_tcb);                       /* Remove task from wait list(s)                     */
   \   00009E A804                  MOVW      AX, [SP+0x04]      ;; 1 cycle
   \   0000A0 FD....                CALL      OS_PendListRemove  ;; 3 cycles
   \   0000A3                       ; ------------------------------------- Block: 4 cycles
   1870          #if OS_CFG_DBG_EN > 0u
   1871                           OS_PendDbgNameRemove(p_obj,
   1872                                                p_tcb);
   1873          #endif
   1874                       }
   1875                       p_tcb->TaskState  = OS_TASK_STATE_SUSPENDED;
   \                     ??OS_TaskRdy_57:
   \   0000A3 A804                  MOVW      AX, [SP+0x04]      ;; 1 cycle
   \   0000A5 16                    MOVW      HL, AX             ;; 1 cycle
   \   0000A6 5104                  MOV       A, #0x4            ;; 1 cycle
   \   0000A8 9C1C                  MOV       [HL+0x1C], A       ;; 1 cycle
   1876                       p_tcb->PendStatus = OS_STATUS_PEND_OK;              /* Clear pend status                                 */
   \   0000AA F1                    CLRB      A                  ;; 1 cycle
   \   0000AB                       ; ------------------------------------- Block: 5 cycles
   \                     ??OS_TaskRdy_55:
   \   0000AB 9C1B                  MOV       [HL+0x1B], A       ;; 1 cycle
   1877                       p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
   \   0000AD A800                  MOVW      AX, [SP]           ;; 1 cycle
   \   0000AF 16                    MOVW      HL, AX             ;; 1 cycle
   \   0000B0 F1                    CLRB      A                  ;; 1 cycle
   \   0000B1 9B                    MOV       [HL], A            ;; 1 cycle
   1878                       break;
   \   0000B2                       ; ------------------------------------- Block: 5 cycles
   1879          
   1880                  default:
   1881                       break;
   1882              }
   1883          }
   \                     ??OS_TaskRdy_52:
   \   0000B2 1008                  ADDW      SP, #0x8           ;; 1 cycle
   \   0000B4                       ; ------------------------------------- Block: 1 cycles
   \   0000B4                       ; ------------------------------------- Total: 144 cycles
   \   0000B4                       REQUIRE ?CLRL78_V1_0_L00
   \   0000B4                       REQUIRE ?Subroutine4
   \   0000B4                       ; // Fall through to label ?Subroutine4

   \                                 In  segment CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000 FD....                CALL      N:?FUNC_LEAVE_L06
   \   000003 0600                  DW        0x6                ;; 3 cycles
   \   000005                       ; ------------------------------------- Block: 3 cycles
   \   000005                       ; ------------------------------------- Total: 3 cycles
   \   000005                       REQUIRE ?CLRL78_V1_0_L00
   1884          
   1885          /*$PAGE*/
   1886          /*
   1887          ************************************************************************************************************************
   1888          *                                           POST TO A TASK PENDING ON MULTIPLE OBJECTS
   1889          *
   1890          * Description: This function is called when a task is pending on multiple objects and the object has been posted to.
   1891          *              This function needs to indicate to the caller which object was posted to by placing the address of the
   1892          *              object in the OS_PEND_DATA table corresponding to the posted object.
   1893          *
   1894          *              For example, if the task pends on six (6) objects, the address of those 6 objects are placed in the
   1895          *              .PendObjPtr field of the OS_PEND_DATA table as shown below.  Note that the .PendDataTblEntries would be
   1896          *              set to six (6) in this case.  As shown, when the pend call returns because a task or an ISR posted to
   1897          *              'Obj C' then, only the one entry contains the filled in data and the other entries contains NULL pointers
   1898          *              and zero data.
   1899          *
   1900          *              You should note that the NULL pointers are zero data values are actually filled in by the pend call.
   1901          *
   1902          *
   1903          *                                           .PendObjPtr    .RdyObjPtr     .RdyMsgPtr     .RdyMsgSize    .RdyTS
   1904          *                                         +--------------+--------------+--------------+--------------+--------------+
   1905          *              p_tcb->PendDataTblPtr  ->  |  Obj A       |  0           | 0            | 0            | 0            |
   1906          *                                         +--------------+--------------+--------------+--------------+--------------+
   1907          *                                         |  Obj B       |  0           | 0            | 0            | 0            |
   1908          *                                         +--------------+--------------+--------------+--------------+--------------+
   1909          *                                         |  Obj C       |  Obj C       | Msg Ptr      | Msg Size     | TS           |
   1910          *                                         +--------------+--------------+--------------+--------------+--------------+
   1911          *                                         |  Obj D       |  0           | 0            | 0            | 0            |
   1912          *                                         +--------------+--------------+--------------+--------------+--------------+
   1913          *                                         |  Obj E       |  0           | 0            | 0            | 0            |
   1914          *                                         +--------------+--------------+--------------+--------------+--------------+
   1915          *                                         |  Obj F       |  0           | 0            | 0            | 0            |
   1916          *                                         +--------------+--------------+--------------+--------------+--------------+
   1917          *
   1918          *
   1919          * Arguments  : p_obj        is a pointer to the object being posted to
   1920          *              -----
   1921          *
   1922          *              p_tcb        is the OS_TCB of the task receiving the signal or the message
   1923          *              -----
   1924          *
   1925          *              p_void       is the actual message (assuming posting to a message queue).  A NULL pointer otherwise.
   1926          *
   1927          *              msg_size     is the size of the message sent (if posted to a message queue)
   1928          *
   1929          *              ts           is the time stamp of when the post occurred
   1930          *
   1931          * Returns    : none
   1932          *
   1933          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1934          ************************************************************************************************************************
   1935          */
   1936          

   \                                 In  segment CODE, align 1, keep-with-next
   1937          void  OS_Post1 (OS_PEND_OBJ  *p_obj,
   \                     OS_Post1:
   1938                          OS_TCB       *p_tcb,
   1939                          void         *p_void,
   1940                          OS_MSG_SIZE   msg_size,
   1941                          CPU_TS        ts)
   1942          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 6
   \   000000 C1                    PUSH      AX                 ;; 1 cycle
   \   000001 C5                    PUSH      DE                 ;; 1 cycle
   \   000002                       ; Auto size: 4
   \   000002 C3                    PUSH      BC                 ;; 1 cycle
   \   000003 C6                    POP       HL                 ;; 1 cycle
   1943              OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
   1944              OS_PEND_DATA   *p_pend_data;
   1945          
   1946          
   1947          
   1948              p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
   \   000004 AC18                  MOVW      AX, [HL+0x18]      ;; 1 cycle
   \   000006 14                    MOVW      DE, AX             ;; 1 cycle
   1949              n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */
   \   000007 AC22                  MOVW      AX, [HL+0x22]      ;; 1 cycle
   \   000009 16                    MOVW      HL, AX             ;; 1 cycle
   \   00000A EF03                  BR        S:??CrossCallReturnLabel_13  ;; 3 cycles
   \   00000C                       ; ------------------------------------- Block: 11 cycles
   1950          
   1951              while (n_pend_list > (OS_OBJ_QTY)0) {                           /* Mark posted object in OS_PEND_DATA table       */
   1952                  if (p_obj == p_pend_data->PendObjPtr) {                     /* Did we find the object posted to?              */
   1953                      p_pend_data->RdyObjPtr  = p_obj;                        /* Yes, indicate the object in the .RdyObjPtr     */
   1954                      p_pend_data->RdyMsgPtr  = p_void;                       /*      store the message posted                  */
   1955                      p_pend_data->RdyMsgSize = msg_size;                     /*      store the size of the message posted      */
   1956                      p_pend_data->RdyTS      = ts;                           /*      save the timestamp of the post            */
   1957                      break;
   1958                  }
   1959                  p_pend_data++;
   \                     ??OS_Post1_0:
   \   00000C FD....                CALL      N:?Subroutine9     ;; 3 cycles
   1960                  n_pend_list--;
   \   00000F                       ; ------------------------------------- Block: 3 cycles
   \                     ??CrossCallReturnLabel_13:
   \   00000F 17                    MOVW      AX, HL             ;; 1 cycle
   \   000010 F7                    CLRW      BC                 ;; 1 cycle
   \   000011 43                    CMPW      AX, BC             ;; 1 cycle
   \   000012 DD1C                  BZ        ??OS_TaskRdy_58    ;; 4 cycles
   \   000014                       ; ------------------------------------- Block: 7 cycles
   \   000014 AA06                  MOVW      AX, [DE+0x06]      ;; 1 cycle
   \   000016 12                    MOVW      BC, AX             ;; 1 cycle
   \   000017 A802                  MOVW      AX, [SP+0x02]      ;; 1 cycle
   \   000019 43                    CMPW      AX, BC             ;; 1 cycle
   \   00001A DFF0                  BNZ       ??OS_Post1_0       ;; 4 cycles
   \   00001C                       ; ------------------------------------- Block: 8 cycles
   \   00001C BA08                  MOVW      [DE+0x08], AX      ;; 1 cycle
   \   00001E A800                  MOVW      AX, [SP]           ;; 1 cycle
   \   000020 BA0A                  MOVW      [DE+0x0A], AX      ;; 1 cycle
   \   000022 A808                  MOVW      AX, [SP+0x08]      ;; 1 cycle
   \   000024 BA0C                  MOVW      [DE+0x0C], AX      ;; 1 cycle
   \   000026 A80C                  MOVW      AX, [SP+0x0C]      ;; 1 cycle
   \   000028 12                    MOVW      BC, AX             ;; 1 cycle
   \   000029 A80A                  MOVW      AX, [SP+0x0A]      ;; 1 cycle
   \   00002B BA0E                  MOVW      [DE+0x0E], AX      ;; 1 cycle
   \   00002D 13                    MOVW      AX, BC             ;; 1 cycle
   \   00002E BA10                  MOVW      [DE+0x10], AX      ;; 1 cycle
   \   000030                       ; ------------------------------------- Block: 11 cycles
   1961              }
   1962          }
   \                     ??OS_TaskRdy_58:
   \   000030 1004                  ADDW      SP, #0x4           ;; 1 cycle
   \   000032 ED....                BR        N:?Subroutine4     ;; 3 cycles
   \   000035                       ; ------------------------------------- Block: 4 cycles
   \   000035                       ; ------------------------------------- Total: 44 cycles
   \   000035                       REQUIRE ?CLRL78_V1_0_L00
   1963          
   1964          /*$PAGE*/
   1965          /*
   1966          ************************************************************************************************************************
   1967          *                                                    INITIALIZATION
   1968          *                                               READY LIST INITIALIZATION
   1969          *
   1970          * Description: This function is called by OSInit() to initialize the ready list.  The ready list contains a list of all
   1971          *              the tasks that are ready to run.  The list is actually an array of OS_RDY_LIST.  An OS_RDY_LIST contains
   1972          *              three fields.  The number of OS_TCBs in the list (i.e. .NbrEntries), a pointer to the first OS_TCB in the
   1973          *              OS_RDY_LIST (i.e. .HeadPtr) and a pointer to the last OS_TCB in the OS_RDY_LIST (i.e. .TailPtr).
   1974          *
   1975          *              OS_TCBs are doubly linked in the OS_RDY_LIST and each OS_TCB points pack to the OS_RDY_LIST it belongs
   1976          *              to.
   1977          *
   1978          *              'OS_RDY_LIST  OSRdyTbl[OS_CFG_PRIO_MAX]'  looks like this once initialized:
   1979          *
   1980          *                               +---------------+--------------+
   1981          *                               |               | TailPtr      |-----> 0
   1982          *                          [0]  | NbrEntries=0  +--------------+
   1983          *                               |               | HeadPtr      |-----> 0
   1984          *                               +---------------+--------------+
   1985          *                               |               | TailPtr      |-----> 0
   1986          *                          [1]  | NbrEntries=0  +--------------+
   1987          *                               |               | HeadPtr      |-----> 0
   1988          *                               +---------------+--------------+
   1989          *                                       :              :
   1990          *                                       :              :
   1991          *                                       :              :
   1992          *                               +---------------+--------------+
   1993          *                               |               | TailPtr      |-----> 0
   1994          *          [OS_CFG_PRIO_MAX-1]  | NbrEntries=0  +--------------+
   1995          *                               |               | HeadPtr      |-----> 0
   1996          *                               +---------------+--------------+
   1997          *
   1998          *
   1999          * Arguments  : none
   2000          *
   2001          * Returns    : none
   2002          *
   2003          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   2004          ************************************************************************************************************************
   2005          */
   2006          

   \                                 In  segment CODE, align 1, keep-with-next
   2007          void  OS_RdyListInit (void)
   \                     OS_RdyListInit:
   2008          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000 C3                    PUSH      BC                 ;; 1 cycle
   \   000001 C5                    PUSH      DE                 ;; 1 cycle
   \   000002                       ; Auto size: 0
   2009              OS_PRIO       i;
   2010              OS_RDY_LIST  *p_rdy_list;
   2011          
   2012          
   2013          
   2014              for (i = 0u; i < OS_CFG_PRIO_MAX; i++) {                /* Initialize the array of OS_RDY_LIST at each priority   */
   \   000002 5400                  MOV       E, #0x0            ;; 1 cycle
   \   000004                       ; ------------------------------------- Block: 3 cycles
   2015                  p_rdy_list = &OSRdyList[i];
   \                     ??OS_RdyListInit_0:
   \   000004 64                    MOV       A, E               ;; 1 cycle
   \   000005 70                    MOV       X, A               ;; 1 cycle
   \   000006 F1                    CLRB      A                  ;; 1 cycle
   \   000007 320600                MOVW      BC, #0x6           ;; 1 cycle
   \   00000A CEFB01                MULHU                        ;; 2 cycles
   \   00000D 04....                ADDW      AX, #OSRdyList     ;; 1 cycle
   \   000010 16                    MOVW      HL, AX             ;; 1 cycle
   2016                  p_rdy_list->NbrEntries = (OS_OBJ_QTY)0;
   \   000011 F6                    CLRW      AX                 ;; 1 cycle
   \   000012 BC04                  MOVW      [HL+0x04], AX      ;; 1 cycle
   2017                  p_rdy_list->HeadPtr    = (OS_TCB   *)0;
   \   000014 BB                    MOVW      [HL], AX           ;; 1 cycle
   2018                  p_rdy_list->TailPtr    = (OS_TCB   *)0;
   \   000015 BC02                  MOVW      [HL+0x02], AX      ;; 1 cycle
   2019              }
   \   000017 84                    INC       E                  ;; 1 cycle
   \   000018 64                    MOV       A, E               ;; 1 cycle
   \   000019 4C08                  CMP       A, #0x8            ;; 1 cycle
   \   00001B DCE7                  BC        ??OS_RdyListInit_0  ;; 4 cycles
   \   00001D                       ; ------------------------------------- Block: 19 cycles
   2020          }
   \   00001D C4                    POP       DE                 ;; 1 cycle
   \   00001E C2                    POP       BC                 ;; 1 cycle
   \   00001F D7                    RET                          ;; 6 cycles
   \   000020                       ; ------------------------------------- Block: 8 cycles
   \   000020                       ; ------------------------------------- Total: 30 cycles
   \   000020                       REQUIRE ?CLRL78_V1_0_L00
   2021          
   2022          /*$PAGE*/
   2023          /*
   2024          ************************************************************************************************************************
   2025          *                                             INSERT TCB IN THE READY LIST
   2026          *
   2027          * Description: This function is called to insert a TCB in the ready list.
   2028          *
   2029          *              The TCB is inserted at the tail of the list if the priority of the TCB is the same as the priority of the
   2030          *              current task.  The TCB is inserted at the head of the list if not.
   2031          *
   2032          * Arguments  : p_tcb     is a pointer to the TCB to insert into the ready list
   2033          *              -----
   2034          *
   2035          * Returns    : none
   2036          *
   2037          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   2038          ************************************************************************************************************************
   2039          */
   2040          

   \                                 In  segment CODE, align 1, keep-with-next
   2041          void  OS_RdyListInsert (OS_TCB *p_tcb)
   \                     OS_RdyListInsert:
   2042          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000 C5                    PUSH      DE                 ;; 1 cycle
   \   000001                       ; Auto size: 0
   \   000001 14                    MOVW      DE, AX             ;; 1 cycle
   2043              OS_PrioInsert(p_tcb->Prio);
   \   000002 8A1D                  MOV       A, [DE+0x1D]       ;; 1 cycle
   \   000004 FD....                CALL      OS_PrioInsert      ;; 3 cycles
   2044              if (p_tcb->Prio == OSPrioCur) {                         /* Are we readying a task at the same prio?               */
   \   000007 8A1D                  MOV       A, [DE+0x1D]       ;; 1 cycle
   \   000009 4F....                CMP       A, N:OSPrioCur     ;; 1 cycle
   \   00000C 15                    MOVW      AX, DE             ;; 1 cycle
   \   00000D DF05                  BNZ       ??OS_TaskRdy_59    ;; 4 cycles
   \   00000F                       ; ------------------------------------- Block: 13 cycles
   2045                  OS_RdyListInsertTail(p_tcb);                        /* Yes, insert readied task at the end of the list        */
   \   00000F FD....                CALL      OS_RdyListInsertTail  ;; 3 cycles
   \   000012 EF03                  BR        S:??OS_TaskRdy_60  ;; 3 cycles
   \   000014                       ; ------------------------------------- Block: 6 cycles
   2046              } else {
   2047                  OS_RdyListInsertHead(p_tcb);                        /* No,  insert readied task at the beginning of the list  */
   \                     ??OS_TaskRdy_59:
   \   000014 FD....                CALL      OS_RdyListInsertHead  ;; 3 cycles
   \   000017                       ; ------------------------------------- Block: 3 cycles
   2048              }
   2049          }
   \                     ??OS_TaskRdy_60:
   \   000017 C4                    POP       DE                 ;; 1 cycle
   \   000018 D7                    RET                          ;; 6 cycles
   \   000019                       ; ------------------------------------- Block: 7 cycles
   \   000019                       ; ------------------------------------- Total: 29 cycles
   \   000019                       REQUIRE ?CLRL78_V1_0_L00
   2050          
   2051          
   2052          /*
   2053          ************************************************************************************************************************
   2054          *                                          INSERT TCB AT THE BEGINNING OF A LIST
   2055          *
   2056          * Description: This function is called to place an OS_TCB at the beginning of a linked list as follows:
   2057          *
   2058          *              CASE 0: Insert in an empty list.
   2059          *
   2060          *                     OS_RDY_LIST
   2061          *                     +--------------+
   2062          *                     | TailPtr      |-> 0
   2063          *                     +--------------+
   2064          *                     | HeadPtr      |-> 0
   2065          *                     +--------------+
   2066          *                     | NbrEntries=0 |
   2067          *                     +--------------+
   2068          *
   2069          *
   2070          *
   2071          *              CASE 1: Insert BEFORE the current head of list
   2072          *
   2073          *                     OS_RDY_LIST
   2074          *                     +--------------+          OS_TCB
   2075          *                     | TailPtr      |--+---> +------------+
   2076          *                     +--------------+  |     | NextPtr    |->0
   2077          *                     | HeadPtr      |--/     +------------+
   2078          *                     +--------------+     0<-| PrevPtr    |
   2079          *                     | NbrEntries=1 |        +------------+
   2080          *                     +--------------+        :            :
   2081          *                                             :            :
   2082          *                                             +------------+
   2083          *
   2084          *
   2085          *                     OS_RDY_LIST
   2086          *                     +--------------+
   2087          *                     | TailPtr      |-----------------------------------------------+
   2088          *                     +--------------+          OS_TCB               OS_TCB          |     OS_TCB
   2089          *                     | HeadPtr      |------> +------------+       +------------+    +-> +------------+
   2090          *                     +--------------+        | NextPtr    |------>| NextPtr    | ...... | NextPtr    |->0
   2091          *                     | NbrEntries=N |        +------------+       +------------+        +------------+
   2092          *                     +--------------+     0<-| PrevPtr    |<------| PrevPtr    | ...... | PrevPtr    |
   2093          *                                             +------------+       +------------+        +------------+
   2094          *                                             :            :       :            :        :            :
   2095          *                                             :            :       :            :        :            :
   2096          *                                             +------------+       +------------+        +------------+
   2097          *
   2098          *
   2099          * Arguments  : p_tcb     is the OS_TCB to insert in the list
   2100          *              -----
   2101          *
   2102          * Returns    : none
   2103          *
   2104          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   2105          ************************************************************************************************************************
   2106          */
   2107          

   \                                 In  segment CODE, align 1, keep-with-next
   2108          void  OS_RdyListInsertHead (OS_TCB  *p_tcb)
   \                     OS_RdyListInsertHead:
   2109          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000 C3                    PUSH      BC                 ;; 1 cycle
   \   000001 C5                    PUSH      DE                 ;; 1 cycle
   \   000002                       ; Auto size: 2
   \   000002 C1                    PUSH      AX                 ;; 1 cycle
   \   000003 FD....                CALL      N:?Subroutine5     ;; 3 cycles
   \   000006                       ; ------------------------------------- Block: 6 cycles
   2110              OS_RDY_LIST  *p_rdy_list;
   2111              OS_TCB       *p_tcb2;
   2112          
   2113          
   2114          
   2115              p_rdy_list = &OSRdyList[p_tcb->Prio];
   \                     ??CrossCallReturnLabel_0:
   \   000006 CEFB01                MULHU                        ;; 2 cycles
   \   000009 04....                ADDW      AX, #OSRdyList     ;; 1 cycle
   \   00000C B800                  MOVW      [SP], AX           ;; 1 cycle
   2116              if (p_rdy_list->NbrEntries == (OS_OBJ_QTY)0) {          /* CASE 0: Insert when there are no entries               */
   \   00000E FD....                CALL      N:?Subroutine8     ;; 3 cycles
   \   000011                       ; ------------------------------------- Block: 7 cycles
   \                     ??CrossCallReturnLabel_9:
   \   000011 DF10                  BNZ       ??OS_TaskRdy_61    ;; 4 cycles
   \   000013                       ; ------------------------------------- Block: 4 cycles
   2117                  p_rdy_list->NbrEntries =  (OS_OBJ_QTY)1;            /*         This is the first entry                        */
   \   000013 E6                    ONEW      AX                 ;; 1 cycle
   \   000014 BB                    MOVW      [HL], AX           ;; 1 cycle
   2118                  p_tcb->NextPtr         =  (OS_TCB   *)0;            /*         No other OS_TCBs in the list                   */
   \   000015 F6                    CLRW      AX                 ;; 1 cycle
   \   000016 BA06                  MOVW      [DE+0x06], AX      ;; 1 cycle
   2119                  p_tcb->PrevPtr         =  (OS_TCB   *)0;
   \   000018 BA08                  MOVW      [DE+0x08], AX      ;; 1 cycle
   2120                  p_rdy_list->HeadPtr    =  p_tcb;                    /*         Both list pointers point to this OS_TCB        */
   \   00001A A800                  MOVW      AX, [SP]           ;; 1 cycle
   \   00001C 16                    MOVW      HL, AX             ;; 1 cycle
   \   00001D 15                    MOVW      AX, DE             ;; 1 cycle
   \   00001E BB                    MOVW      [HL], AX           ;; 1 cycle
   2121                  p_rdy_list->TailPtr    =  p_tcb;
   \   00001F BC02                  MOVW      [HL+0x02], AX      ;; 1 cycle
   \   000021 EF15                  BR        S:??OS_TaskRdy_62  ;; 3 cycles
   \   000023                       ; ------------------------------------- Block: 13 cycles
   2122              } else {                                                /* CASE 1: Insert BEFORE the current head of list         */
   2123                  p_rdy_list->NbrEntries++;                           /*         One more OS_TCB in the list                    */
   \                     ??OS_TaskRdy_61:
   \   000023 A1                    INCW      AX                 ;; 1 cycle
   \   000024 BB                    MOVW      [HL], AX           ;; 1 cycle
   2124                  p_tcb->NextPtr         = p_rdy_list->HeadPtr;       /*         Adjust new OS_TCBs links                       */
   \   000025 A800                  MOVW      AX, [SP]           ;; 1 cycle
   \   000027 16                    MOVW      HL, AX             ;; 1 cycle
   \   000028 AB                    MOVW      AX, [HL]           ;; 1 cycle
   \   000029 BA06                  MOVW      [DE+0x06], AX      ;; 1 cycle
   2125                  p_tcb->PrevPtr         = (OS_TCB    *)0;
   \   00002B F6                    CLRW      AX                 ;; 1 cycle
   \   00002C BA08                  MOVW      [DE+0x08], AX      ;; 1 cycle
   2126                  p_tcb2                 = p_rdy_list->HeadPtr;       /*         Adjust old head of list's links                */
   2127                  p_tcb2->PrevPtr        = p_tcb;
   \   00002E AB                    MOVW      AX, [HL]           ;; 1 cycle
   \   00002F 16                    MOVW      HL, AX             ;; 1 cycle
   \   000030 15                    MOVW      AX, DE             ;; 1 cycle
   \   000031 BC08                  MOVW      [HL+0x08], AX      ;; 1 cycle
   2128                  p_rdy_list->HeadPtr    = p_tcb;
   \   000033 A800                  MOVW      AX, [SP]           ;; 1 cycle
   \   000035 16                    MOVW      HL, AX             ;; 1 cycle
   \   000036 15                    MOVW      AX, DE             ;; 1 cycle
   \   000037 BB                    MOVW      [HL], AX           ;; 1 cycle
   \   000038                       ; ------------------------------------- Block: 16 cycles
   2129              }
   2130          }
   \                     ??OS_TaskRdy_62:
   \   000038                       REQUIRE ?CLRL78_V1_0_L00
   \   000038                       REQUIRE ?Subroutine1
   \   000038                       ; // Fall through to label ?Subroutine1

   \                                 In  segment CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000 1002                  ADDW      SP, #0x2           ;; 1 cycle
   \   000002 C4                    POP       DE                 ;; 1 cycle
   \   000003 C2                    POP       BC                 ;; 1 cycle
   \   000004 D7                    RET                          ;; 6 cycles
   \   000005                       ; ------------------------------------- Block: 9 cycles
   \   000005                       ; ------------------------------------- Total: 9 cycles
   \   000005                       REQUIRE ?CLRL78_V1_0_L00

   \                                 In  segment CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000 16                    MOVW      HL, AX             ;; 1 cycle
   \   000001 A7                    INCW      HL                 ;; 1 cycle
   \   000002 A7                    INCW      HL                 ;; 1 cycle
   \   000003 A7                    INCW      HL                 ;; 1 cycle
   \   000004 A7                    INCW      HL                 ;; 1 cycle
   \   000005 AB                    MOVW      AX, [HL]           ;; 1 cycle
   \   000006 F7                    CLRW      BC                 ;; 1 cycle
   \   000007 43                    CMPW      AX, BC             ;; 1 cycle
   \   000008 D7                    RET                          ;; 6 cycles
   \   000009                       ; ------------------------------------- Block: 14 cycles
   \   000009                       ; ------------------------------------- Total: 14 cycles
   \   000009                       REQUIRE ?CLRL78_V1_0_L00

   \                                 In  segment CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000 14                    MOVW      DE, AX             ;; 1 cycle
   \   000001 8A1D                  MOV       A, [DE+0x1D]       ;; 1 cycle
   \   000003 70                    MOV       X, A               ;; 1 cycle
   \   000004 F1                    CLRB      A                  ;; 1 cycle
   \   000005 320600                MOVW      BC, #0x6           ;; 1 cycle
   \   000008 D7                    RET                          ;; 6 cycles
   \   000009                       ; ------------------------------------- Block: 11 cycles
   \   000009                       ; ------------------------------------- Total: 11 cycles
   \   000009                       REQUIRE ?CLRL78_V1_0_L00
   2131          
   2132          /*$PAGE*/
   2133          /*
   2134          ************************************************************************************************************************
   2135          *                                           INSERT TCB AT THE END OF A LIST
   2136          *
   2137          * Description: This function is called to place an OS_TCB at the end of a linked list as follows:
   2138          *
   2139          *              CASE 0: Insert in an empty list.
   2140          *
   2141          *                     OS_RDY_LIST
   2142          *                     +--------------+
   2143          *                     | TailPtr      |-> 0
   2144          *                     +--------------+
   2145          *                     | HeadPtr      |-> 0
   2146          *                     +--------------+
   2147          *                     | NbrEntries=0 |
   2148          *                     +--------------+
   2149          *
   2150          *
   2151          *
   2152          *              CASE 1: Insert AFTER the current tail of list
   2153          *
   2154          *                     OS_RDY_LIST
   2155          *                     +--------------+          OS_TCB
   2156          *                     | TailPtr      |--+---> +------------+
   2157          *                     +--------------+  |     | NextPtr    |->0
   2158          *                     | HeadPtr      |--/     +------------+
   2159          *                     +--------------+     0<-| PrevPtr    |
   2160          *                     | NbrEntries=1 |        +------------+
   2161          *                     +--------------+        :            :
   2162          *                                             :            :
   2163          *                                             +------------+
   2164          *
   2165          *
   2166          *                     OS_RDY_LIST
   2167          *                     +--------------+
   2168          *                     | TailPtr      |-----------------------------------------------+
   2169          *                     +--------------+          OS_TCB               OS_TCB          |     OS_TCB
   2170          *                     | HeadPtr      |------> +------------+       +------------+    +-> +------------+
   2171          *                     +--------------+        | NextPtr    |------>| NextPtr    | ...... | NextPtr    |->0
   2172          *                     | NbrEntries=N |        +------------+       +------------+        +------------+
   2173          *                     +--------------+     0<-| PrevPtr    |<------| PrevPtr    | ...... | PrevPtr    |
   2174          *                                             +------------+       +------------+        +------------+
   2175          *                                             :            :       :            :        :            :
   2176          *                                             :            :       :            :        :            :
   2177          *                                             +------------+       +------------+        +------------+
   2178          *
   2179          *
   2180          * Arguments  : p_tcb     is the OS_TCB to insert in the list
   2181          *              -----
   2182          *
   2183          * Returns    : none
   2184          *
   2185          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   2186          ************************************************************************************************************************
   2187          */
   2188          

   \                                 In  segment CODE, align 1, keep-with-next
   2189          void  OS_RdyListInsertTail (OS_TCB  *p_tcb)
   \                     OS_RdyListInsertTail:
   2190          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000 C3                    PUSH      BC                 ;; 1 cycle
   \   000001 C5                    PUSH      DE                 ;; 1 cycle
   \   000002                       ; Auto size: 2
   \   000002 C1                    PUSH      AX                 ;; 1 cycle
   \   000003 FD....                CALL      N:?Subroutine5     ;; 3 cycles
   \   000006                       ; ------------------------------------- Block: 6 cycles
   2191              OS_RDY_LIST  *p_rdy_list;
   2192              OS_TCB       *p_tcb2;
   2193          
   2194          
   2195          
   2196              p_rdy_list = &OSRdyList[p_tcb->Prio];
   \                     ??CrossCallReturnLabel_1:
   \   000006 CEFB01                MULHU                        ;; 2 cycles
   \   000009 04....                ADDW      AX, #OSRdyList     ;; 1 cycle
   \   00000C B800                  MOVW      [SP], AX           ;; 1 cycle
   2197              if (p_rdy_list->NbrEntries == (OS_OBJ_QTY)0) {          /* CASE 0: Insert when there are no entries               */
   \   00000E FD....                CALL      N:?Subroutine8     ;; 3 cycles
   \   000011                       ; ------------------------------------- Block: 7 cycles
   \                     ??CrossCallReturnLabel_10:
   \   000011 DF0E                  BNZ       ??OS_TaskRdy_63    ;; 4 cycles
   \   000013                       ; ------------------------------------- Block: 4 cycles
   2198                  p_rdy_list->NbrEntries  = (OS_OBJ_QTY)1;            /*         This is the first entry                        */
   \   000013 E6                    ONEW      AX                 ;; 1 cycle
   \   000014 BB                    MOVW      [HL], AX           ;; 1 cycle
   2199                  p_tcb->NextPtr          = (OS_TCB   *)0;            /*         No other OS_TCBs in the list                   */
   \   000015 F6                    CLRW      AX                 ;; 1 cycle
   \   000016 BA06                  MOVW      [DE+0x06], AX      ;; 1 cycle
   2200                  p_tcb->PrevPtr          = (OS_TCB   *)0;
   \   000018 BA08                  MOVW      [DE+0x08], AX      ;; 1 cycle
   2201                  p_rdy_list->HeadPtr     = p_tcb;                    /*         Both list pointers point to this OS_TCB        */
   \   00001A A800                  MOVW      AX, [SP]           ;; 1 cycle
   \   00001C 16                    MOVW      HL, AX             ;; 1 cycle
   \   00001D 15                    MOVW      AX, DE             ;; 1 cycle
   \   00001E BB                    MOVW      [HL], AX           ;; 1 cycle
   2202                  p_rdy_list->TailPtr     = p_tcb;
   \   00001F EF14                  BR        S:??OS_TaskRdy_64  ;; 3 cycles
   \   000021                       ; ------------------------------------- Block: 12 cycles
   2203              } else {                                                /* CASE 1: Insert AFTER the current tail of list          */
   2204                  p_rdy_list->NbrEntries++;                           /*         One more OS_TCB in the list                    */
   \                     ??OS_TaskRdy_63:
   \   000021 A1                    INCW      AX                 ;; 1 cycle
   \   000022 BB                    MOVW      [HL], AX           ;; 1 cycle
   2205                  p_tcb->NextPtr          = (OS_TCB   *)0;            /*         Adjust new OS_TCBs links                       */
   \   000023 F6                    CLRW      AX                 ;; 1 cycle
   \   000024 BA06                  MOVW      [DE+0x06], AX      ;; 1 cycle
   2206                  p_tcb2                  = p_rdy_list->TailPtr;
   \   000026 A800                  MOVW      AX, [SP]           ;; 1 cycle
   \   000028 16                    MOVW      HL, AX             ;; 1 cycle
   \   000029 AC02                  MOVW      AX, [HL+0x02]      ;; 1 cycle
   \   00002B 16                    MOVW      HL, AX             ;; 1 cycle
   2207                  p_tcb->PrevPtr          = p_tcb2;
   \   00002C BA08                  MOVW      [DE+0x08], AX      ;; 1 cycle
   2208                  p_tcb2->NextPtr         = p_tcb;                    /*         Adjust old tail of list's links                */
   \   00002E 15                    MOVW      AX, DE             ;; 1 cycle
   \   00002F BC06                  MOVW      [HL+0x06], AX      ;; 1 cycle
   2209                  p_rdy_list->TailPtr     = p_tcb;
   \   000031 A800                  MOVW      AX, [SP]           ;; 1 cycle
   \   000033 16                    MOVW      HL, AX             ;; 1 cycle
   \   000034 15                    MOVW      AX, DE             ;; 1 cycle
   \   000035                       ; ------------------------------------- Block: 14 cycles
   \                     ??OS_TaskRdy_64:
   \   000035 BC02                  MOVW      [HL+0x02], AX      ;; 1 cycle
   2210              }
   2211          }
   \   000037 ED....                BR        N:?Subroutine1     ;; 3 cycles
   \   00003A                       ; ------------------------------------- Block: 4 cycles
   \   00003A                       ; ------------------------------------- Total: 47 cycles
   \   00003A                       REQUIRE ?CLRL78_V1_0_L00
   2212          
   2213          /*$PAGE*/
   2214          /*
   2215          ************************************************************************************************************************
   2216          *                                                MOVE TCB AT HEAD TO TAIL
   2217          *
   2218          * Description: This function is called to move the current head of a list to the tail of the list.
   2219          *
   2220          *
   2221          *              CASE 0: TCB list is empty, nothing to do.
   2222          *
   2223          *              CASE 1: Only 1 OS_TCB  in the list, nothing to do.
   2224          *
   2225          *              CASE 2: Only 2 OS_TCBs in the list.
   2226          *
   2227          *                     OS_RDY_LIST
   2228          *                     +--------------+
   2229          *                     | TailPtr      |--------------------------+
   2230          *                     +--------------+          OS_TCB          |     OS_TCB
   2231          *                     | HeadPtr      |------> +------------+    +-> +------------+
   2232          *                     +--------------+        | NextPtr    |------> | NextPtr    |->0
   2233          *                     | NbrEntries=2 |        +------------+        +------------+
   2234          *                     +--------------+     0<-| PrevPtr    | <------| PrevPtr    |
   2235          *                                             +------------+        +------------+
   2236          *                                             :            :        :            :
   2237          *                                             :            :        :            :
   2238          *                                             +------------+        +------------+
   2239          *
   2240          *
   2241          *              CASE N: More than 2 OS_TCBs in the list.
   2242          *
   2243          *                     OS_RDY_LIST
   2244          *                     +--------------+
   2245          *                     | TailPtr      |-----------------------------------------------+
   2246          *                     +--------------+          OS_TCB               OS_TCB          |     OS_TCB
   2247          *                     | HeadPtr      |------> +------------+       +------------+    +-> +------------+
   2248          *                     +--------------+        | NextPtr    |------>| NextPtr    | ...... | NextPtr    |->0
   2249          *                     | NbrEntries=N |        +------------+       +------------+        +------------+
   2250          *                     +--------------+     0<-| PrevPtr    |<------| PrevPtr    | ...... | PrevPtr    |
   2251          *                                             +------------+       +------------+        +------------+
   2252          *                                             :            :       :            :        :            :
   2253          *                                             :            :       :            :        :            :
   2254          *                                             +------------+       +------------+        +------------+
   2255          *
   2256          *
   2257          * Arguments  : p_list    is a pointer to the OS_RDY_LIST where the OS_TCB will be inserted
   2258          *              ------
   2259          *
   2260          * Returns    : none
   2261          *
   2262          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   2263          ************************************************************************************************************************
   2264          */
   2265          

   \                                 In  segment CODE, align 1, keep-with-next
   2266          void  OS_RdyListMoveHeadToTail (OS_RDY_LIST  *p_rdy_list)
   \                     OS_RdyListMoveHeadToTail:
   2267          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000 C3                    PUSH      BC                 ;; 1 cycle
   \   000001 C5                    PUSH      DE                 ;; 1 cycle
   \   000002 C1                    PUSH      AX                 ;; 1 cycle
   \   000003                       ; Auto size: 8
   \   000003 2006                  SUBW      SP, #0x6           ;; 1 cycle
   2268              OS_TCB  *p_tcb1;
   2269              OS_TCB  *p_tcb2;
   2270              OS_TCB  *p_tcb3;
   2271          
   2272          
   2273          
   2274              switch (p_rdy_list->NbrEntries) {
   \   000005 16                    MOVW      HL, AX             ;; 1 cycle
   \   000006 AC04                  MOVW      AX, [HL+0x04]      ;; 1 cycle
   \   000008 440200                CMPW      AX, #0x2           ;; 1 cycle
   \   00000B DC3E                  BC        ??OS_TaskRdy_65    ;; 4 cycles
   \   00000D                       ; ------------------------------------- Block: 11 cycles
   \   00000D AB                    MOVW      AX, [HL]           ;; 1 cycle
   \   00000E 14                    MOVW      DE, AX             ;; 1 cycle
   \   00000F 17                    MOVW      AX, HL             ;; 1 cycle
   \   000010 A1                    INCW      AX                 ;; 1 cycle
   \   000011 A1                    INCW      AX                 ;; 1 cycle
   \   000012 B802                  MOVW      [SP+0x02], AX      ;; 1 cycle
   \   000014 A7                    INCW      HL                 ;; 1 cycle
   \   000015 A7                    INCW      HL                 ;; 1 cycle
   \   000016 AB                    MOVW      AX, [HL]           ;; 1 cycle
   \   000017 B800                  MOVW      [SP], AX           ;; 1 cycle
   \   000019 DF12                  BNZ       ??OS_TaskRdy_66    ;; 4 cycles
   \   00001B                       ; ------------------------------------- Block: 14 cycles
   2275                  case 0:
   2276                  case 1:
   2277                       break;
   2278          
   2279                  case 2:                                             /* SWAP the TCBs                                          */
   2280                       p_tcb1              = p_rdy_list->HeadPtr;     /* Point to current head                                  */
   2281                       p_tcb2              = p_rdy_list->TailPtr;     /* Point to current tail                                  */
   2282                       p_tcb1->PrevPtr     = p_tcb2;
   \   00001B BA08                  MOVW      [DE+0x08], AX      ;; 1 cycle
   2283                       p_tcb1->NextPtr     = (OS_TCB *)0;
   \   00001D F6                    CLRW      AX                 ;; 1 cycle
   \   00001E BA06                  MOVW      [DE+0x06], AX      ;; 1 cycle
   2284                       p_tcb2->PrevPtr     = (OS_TCB *)0;
   \   000020 A800                  MOVW      AX, [SP]           ;; 1 cycle
   \   000022 16                    MOVW      HL, AX             ;; 1 cycle
   \   000023 F6                    CLRW      AX                 ;; 1 cycle
   \   000024 BC08                  MOVW      [HL+0x08], AX      ;; 1 cycle
   2285                       p_tcb2->NextPtr     = p_tcb1;
   \   000026 17                    MOVW      AX, HL             ;; 1 cycle
   \   000027 35                    XCHW      AX, DE             ;; 1 cycle
   \   000028 BC06                  MOVW      [HL+0x06], AX      ;; 1 cycle
   \   00002A 35                    XCHW      AX, DE             ;; 1 cycle
   2286                       p_rdy_list->HeadPtr = p_tcb2;
   \   00002B EF14                  BR        S:??OS_TaskRdy_67  ;; 3 cycles
   \   00002D                       ; ------------------------------------- Block: 14 cycles
   2287                       p_rdy_list->TailPtr = p_tcb1;
   2288                       break;
   2289          
   2290                  default:                                            /* Move only if there are more than 2 OS_TCBs in the list */
   2291                       p_tcb1              = p_rdy_list->HeadPtr;     /* Point to current head                                  */
   2292                       p_tcb2              = p_rdy_list->TailPtr;     /* Point to current tail                                  */
   2293                       p_tcb3              = p_tcb1->NextPtr;         /* Point to new list head                                 */
   \                     ??OS_TaskRdy_66:
   \   00002D AA06                  MOVW      AX, [DE+0x06]      ;; 1 cycle
   \   00002F B804                  MOVW      [SP+0x04], AX      ;; 1 cycle
   2294                       p_tcb3->PrevPtr     = (OS_TCB *)0;             /* Adjust back    link of new list head                   */
   \   000031 16                    MOVW      HL, AX             ;; 1 cycle
   \   000032 F6                    CLRW      AX                 ;; 1 cycle
   \   000033 BC08                  MOVW      [HL+0x08], AX      ;; 1 cycle
   2295                       p_tcb1->NextPtr     = (OS_TCB *)0;             /* Adjust forward link of new list tail                   */
   \   000035 BA06                  MOVW      [DE+0x06], AX      ;; 1 cycle
   2296                       p_tcb1->PrevPtr     = p_tcb2;                  /* Adjust back    link of new list tail                   */
   \   000037 A800                  MOVW      AX, [SP]           ;; 1 cycle
   \   000039 BA08                  MOVW      [DE+0x08], AX      ;; 1 cycle
   2297                       p_tcb2->NextPtr     = p_tcb1;                  /* Adjust forward link of old list tail                   */
   \   00003B 16                    MOVW      HL, AX             ;; 1 cycle
   \   00003C 15                    MOVW      AX, DE             ;; 1 cycle
   \   00003D BC06                  MOVW      [HL+0x06], AX      ;; 1 cycle
   2298                       p_rdy_list->HeadPtr = p_tcb3;                  /* Adjust new list head and tail pointers                 */
   \   00003F A804                  MOVW      AX, [SP+0x04]      ;; 1 cycle
   \   000041                       ; ------------------------------------- Block: 12 cycles
   \                     ??OS_TaskRdy_67:
   \   000041 12                    MOVW      BC, AX             ;; 1 cycle
   \   000042 A806                  MOVW      AX, [SP+0x06]      ;; 1 cycle
   \   000044 16                    MOVW      HL, AX             ;; 1 cycle
   \   000045 13                    MOVW      AX, BC             ;; 1 cycle
   \   000046 BB                    MOVW      [HL], AX           ;; 1 cycle
   2299                       p_rdy_list->TailPtr = p_tcb1;
   \   000047 A7                    INCW      HL                 ;; 1 cycle
   \   000048 A7                    INCW      HL                 ;; 1 cycle
   \   000049 15                    MOVW      AX, DE             ;; 1 cycle
   \   00004A BB                    MOVW      [HL], AX           ;; 1 cycle
   2300                       break;
   \   00004B                       ; ------------------------------------- Block: 9 cycles
   2301              }
   2302          }
   \                     ??OS_TaskRdy_65:
   \   00004B                       REQUIRE ?CLRL78_V1_0_L00
   \   00004B                       REQUIRE ?Subroutine2
   \   00004B                       ; // Fall through to label ?Subroutine2

   \                                 In  segment CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000 1008                  ADDW      SP, #0x8           ;; 1 cycle
   \   000002 C4                    POP       DE                 ;; 1 cycle
   \   000003 C2                    POP       BC                 ;; 1 cycle
   \   000004 D7                    RET                          ;; 6 cycles
   \   000005                       ; ------------------------------------- Block: 9 cycles
   \   000005                       ; ------------------------------------- Total: 9 cycles
   \   000005                       REQUIRE ?CLRL78_V1_0_L00
   2303          
   2304          /*$PAGE*/
   2305          /*
   2306          ************************************************************************************************************************
   2307          *                                REMOVE TCB FROM LIST KNOWING ONLY WHICH OS_TCB TO REMOVE
   2308          *
   2309          * Description: This function is called to remove an OS_TCB from an OS_RDY_LIST knowing the address of the OS_TCB to
   2310          *              remove.
   2311          *
   2312          *
   2313          *              CASE 0: TCB list is empty, nothing to do.
   2314          *
   2315          *              CASE 1: Only 1 OS_TCBs in the list.
   2316          *
   2317          *                     OS_RDY_LIST
   2318          *                     +--------------+          OS_TCB
   2319          *                     | TailPtr      |--+---> +------------+
   2320          *                     +--------------+  |     | NextPtr    |->0
   2321          *                     | HeadPtr      |--/     +------------+
   2322          *                     +--------------+     0<-| PrevPtr    |
   2323          *                     | NbrEntries=1 |        +------------+
   2324          *                     +--------------+        :            :
   2325          *                                             :            :
   2326          *                                             +------------+
   2327          *
   2328          *              CASE N: Two or more OS_TCBs in the list.
   2329          *
   2330          *                     OS_RDY_LIST
   2331          *                     +--------------+
   2332          *                     | TailPtr      |-----------------------------------------------+
   2333          *                     +--------------+          OS_TCB               OS_TCB          |     OS_TCB
   2334          *                     | HeadPtr      |------> +------------+       +------------+    +-> +------------+
   2335          *                     +--------------+        | NextPtr    |------>| NextPtr    | ...... | NextPtr    |->0
   2336          *                     | NbrEntries=N |        +------------+       +------------+        +------------+
   2337          *                     +--------------+     0<-| PrevPtr    |<------| PrevPtr    | ...... | PrevPtr    |
   2338          *                                             +------------+       +------------+        +------------+
   2339          *                                             :            :       :            :        :            :
   2340          *                                             :            :       :            :        :            :
   2341          *                                             +------------+       +------------+        +------------+
   2342          *
   2343          *
   2344          * Arguments  : p_tcb    is a pointer to the OS_TCB to remove
   2345          *              -----
   2346          *
   2347          * Returns    : A pointer to the OS_RDY_LIST where the OS_TCB was
   2348          *
   2349          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   2350          ************************************************************************************************************************
   2351          */
   2352          

   \                                 In  segment CODE, align 1, keep-with-next
   2353          void  OS_RdyListRemove (OS_TCB *p_tcb)
   \                     OS_RdyListRemove:
   2354          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000 C3                    PUSH      BC                 ;; 1 cycle
   \   000001 C5                    PUSH      DE                 ;; 1 cycle
   \   000002                       ; Auto size: 8
   \   000002 2008                  SUBW      SP, #0x8           ;; 1 cycle
   \   000004 FD....                CALL      N:?Subroutine5     ;; 3 cycles
   \   000007                       ; ------------------------------------- Block: 6 cycles
   2355              OS_RDY_LIST  *p_rdy_list;
   2356              OS_TCB       *p_tcb1;
   2357              OS_TCB       *p_tcb2;
   2358          
   2359          
   2360          
   2361              p_rdy_list = &OSRdyList[p_tcb->Prio];
   \                     ??CrossCallReturnLabel_2:
   \   000007 CEFB01                MULHU                        ;; 2 cycles
   \   00000A 04....                ADDW      AX, #OSRdyList     ;; 1 cycle
   \   00000D B804                  MOVW      [SP+0x04], AX      ;; 1 cycle
   2362              p_tcb1     = p_tcb->PrevPtr;                            /* Point to next and previous OS_TCB in the list          */
   \   00000F AA08                  MOVW      AX, [DE+0x08]      ;; 1 cycle
   \   000011 B806                  MOVW      [SP+0x06], AX      ;; 1 cycle
   2363              p_tcb2     = p_tcb->NextPtr;
   \   000013 AA06                  MOVW      AX, [DE+0x06]      ;; 1 cycle
   \   000015 B800                  MOVW      [SP], AX           ;; 1 cycle
   2364              if (p_tcb1 == (OS_TCB *)0) {                            /* Was the OS_TCB to remove was at the head?              */
   \   000017 A804                  MOVW      AX, [SP+0x04]      ;; 1 cycle
   \   000019 040400                ADDW      AX, #0x4           ;; 1 cycle
   \   00001C B802                  MOVW      [SP+0x02], AX      ;; 1 cycle
   \   00001E A806                  MOVW      AX, [SP+0x06]      ;; 1 cycle
   \   000020 440000                CMPW      AX, #0x0           ;; 1 cycle
   \   000023 DF2C                  BNZ       ??OS_TaskRdy_68    ;; 4 cycles
   \   000025                       ; ------------------------------------- Block: 17 cycles
   2365                  if (p_tcb2 == (OS_TCB *)0) {                        /* Yes, was it the only OS_TCB?                           */
   \   000025 A800                  MOVW      AX, [SP]           ;; 1 cycle
   \   000027 440000                CMPW      AX, #0x0           ;; 1 cycle
   \   00002A A802                  MOVW      AX, [SP+0x02]      ;; 1 cycle
   \   00002C 16                    MOVW      HL, AX             ;; 1 cycle
   \   00002D DF10                  BNZ       ??OS_TaskRdy_69    ;; 4 cycles
   \   00002F                       ; ------------------------------------- Block: 8 cycles
   2366                      p_rdy_list->NbrEntries = (OS_OBJ_QTY)0;         /*      Yes, no more entries                              */
   \   00002F F6                    CLRW      AX                 ;; 1 cycle
   \   000030 BB                    MOVW      [HL], AX           ;; 1 cycle
   2367                      p_rdy_list->HeadPtr    = (OS_TCB   *)0;
   \   000031 A804                  MOVW      AX, [SP+0x04]      ;; 1 cycle
   \   000033 16                    MOVW      HL, AX             ;; 1 cycle
   \   000034 F6                    CLRW      AX                 ;; 1 cycle
   \   000035 BB                    MOVW      [HL], AX           ;; 1 cycle
   2368                      p_rdy_list->TailPtr    = (OS_TCB   *)0;
   \   000036 BC02                  MOVW      [HL+0x02], AX      ;; 1 cycle
   2369                      OS_PrioRemove(p_tcb->Prio);
   \   000038 8A1D                  MOV       A, [DE+0x1D]       ;; 1 cycle
   \   00003A FD....                CALL      OS_PrioRemove      ;; 3 cycles
   \   00003D EF32                  BR        S:??OS_TaskRdy_70  ;; 3 cycles
   \   00003F                       ; ------------------------------------- Block: 14 cycles
   2370                  } else {
   2371                      p_rdy_list->NbrEntries--;                       /*      No,  one less entry                               */
   \                     ??OS_TaskRdy_69:
   \   00003F AB                    MOVW      AX, [HL]           ;; 1 cycle
   \   000040 B1                    DECW      AX                 ;; 1 cycle
   \   000041 BB                    MOVW      [HL], AX           ;; 1 cycle
   2372                      p_tcb2->PrevPtr        = (OS_TCB   *)0;         /*           adjust back link of new list head            */
   \   000042 A800                  MOVW      AX, [SP]           ;; 1 cycle
   \   000044 16                    MOVW      HL, AX             ;; 1 cycle
   \   000045 F6                    CLRW      AX                 ;; 1 cycle
   \   000046 BC08                  MOVW      [HL+0x08], AX      ;; 1 cycle
   2373                      p_rdy_list->HeadPtr    = p_tcb2;                /*           adjust OS_RDY_LIST's new head                */
   \   000048 C7                    PUSH      HL                 ;; 1 cycle
   \   000049 C2                    POP       BC                 ;; 1 cycle
   \   00004A A804                  MOVW      AX, [SP+0x04]      ;; 1 cycle
   \   00004C 16                    MOVW      HL, AX             ;; 1 cycle
   \   00004D 13                    MOVW      AX, BC             ;; 1 cycle
   \   00004E BB                    MOVW      [HL], AX           ;; 1 cycle
   \   00004F EF20                  BR        S:??OS_TaskRdy_70  ;; 3 cycles
   \   000051                       ; ------------------------------------- Block: 16 cycles
   2374                  }
   2375              } else {
   2376                  p_rdy_list->NbrEntries--;                           /* No,  one less entry                                    */
   \                     ??OS_TaskRdy_68:
   \   000051 A802                  MOVW      AX, [SP+0x02]      ;; 1 cycle
   \   000053 16                    MOVW      HL, AX             ;; 1 cycle
   \   000054 AB                    MOVW      AX, [HL]           ;; 1 cycle
   \   000055 B1                    DECW      AX                 ;; 1 cycle
   \   000056 BB                    MOVW      [HL], AX           ;; 1 cycle
   2377                  p_tcb1->NextPtr = p_tcb2;
   \   000057 A800                  MOVW      AX, [SP]           ;; 1 cycle
   \   000059 12                    MOVW      BC, AX             ;; 1 cycle
   \   00005A A806                  MOVW      AX, [SP+0x06]      ;; 1 cycle
   \   00005C 16                    MOVW      HL, AX             ;; 1 cycle
   \   00005D 33                    XCHW      AX, BC             ;; 1 cycle
   \   00005E BC06                  MOVW      [HL+0x06], AX      ;; 1 cycle
   2378                  if (p_tcb2 == (OS_TCB *)0) {
   \   000060 440000                CMPW      AX, #0x0           ;; 1 cycle
   \   000063 DF08                  BNZ       ??OS_TaskRdy_71    ;; 4 cycles
   \   000065                       ; ------------------------------------- Block: 16 cycles
   2379                      p_rdy_list->TailPtr = p_tcb1;                   /*      Removing the TCB at the tail, adj the tail ptr    */
   \   000065 A804                  MOVW      AX, [SP+0x04]      ;; 1 cycle
   \   000067 16                    MOVW      HL, AX             ;; 1 cycle
   \   000068 13                    MOVW      AX, BC             ;; 1 cycle
   \   000069 BC02                  MOVW      [HL+0x02], AX      ;; 1 cycle
   \   00006B EF04                  BR        S:??OS_TaskRdy_70  ;; 3 cycles
   \   00006D                       ; ------------------------------------- Block: 7 cycles
   2380                  } else {
   2381                      p_tcb2->PrevPtr     = p_tcb1;
   \                     ??OS_TaskRdy_71:
   \   00006D 16                    MOVW      HL, AX             ;; 1 cycle
   \   00006E 13                    MOVW      AX, BC             ;; 1 cycle
   \   00006F BC08                  MOVW      [HL+0x08], AX      ;; 1 cycle
   \   000071                       ; ------------------------------------- Block: 3 cycles
   2382                  }
   2383              }
   2384              p_tcb->PrevPtr = (OS_TCB *)0;
   \                     ??OS_TaskRdy_70:
   \   000071 F6                    CLRW      AX                 ;; 1 cycle
   \   000072 BA08                  MOVW      [DE+0x08], AX      ;; 1 cycle
   2385              p_tcb->NextPtr = (OS_TCB *)0;
   \   000074 BA06                  MOVW      [DE+0x06], AX      ;; 1 cycle
   2386          }
   \   000076 ED....                BR        N:?Subroutine2     ;; 3 cycles
   \   000079                       ; ------------------------------------- Block: 6 cycles
   \   000079                       ; ------------------------------------- Total: 93 cycles
   \   000079                       REQUIRE ?CLRL78_V1_0_L00
   2387          
   2388          /*$PAGE*/
   2389          /*
   2390          ************************************************************************************************************************
   2391          *                                             SCHEDULE THE ISR HANDLER TASK
   2392          *
   2393          * Description: This function is called by other uC/OS-III services to schedule task at priority 0 which is always the
   2394          *              ISR handler task.
   2395          *
   2396          * Arguments  : none
   2397          *
   2398          * Returns    : none
   2399          *
   2400          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   2401          ************************************************************************************************************************
   2402          */
   2403          
   2404          #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
   2405          void  OS_Sched0 (void)
   2406          {
   2407              CPU_SR_ALLOC();
   2408          
   2409          
   2410          
   2411              CPU_INT_DIS();
   2412              OSPrioHighRdy   = (OS_PRIO)0;                           /* Force the priority to 0                                */
   2413              OSTCBHighRdyPtr = &OSIntQTaskTCB;                       /* Always schedule the ISR handler task                   */
   2414          #if OS_CFG_TASK_PROFILE_EN > 0u
   2415              OSTCBHighRdyPtr->CtxSwCtr++;                            /* Inc. # of context switches to this task                */
   2416          #endif
   2417              OSTaskCtxSwCtr++;                                       /* Increment context switch counter                       */
   2418              OS_TASK_SW();                                           /* Perform a task level context switch                    */
   2419              CPU_INT_EN();
   2420          }
   2421          #endif
   2422          
   2423          /*$PAGE*/
   2424          /*
   2425          ************************************************************************************************************************
   2426          *                                               SCHEDULER LOCK TIME MEASUREMENT
   2427          *
   2428          * Description: These functions are used to measure the peak amount of time that the scheduler is locked
   2429          *
   2430          * Arguments  : none
   2431          *
   2432          * Returns    : none
   2433          *
   2434          * Note(s)    : 1) The are internal functions to uC/OS-III and MUST not be called by your application code.
   2435          *
   2436          *              2) It's assumed that these functions are called when interrupts are disabled.
   2437          *
   2438          *              3) We are reading the CPU_TS_TmrRd() directly even if this is a 16-bit timer.  The reason is that we
   2439          *                 don't expect to have the scheduler locked for 65536 counts even at the rate the TS timer is updated.
   2440          *                 In other words, locking the scheduler for longer than 65536 count would not be a good thing for a
   2441          *                 real-time system.
   2442          ************************************************************************************************************************
   2443          */
   2444          
   2445          #if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
   2446          void  OS_SchedLockTimeMeasStart (void)
   2447          {
   2448              if (OSSchedLockNestingCtr == 1u) {
   2449                  OSSchedLockTimeBegin = CPU_TS_TmrRd();
   2450              }
   2451          }
   2452          
   2453          
   2454          
   2455          
   2456          void  OS_SchedLockTimeMeasStop (void)
   2457          {
   2458              CPU_TS_TMR  delta;
   2459          
   2460          
   2461              if (OSSchedLockNestingCtr == (OS_NESTING_CTR)0) {       /* Make sure we fully un-nested scheduler lock            */
   2462                  delta = CPU_TS_TmrRd()                              /* Compute the delta time between begin and end           */
   2463                        - OSSchedLockTimeBegin;
   2464                  if (delta > OSSchedLockTimeMax) {                   /* Detect peak value                                      */
   2465                      OSSchedLockTimeMax    = delta;
   2466                  }
   2467                  if (delta > OSSchedLockTimeMaxCur) {                /* Detect peak value (for resetable value)                */
   2468                      OSSchedLockTimeMaxCur = delta;
   2469                  }
   2470              }
   2471          }
   2472          #endif
   2473          
   2474          /*$PAGE*/
   2475          /*
   2476          ************************************************************************************************************************
   2477          *                                        RUN ROUND-ROBIN SCHEDULING ALGORITHM
   2478          *
   2479          * Description: This function is called on every tick to determine if a new task at the same priority needs to execute.
   2480          *
   2481          *
   2482          * Arguments  : p_rdy_list    is a pointer to the OS_RDY_LIST entry of the ready list at the current priority
   2483          *              ----------
   2484          *
   2485          * Returns    : none
   2486          *
   2487          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   2488          ************************************************************************************************************************
   2489          */
   2490          
   2491          #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
   2492          void  OS_SchedRoundRobin (OS_RDY_LIST  *p_rdy_list)
   2493          {
   2494              OS_TCB   *p_tcb;
   2495              CPU_SR_ALLOC();
   2496          
   2497          
   2498          
   2499              if (OSSchedRoundRobinEn != DEF_TRUE) {                  /* Make sure round-robin has been enabled                 */
   2500                  return;
   2501              }
   2502          
   2503              CPU_CRITICAL_ENTER();
   2504              p_tcb = p_rdy_list->HeadPtr;                            /* Decrement time quanta counter                          */
   2505          
   2506              if (p_tcb == (OS_TCB *)0) {
   2507                  CPU_CRITICAL_EXIT();
   2508                  return;
   2509              }
   2510          
   2511              if (p_tcb == &OSIdleTaskTCB) {
   2512                  CPU_CRITICAL_EXIT();
   2513                  return;
   2514              }
   2515          
   2516              if (p_tcb->TimeQuantaCtr > (OS_TICK)0) {
   2517                  p_tcb->TimeQuantaCtr--;
   2518              }
   2519          
   2520              if (p_tcb->TimeQuantaCtr > (OS_TICK)0) {                /* Task not done with its time quanta                     */
   2521                  CPU_CRITICAL_EXIT();
   2522                  return;
   2523              }
   2524          
   2525              if (p_rdy_list->NbrEntries < (OS_OBJ_QTY)2) {           /* See if it's time to time slice current task            */
   2526                  CPU_CRITICAL_EXIT();                                /* ... only if multiple tasks at same priority            */
   2527                  return;
   2528              }
   2529          
   2530              if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {        /* Can't round-robin if the scheduler is locked           */
   2531                  CPU_CRITICAL_EXIT();
   2532                  return;
   2533              }
   2534          
   2535              OS_RdyListMoveHeadToTail(p_rdy_list);                   /* Move current OS_TCB to the end of the list             */
   2536              p_tcb = p_rdy_list->HeadPtr;                            /* Point to new OS_TCB at head of the list                */
   2537              if (p_tcb->TimeQuanta == (OS_TICK)0) {                  /* See if we need to use the default time slice           */
   2538                  p_tcb->TimeQuantaCtr = OSSchedRoundRobinDfltTimeQuanta;
   2539              } else {
   2540                  p_tcb->TimeQuantaCtr = p_tcb->TimeQuanta;           /* Load time slice counter with new time                  */
   2541              }
   2542              CPU_CRITICAL_EXIT();
   2543          }
   2544          #endif
   2545          
   2546          /*$PAGE*/
   2547          /*
   2548          ************************************************************************************************************************
   2549          *                                                     BLOCK A TASK
   2550          *
   2551          * Description: This function is called to remove a task from the ready list and also insert it in the timer tick list if
   2552          *              the specified timeout is non-zero.
   2553          *
   2554          * Arguments  : p_tcb          is a pointer to the OS_TCB of the task block
   2555          *              -----
   2556          *
   2557          *              timeout        is the desired timeout
   2558          *
   2559          * Returns    : none
   2560          *
   2561          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   2562          ************************************************************************************************************************
   2563          */
   2564          

   \                                 In  segment CODE, align 1, keep-with-next
   2565          void  OS_TaskBlock (OS_TCB   *p_tcb,
   \                     OS_TaskBlock:
   2566                              OS_TICK   timeout)
   2567          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 4
   \   000000 C3                    PUSH      BC                 ;; 1 cycle
   \   000001 C5                    PUSH      DE                 ;; 1 cycle
   \   000002 C1                    PUSH      AX                 ;; 1 cycle
   \   000003                       ; Auto size: 4
   \   000003 C1                    PUSH      AX                 ;; 1 cycle
   \   000004 A80E                  MOVW      AX, [SP+0x0E]      ;; 1 cycle
   \   000006 12                    MOVW      BC, AX             ;; 1 cycle
   \   000007 A80C                  MOVW      AX, [SP+0x0C]      ;; 1 cycle
   2568              OS_ERR  err;
   2569          
   2570          
   2571              if (timeout > (OS_TICK)0) {                             /* Add task to tick list if timeout non zero               */
   \   000009 33                    XCHW      AX, BC             ;; 1 cycle
   \   00000A 440000                CMPW      AX, #0x0           ;; 1 cycle
   \   00000D 33                    XCHW      AX, BC             ;; 1 cycle
   \   00000E 61F8                  SKNZ                         ;; 4 cycles
   \   000010                       ; ------------------------------------- Block: 14 cycles
   \   000010 440000                CMPW      AX, #0x0           ;; 1 cycle
   \   000013                       ; ------------------------------------- Block: 1 cycles
   \                     ??OS_TaskBlock_0:
   \   000013 DD1D                  BZ        ??OS_TaskRdy_72    ;; 4 cycles
   \   000015                       ; ------------------------------------- Block: 4 cycles
   2572                  OS_TickListInsert(p_tcb,
   2573                                    timeout,
   2574                                    OS_OPT_TIME_TIMEOUT,
   2575                                   &err);
   \   000015 C3                    PUSH      BC                 ;; 1 cycle
   \   000016 C1                    PUSH      AX                 ;; 1 cycle
   \   000017 AEF8                  MOVW      AX, SP             ;; 1 cycle
   \   000019 040400                ADDW      AX, #0x4           ;; 1 cycle
   \   00001C 14                    MOVW      DE, AX             ;; 1 cycle
   \   00001D 320200                MOVW      BC, #0x2           ;; 1 cycle
   \   000020 A806                  MOVW      AX, [SP+0x06]      ;; 1 cycle
   \   000022 FD....                CALL      OS_TickListInsert  ;; 3 cycles
   2576                  if (err == OS_ERR_NONE) {
   \   000025 A800                  MOVW      AX, [SP]           ;; 1 cycle
   \   000027 F7                    CLRW      BC                 ;; 1 cycle
   \   000028 43                    CMPW      AX, BC             ;; 1 cycle
   \   000029 DF07                  BNZ       ??OS_TaskRdy_72    ;; 4 cycles
   \   00002B                       ; ------------------------------------- Block: 17 cycles
   2577                      p_tcb->TaskState = OS_TASK_STATE_PEND_TIMEOUT;
   \   00002B A802                  MOVW      AX, [SP+0x02]      ;; 1 cycle
   \   00002D 16                    MOVW      HL, AX             ;; 1 cycle
   \   00002E 5103                  MOV       A, #0x3            ;; 1 cycle
   \   000030 EF05                  BR        S:??OS_TaskRdy_73  ;; 3 cycles
   \   000032                       ; ------------------------------------- Block: 6 cycles
   2578                  } else {
   2579                      p_tcb->TaskState = OS_TASK_STATE_PEND;
   2580                  }
   2581              } else {
   2582                  p_tcb->TaskState = OS_TASK_STATE_PEND;
   \                     ??OS_TaskRdy_72:
   \   000032 A802                  MOVW      AX, [SP+0x02]      ;; 1 cycle
   \   000034 16                    MOVW      HL, AX             ;; 1 cycle
   \   000035 5102                  MOV       A, #0x2            ;; 1 cycle
   \   000037                       ; ------------------------------------- Block: 3 cycles
   \                     ??OS_TaskRdy_73:
   \   000037 9C1C                  MOV       [HL+0x1C], A       ;; 1 cycle
   2583              }
   2584              OS_RdyListRemove(p_tcb);
   \   000039 17                    MOVW      AX, HL             ;; 1 cycle
   \   00003A FD....                CALL      OS_RdyListRemove   ;; 3 cycles
   2585          }
   \   00003D 1004                  ADDW      SP, #0x4           ;; 1 cycle
   \   00003F C4                    POP       DE                 ;; 1 cycle
   \   000040 C2                    POP       BC                 ;; 1 cycle
   \   000041 ED....                BR        N:??Subroutine17_0  ;; 3 cycles
   \   000044                       ; ------------------------------------- Block: 11 cycles
   \   000044                       ; ------------------------------------- Total: 56 cycles
   \   000044                       REQUIRE ?CLRL78_V1_0_L00
   2586          
   2587          /*$PAGE*/
   2588          /*
   2589          ************************************************************************************************************************
   2590          *                                                     READY A TASK
   2591          *
   2592          * Description: This function is called to make a task ready-to-run.
   2593          *
   2594          * Arguments  : p_tcb          is a pointer to the OS_TCB of the task to make ready-to-run
   2595          *              -----
   2596          *
   2597          * Returns    : none
   2598          *
   2599          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   2600          ************************************************************************************************************************
   2601          */
   2602          

   \                                 In  segment CODE, align 1, keep-with-next
   2603          void   OS_TaskRdy (OS_TCB *p_tcb)
   \                     OS_TaskRdy:
   2604          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000 C5                    PUSH      DE                 ;; 1 cycle
   \   000001                       ; Auto size: 0
   \   000001 14                    MOVW      DE, AX             ;; 1 cycle
   2605              OS_TickListRemove(p_tcb);                               /* Remove from tick list                                  */
   \   000002 FD....                CALL      OS_TickListRemove  ;; 3 cycles
   2606              if ((p_tcb->TaskState & OS_TASK_STATE_BIT_SUSPENDED) == (OS_STATE)0) {
   \   000005 15                    MOVW      AX, DE             ;; 1 cycle
   \   000006 041C00                ADDW      AX, #0x1C          ;; 1 cycle
   \   000009 16                    MOVW      HL, AX             ;; 1 cycle
   \   00000A 31A304                BT        [HL].2, ??OS_TaskRdy_74  ;; 5 cycles
   \   00000D                       ; ------------------------------------- Block: 13 cycles
   2607                  OS_RdyListInsert(p_tcb);                            /* Insert the task in the ready list                      */
   \   00000D 15                    MOVW      AX, DE             ;; 1 cycle
   \   00000E FD....                CALL      OS_RdyListInsert   ;; 3 cycles
   \   000011                       ; ------------------------------------- Block: 4 cycles
   2608              }
   2609          }
   \                     ??OS_TaskRdy_74:
   \   000011 C4                    POP       DE                 ;; 1 cycle
   \   000012 D7                    RET                          ;; 6 cycles
   \   000013                       ; ------------------------------------- Block: 7 cycles
   \   000013                       ; ------------------------------------- Total: 24 cycles
   \   000013                       REQUIRE ?CLRL78_V1_0_L00

   \                                 In  segment NEAR_CONST, align 2
   \                     `?<Constant "uC/OS-III Idle Task">`:
   \   000000 75432F4F532D          DB "uC/OS-III Idle Task"

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   OSInit
        4   -> OSCfg_Init
        4   -> OSInitHook
        4   -> OS_IdleTaskInit
        4   -> OS_MsgPoolInit
        4   -> OS_MutexInit
        4   -> OS_PrioInit
        4   -> OS_QInit
        4   -> OS_RdyListInit
        4   -> OS_SemInit
        4   -> OS_TaskInit
        4   -> OS_TickTaskInit
      0   OSIntEnter
      6   OSIntExit
        6   -> OSIntCtxSw
        6   -> OS_PrioGetHighest
      6   OSSched
        6   -> OS_PrioGetHighest
      4   OSSchedLock
        4   -> CPU_IntDisMeasStart
        4   -> CPU_IntDisMeasStop
      8   OSSchedUnlock
        8   -> CPU_IntDisMeasStart
        8   -> CPU_IntDisMeasStop
        8   -> OSSched
      4   OSStart
        4   -> OSStartHighRdy
        4   -> OS_PrioGetHighest
      0   OSVersion
      4   OS_IdleTask
        4   -> CPU_IntDisMeasStart
        4   -> CPU_IntDisMeasStop
        4   -> OSIdleTaskHook
     26   OS_IdleTaskInit
       26   -> OSTaskCreate
     14   OS_Pend
        6   -> OS_PendDataInit
        6   -> OS_PendListInsertPrio
       10   -> OS_TaskBlock
     12   OS_PendAbort
        8   -> OS_PendAbort1
        4   -> OS_PendListRemove
        4   -> OS_TaskRdy
        4   -> OS_TickListRemove
     10   OS_PendAbort1
      2   OS_PendDataInit
      8   OS_PendListChangePrio
        8   -> OS_PendListInsertPrio
        8   -> OS_PendListRemove1
      0   OS_PendListInit
      6   OS_PendListInsertHead
     10   OS_PendListInsertPrio
      8   OS_PendListRemove
        8   -> OS_PendListRemove1
     10   OS_PendListRemove1
     12   OS_PendObjDel
        4   -> OS_PendListRemove
        8   -> OS_PendObjDel1
        4   -> OS_TaskRdy
        4   -> OS_TickListRemove
     10   OS_PendObjDel1
     20   OS_Post
        8   -> OS_PendListRemove
       14   -> OS_Post1
        8   -> OS_TaskRdy
        8   -> OS_TickListRemove
     10   OS_Post1
      4   OS_RdyListInit
      2   OS_RdyListInsert
        2   -> OS_PrioInsert
        2   -> OS_RdyListInsertHead
        2   -> OS_RdyListInsertTail
      6   OS_RdyListInsertHead
      6   OS_RdyListInsertTail
     12   OS_RdyListMoveHeadToTail
     12   OS_RdyListRemove
       12   -> OS_PrioRemove
     16   OS_TaskBlock
        8   -> OS_RdyListRemove
       12   -> OS_TickListInsert
      2   OS_TaskRdy
        2   -> OS_RdyListInsert
        2   -> OS_TickListRemove


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      20  ?<Constant "uC/OS-III Idle Task">
       6  ??Subroutine15_0
       1  ??Subroutine16_0
       5  ??Subroutine17_0
       5  ?Subroutine0
       5  ?Subroutine1
       1  ?Subroutine10
      10  ?Subroutine11
       6  ?Subroutine12
       9  ?Subroutine13
       5  ?Subroutine14
       5  ?Subroutine2
       2  ?Subroutine3
       5  ?Subroutine4
       9  ?Subroutine5
       6  ?Subroutine6
       8  ?Subroutine7
       9  ?Subroutine8
       7  ?Subroutine9
     112  OSInit
      19  OSIntEnter
      87  OSIntExit
      73  OSSched
      49  OSSchedLock
      72  OSSchedUnlock
      49  OSStart
       7  OSVersion
      41  OS_IdleTask
      52  OS_IdleTaskInit
      80  OS_Pend
     125  OS_PendAbort
      46  OS_PendAbort1
      47  OS_PendDataInit
      60  OS_PendListChangePrio
       8  OS_PendListInit
      46  OS_PendListInsertHead
     155  OS_PendListInsertPrio
      47  OS_PendListRemove
      95  OS_PendListRemove1
     115  OS_PendObjDel
      46  OS_PendObjDel1
     180  OS_Post
      53  OS_Post1
      32  OS_RdyListInit
      25  OS_RdyListInsert
      56  OS_RdyListInsertHead
      58  OS_RdyListInsertTail
      75  OS_RdyListMoveHeadToTail
     121  OS_RdyListRemove
      68  OS_TaskBlock
      19  OS_TaskRdy

 
 2 222 bytes in segment CODE
    20 bytes in segment NEAR_CONST
 
 2 222 bytes of CODE  memory
    20 bytes of CONST memory

Errors: none
Warnings: none

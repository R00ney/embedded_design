###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.30.5.50715 for RL78             23/Mar/2014  17:08:44 #
# Copyright 2011-2013 IAR Systems AB.                                         #
# Network license: ece-lic-19.ece.ncsu.edu (STD)                              #
#                                                                             #
#    Core         =  rl78_2                                                   #
#    Code model   =  Near                                                     #
#    Data model   =  Near                                                     #
#                 =                                                           #
#    Source file  =  C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\uCOS-III\Source\os_task.c  #
#    Command line =  C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\uCOS-III\Source\os_task.c  #
#                    --core rl78_2 --code_model near --data_model near        #
#                    --near_const_location rom0 -o                            #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\Debug\Obj\ --dlib_config            #
#                    "C:\Program Files\IAR Systems\Embedded Workbench         #
#                    6.5\rl78\LIB\dlrl78nn2n.h" -e -Ohz --no_scheduling       #
#                    --no_clustering --debug -lC                              #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\Debug\List\ -I                      #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\ -I C:\Users\Suddenlink\Dropbox\git #
#                    _files\embedded_design\Proj2_uCOS-III-LCD-G14\Software\E #
#                    valBoards\Renesas\YRDKRL78G14\IAR\Application\Source\    #
#                    -I C:\Users\Suddenlink\Dropbox\git_files\embedded_design #
#                    \Proj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDK #
#                    RL78G14\IAR\Application\..\uCOS-III\ -I                  #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\..\BSP\ -I                          #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\..\BSP\applilet3_src\ -I            #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\..\BSP\Glyph\Drivers\ -I            #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\..\BSP\Glyph\glyph\ -I              #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\..\..\..\..\..\uC-CPU\ -I           #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\..\..\..\..\..\uC-CPU\RL78\IAR\ -I  #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\..\..\..\..\..\uC-LIB\ -I           #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\..\..\..\..\..\uCOS-III\Ports\Renes #
#                    as\RL78\IAR\ -I C:\Users\Suddenlink\Dropbox\git_files\em #
#                    bedded_design\Proj2_uCOS-III-LCD-G14\Software\EvalBoards #
#                    \Renesas\YRDKRL78G14\IAR\Application\..\..\..\..\..\uCOS #
#                    -III\Source\ --relaxed_fp                                #
#    List file    =  C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\Debug\List\os_task.lst              #
#    Object file  =  C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Pr #
#                    oj2_uCOS-III-LCD-G14\Software\EvalBoards\Renesas\YRDKRL7 #
#                    8G14\IAR\Application\Debug\Obj\os_task.r87               #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\Suddenlink\Dropbox\git_files\embedded_design\Proj2_uCOS-III-LCD-G14\Software\uCOS-III\Source\os_task.c
      1          /*
      2          ************************************************************************************************************************
      3          *                                                      uC/OS-III
      4          *                                                 The Real-Time Kernel
      5          *
      6          *                                  (c) Copyright 2009-2011; Micrium, Inc.; Weston, FL
      7          *                           All rights reserved.  Protected by international copyright laws.
      8          *
      9          *                                                   TASK MANAGEMENT
     10          *
     11          * File    : OS_TASK.C
     12          * By      : JJL
     13          * Version : V3.02.00
     14          *
     15          * LICENSING TERMS:
     16          * ---------------
     17          *           uC/OS-III is provided in source form for FREE short-term evaluation, for educational use or 
     18          *           for peaceful research.  If you plan or intend to use uC/OS-III in a commercial application/
     19          *           product then, you need to contact Micrium to properly license uC/OS-III for its use in your 
     20          *           application/product.   We provide ALL the source code for your convenience and to help you 
     21          *           experience uC/OS-III.  The fact that the source is provided does NOT mean that you can use 
     22          *           it commercially without paying a licensing fee.
     23          *
     24          *           Knowledge of the source code may NOT be used to develop a similar product.
     25          *
     26          *           Please help us continue to provide the embedded community with the finest software available.
     27          *           Your honesty is greatly appreciated.
     28          *
     29          *           You can contact us at www.micrium.com, or by phone at +1 (954) 217-2036.
     30          ************************************************************************************************************************
     31          */
     32          
     33          #include <os.h>
     34          
     35          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     36          const  CPU_CHAR  *os_task__c = "$Id: $";
     37          #endif
     38          
     39          /*
     40          ************************************************************************************************************************
     41          *                                                CHANGE PRIORITY OF A TASK
     42          *
     43          * Description: This function allows you to change the priority of a task dynamically.  Note that the new
     44          *              priority MUST be available.
     45          *
     46          * Arguments  : p_tcb      is the TCB of the tack to change the priority for
     47          *
     48          *              prio_new   is the new priority
     49          *
     50          *              p_err      is a pointer to an error code returned by this function:
     51          *
     52          *                             OS_ERR_NONE                 is the call was successful
     53          *                             OS_ERR_PRIO_INVALID         if the priority you specify is higher that the maximum allowed
     54          *                                                         (i.e. >= (OS_CFG_PRIO_MAX-1))
     55          *                             OS_ERR_STATE_INVALID        if the task is in an invalid state
     56          *                             OS_ERR_TASK_CHANGE_PRIO_ISR if you tried to change the task's priority from an ISR
     57          ************************************************************************************************************************
     58          */
     59          
     60          #if OS_CFG_TASK_CHANGE_PRIO_EN > 0u
     61          void  OSTaskChangePrio (OS_TCB   *p_tcb,
     62                                  OS_PRIO   prio_new,
     63                                  OS_ERR   *p_err)
     64          {
     65              CPU_BOOLEAN   self;
     66              CPU_SR_ALLOC();
     67          
     68          
     69          
     70          #ifdef OS_SAFETY_CRITICAL
     71              if (p_err == (OS_ERR *)0) {
     72                  OS_SAFETY_CRITICAL_EXCEPTION();
     73                  return;
     74              }
     75          #endif
     76          
     77          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
     78              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* ---------- CANNOT CREATE A TASK FROM AN ISR ---------- */
     79                 *p_err = OS_ERR_TASK_CHANGE_PRIO_ISR;
     80                  return;
     81              }
     82          #endif
     83          
     84              if (prio_new >= (OS_CFG_PRIO_MAX - 1u)) {               /* Cannot set to Idle Task priority                       */
     85                  *p_err = OS_ERR_PRIO_INVALID;
     86                  return;
     87              }
     88          
     89              if (p_tcb == (OS_TCB *)0) {                             /* See if want to change priority of 'self'               */
     90                  CPU_CRITICAL_ENTER();
     91                  p_tcb = OSTCBCurPtr;
     92                  CPU_CRITICAL_EXIT();
     93                  self  = DEF_TRUE;
     94              } else {
     95                  self  = DEF_FALSE;
     96              }
     97          
     98              OS_CRITICAL_ENTER();
     99              switch (p_tcb->TaskState) {
    100                  case OS_TASK_STATE_RDY:
    101                       OS_RdyListRemove(p_tcb);                       /* Remove from current priority                           */
    102                       p_tcb->Prio = prio_new;                        /* Set new task priority                                  */
    103                       OS_PrioInsert(p_tcb->Prio);
    104                       if (self == DEF_TRUE) {
    105                           OS_RdyListInsertHead(p_tcb);
    106                       } else {
    107                           OS_RdyListInsertTail(p_tcb);
    108                       }
    109                       break;
    110          
    111                  case OS_TASK_STATE_DLY:                             /* Nothing to do except change the priority in the OS_TCB */
    112                  case OS_TASK_STATE_SUSPENDED:
    113                  case OS_TASK_STATE_DLY_SUSPENDED:
    114                       p_tcb->Prio = prio_new;                        /* Set new task priority                                  */
    115                       break;
    116          
    117                  case OS_TASK_STATE_PEND:
    118                  case OS_TASK_STATE_PEND_TIMEOUT:
    119                  case OS_TASK_STATE_PEND_SUSPENDED:
    120                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
    121                       switch (p_tcb->PendOn) {                       /* What to do depends on what we are pending on           */
    122                           case OS_TASK_PEND_ON_TASK_Q:               /* Nothing to do except change the priority in the OS_TCB */
    123                           case OS_TASK_PEND_ON_TASK_SEM:
    124                           case OS_TASK_PEND_ON_FLAG:
    125                                p_tcb->Prio = prio_new;               /* Set new task priority                                  */
    126                                break;
    127          
    128                           case OS_TASK_PEND_ON_MUTEX:
    129                           case OS_TASK_PEND_ON_MULTI:
    130                           case OS_TASK_PEND_ON_Q:
    131                           case OS_TASK_PEND_ON_SEM:
    132                                OS_PendListChangePrio(p_tcb,
    133                                                      prio_new);
    134                                break;
    135          
    136                           default:
    137                                break;
    138                      }
    139                       break;
    140          
    141                  default:
    142                       OS_CRITICAL_EXIT();
    143                       *p_err = OS_ERR_STATE_INVALID;
    144                       return;
    145              }
    146          
    147              OS_CRITICAL_EXIT_NO_SCHED();
    148          
    149              OSSched();                                              /* Run highest priority task ready                        */
    150          
    151              *p_err = OS_ERR_NONE;
    152          }
    153          #endif
    154          
    155          /*$PAGE*/
    156          /*
    157          ************************************************************************************************************************
    158          *                                                    CREATE A TASK
    159          *
    160          * Description: This function is used to have uC/OS-III manage the execution of a task.  Tasks can either be created
    161          *              prior to the start of multitasking or by a running task.  A task cannot be created by an ISR.
    162          *
    163          * Arguments  : p_tcb          is a pointer to the task's TCB
    164          *
    165          *              p_name         is a pointer to an ASCII string to provide a name to the task.
    166          *
    167          *              p_task         is a pointer to the task's code
    168          *
    169          *              p_arg          is a pointer to an optional data area which can be used to pass parameters to
    170          *                             the task when the task first executes.  Where the task is concerned it thinks
    171          *                             it was invoked and passed the argument 'p_arg' as follows:
    172          *
    173          *                                 void Task (void *p_arg)
    174          *                                 {
    175          *                                     for (;;) {
    176          *                                         Task code;
    177          *                                     }
    178          *                                 }
    179          *
    180          *              prio           is the task's priority.  A unique priority MUST be assigned to each task and the
    181          *                             lower the number, the higher the priority.
    182          *
    183          *              p_stk_base     is a pointer to the base address of the stack (i.e. low address).
    184          *
    185          *              stk_limit      is the number of stack elements to set as 'watermark' limit for the stack.  This value
    186          *                             represents the number of CPU_STK entries left before the stack is full.  For example,
    187          *                             specifying 10% of the 'stk_size' value indicates that the stack limit will be reached
    188          *                             when the stack reaches 90% full.
    189          *
    190          *              stk_size       is the size of the stack in number of elements.  If CPU_STK is set to CPU_INT08U,
    191          *                             'stk_size' corresponds to the number of bytes available.  If CPU_STK is set to
    192          *                             CPU_INT16U, 'stk_size' contains the number of 16-bit entries available.  Finally, if
    193          *                             CPU_STK is set to CPU_INT32U, 'stk_size' contains the number of 32-bit entries
    194          *                             available on the stack.
    195          *
    196          *              q_size         is the maximum number of messages that can be sent to the task
    197          *
    198          *              time_quanta    amount of time (in ticks) for time slice when round-robin between tasks.  Specify 0 to use
    199          *                             the default.
    200          *
    201          *              p_ext          is a pointer to a user supplied memory location which is used as a TCB extension.
    202          *                             For example, this user memory can hold the contents of floating-point registers
    203          *                             during a context switch, the time each task takes to execute, the number of times
    204          *                             the task has been switched-in, etc.
    205          *
    206          *              opt            contains additional information (or options) about the behavior of the task.
    207          *                             See OS_OPT_TASK_xxx in OS.H.  Current choices are:
    208          *
    209          *                                 OS_OPT_TASK_NONE            No option selected
    210          *                                 OS_OPT_TASK_STK_CHK         Stack checking to be allowed for the task
    211          *                                 OS_OPT_TASK_STK_CLR         Clear the stack when the task is created
    212          *                                 OS_OPT_TASK_SAVE_FP         If the CPU has floating-point registers, save them
    213          *                                                             during a context switch.
    214          *
    215          *              p_err          is a pointer to an error code that will be set during this call.  The value pointer
    216          *                             to by 'p_err' can be:
    217          *
    218          *                                 OS_ERR_NONE                    if the function was successful.
    219          *                                 OS_ERR_ILLEGAL_CREATE_RUN_TIME if you are trying to create the task after you called
    220          *                                                                   OSSafetyCriticalStart().
    221          *                                 OS_ERR_NAME                    if 'p_name' is a NULL pointer
    222          *                                 OS_ERR_PRIO_INVALID            if the priority you specify is higher that the maximum
    223          *                                                                   allowed (i.e. >= OS_CFG_PRIO_MAX-1) or,
    224          *                                                                if OS_CFG_ISR_POST_DEFERRED_EN is set to 1 and you tried
    225          *                                                                   to use priority 0 which is reserved.
    226          *                                 OS_ERR_STK_INVALID             if you specified a NULL pointer for 'p_stk_base'
    227          *                                 OS_ERR_STK_SIZE_INVALID        if you specified zero for the 'stk_size'
    228          *                                 OS_ERR_STK_LIMIT_INVALID       if you specified a 'stk_limit' greater than or equal
    229          *                                                                   to 'stk_size'
    230          *                                 OS_ERR_TASK_CREATE_ISR         if you tried to create a task from an ISR.
    231          *                                 OS_ERR_TASK_INVALID            if you specified a NULL pointer for 'p_task'
    232          *                                 OS_ERR_TCB_INVALID             if you specified a NULL pointer for 'p_tcb'
    233          *
    234          * Returns    : A pointer to the TCB of the task created.  This pointer must be used as an ID (i.e handle) to the task.
    235          ************************************************************************************************************************
    236          */
    237          /*$PAGE*/

   \                                 In  segment CODE, align 1, keep-with-next
    238          void  OSTaskCreate (OS_TCB        *p_tcb,
   \                     OSTaskCreate:
    239                              CPU_CHAR      *p_name,
    240                              OS_TASK_PTR    p_task,
    241                              void          *p_arg,
    242                              OS_PRIO        prio,
    243                              CPU_STK       *p_stk_base,
    244                              CPU_STK_SIZE   stk_limit,
    245                              CPU_STK_SIZE   stk_size,
    246                              OS_MSG_QTY     q_size,
    247                              OS_TICK        time_quanta,
    248                              void          *p_ext,
    249                              OS_OPT         opt,
    250                              OS_ERR        *p_err)
    251          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 22
   \   000000 C1                    PUSH      AX                 ;; 1 cycle
   \   000001 C3                    PUSH      BC                 ;; 1 cycle
   \   000002 C5                    PUSH      DE                 ;; 1 cycle
   \   000003                       ; Auto size: 10
   \   000003 2004                  SUBW      SP, #0x4           ;; 1 cycle
   \   000005 A822                  MOVW      AX, [SP+0x22]      ;; 1 cycle
   \   000007 14                    MOVW      DE, AX             ;; 1 cycle
    252              CPU_STK_SIZE   i;
    253          #if OS_CFG_TASK_REG_TBL_SIZE > 0u
    254              OS_OBJ_QTY     reg_nbr;
    255          #endif
    256              CPU_STK       *p_sp;
    257              CPU_STK       *p_stk_limit;
    258              CPU_SR_ALLOC();
    259          
    260          
    261          
    262          #ifdef OS_SAFETY_CRITICAL
    263              if (p_err == (OS_ERR *)0) {
    264                  OS_SAFETY_CRITICAL_EXCEPTION();
    265                  return;
    266              }
    267          #endif
    268          
    269          #ifdef OS_SAFETY_CRITICAL_IEC61508
    270              if (OSSafetyCriticalStartFlag == DEF_TRUE) {
    271                 *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
    272                  return;
    273              }
    274          #endif
    275          
    276          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    277              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* ---------- CANNOT CREATE A TASK FROM AN ISR ---------- */
    278                  *p_err = OS_ERR_TASK_CREATE_ISR;
    279                  return;
    280              }
    281          #endif
    282          
    283          #if OS_CFG_ARG_CHK_EN > 0u                                  /* ---------------- VALIDATE ARGUMENTS ------------------ */
    284              if (p_tcb == (OS_TCB *)0) {                             /* User must supply a valid OS_TCB                        */
    285                  *p_err = OS_ERR_TCB_INVALID;
    286                  return;
    287              }
    288              if (p_task == (OS_TASK_PTR)0) {                         /* User must supply a valid task                          */
    289                  *p_err = OS_ERR_TASK_INVALID;
    290                  return;
    291              }
    292              if (p_stk_base == (CPU_STK *)0) {                       /* User must supply a valid stack base address            */
    293                  *p_err = OS_ERR_STK_INVALID;
    294                  return;
    295              }
    296              if (stk_size < OSCfg_StkSizeMin) {                      /* User must supply a valid minimum stack size            */
    297                  *p_err = OS_ERR_STK_SIZE_INVALID;
    298                  return;
    299              }
    300              if (stk_limit >= stk_size) {                            /* User must supply a valid stack limit                   */
    301                  *p_err = OS_ERR_STK_LIMIT_INVALID;
    302                  return;
    303              }
    304              if (prio >= OS_CFG_PRIO_MAX) {                          /* Priority must be within 0 and OS_CFG_PRIO_MAX-1        */
    305                  *p_err = OS_ERR_PRIO_INVALID;
    306                  return;
    307              }
    308          #endif
    309          
    310          #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
    311              if (prio == (OS_PRIO)0) {
    312                  if (p_tcb != &OSIntQTaskTCB) {
    313                      *p_err = OS_ERR_PRIO_INVALID;                   /* Not allowed to use priority 0                          */
    314                      return;
    315                  }
    316              }
    317          #endif
    318          
    319              if (prio == (OS_CFG_PRIO_MAX - 1u)) {
   \   000008 8810                  MOV       A, [SP+0x10]       ;; 1 cycle
   \   00000A 4C07                  CMP       A, #0x7            ;; 1 cycle
   \   00000C DF0E                  BNZ       ??OS_TaskSemPost_0  ;; 4 cycles
   \   00000E                       ; ------------------------------------- Block: 12 cycles
    320                  if (p_tcb != &OSIdleTaskTCB) {
   \   00000E A808                  MOVW      AX, [SP+0x08]      ;; 1 cycle
   \   000010 44....                CMPW      AX, #OSIdleTaskTCB  ;; 1 cycle
   \   000013 DD07                  BZ        ??OS_TaskSemPost_0  ;; 4 cycles
   \   000015                       ; ------------------------------------- Block: 6 cycles
    321                      *p_err = OS_ERR_PRIO_INVALID;                   /* Not allowed to use same priority as idle task          */
   \   000015 307362                MOVW      AX, #0x6273        ;; 1 cycle
   \   000018 B9                    MOVW      [DE], AX           ;; 1 cycle
    322                      return;
   \   000019 ED....                BR        N:??OS_TaskSemPost_1  ;; 3 cycles
   \   00001C                       ; ------------------------------------- Block: 5 cycles
    323                  }
    324              }
    325          
    326              OS_TaskInitTCB(p_tcb);                                  /* Initialize the TCB to default values                   */
   \                     ??OS_TaskSemPost_0:
   \   00001C A808                  MOVW      AX, [SP+0x08]      ;; 1 cycle
   \   00001E FD....                CALL      OS_TaskInitTCB     ;; 3 cycles
    327          
    328              *p_err = OS_ERR_NONE;
   \   000021 F6                    CLRW      AX                 ;; 1 cycle
   \   000022 B9                    MOVW      [DE], AX           ;; 1 cycle
    329                                                                      /* --------------- CLEAR THE TASK'S STACK --------------- */
    330              if ((opt & OS_OPT_TASK_STK_CHK) != (OS_OPT)0) {         /* See if stack checking has been enabled                 */
   \   000023 A820                  MOVW      AX, [SP+0x20]      ;; 1 cycle
   \   000025 60                    MOV       A, X               ;; 1 cycle
   \   000026 5C03                  AND       A, #0x3            ;; 1 cycle
   \   000028 4C03                  CMP       A, #0x3            ;; 1 cycle
   \   00002A DF12                  BNZ       ??OS_TaskSemPost_2  ;; 4 cycles
   \   00002C                       ; ------------------------------------- Block: 14 cycles
    331                  if ((opt & OS_OPT_TASK_STK_CLR) != (OS_OPT)0) {     /* See if stack needs to be cleared                       */
    332                      p_sp = p_stk_base;
   \   00002C A812                  MOVW      AX, [SP+0x12]      ;; 1 cycle
   \   00002E 16                    MOVW      HL, AX             ;; 1 cycle
    333                      for (i = 0u; i < stk_size; i++) {               /* Stack grows from HIGH to LOW memory                    */
   \   00002F F6                    CLRW      AX                 ;; 1 cycle
   \   000030 14                    MOVW      DE, AX             ;; 1 cycle
   \   000031 EF05                  BR        S:??OS_TaskSemPost_3  ;; 3 cycles
   \   000033                       ; ------------------------------------- Block: 7 cycles
    334                          *p_sp = (CPU_STK)0;                         /* Clear from bottom of stack and up!                     */
   \                     ??OSTaskCreate_0:
   \   000033 F6                    CLRW      AX                 ;; 1 cycle
   \   000034 BB                    MOVW      [HL], AX           ;; 1 cycle
    335                          p_sp++;
   \   000035 A7                    INCW      HL                 ;; 1 cycle
   \   000036 A7                    INCW      HL                 ;; 1 cycle
    336                      }
   \   000037 A5                    INCW      DE                 ;; 1 cycle
   \   000038                       ; ------------------------------------- Block: 5 cycles
   \                     ??OS_TaskSemPost_3:
   \   000038 A816                  MOVW      AX, [SP+0x16]      ;; 1 cycle
   \   00003A 45                    CMPW      AX, DE             ;; 1 cycle
   \   00003B 61C3F5                BH        ??OSTaskCreate_0   ;; 4 cycles
   \   00003E                       ; ------------------------------------- Block: 6 cycles
    337                  }
    338              }
    339                                                                      /* ------- INITIALIZE THE STACK FRAME OF THE TASK ------- */
    340          #if (CPU_CFG_STK_GROWTH == CPU_STK_GROWTH_HI_TO_LO)
    341              p_stk_limit = p_stk_base + stk_limit;
   \                     ??OS_TaskSemPost_2:
   \   00003E A814                  MOVW      AX, [SP+0x14]      ;; 1 cycle
   \   000040 12                    MOVW      BC, AX             ;; 1 cycle
   \   000041 311C                  SHLW      BC, 0x1            ;; 1 cycle
   \   000043 A812                  MOVW      AX, [SP+0x12]      ;; 1 cycle
   \   000045 03                    ADDW      AX, BC             ;; 1 cycle
   \   000046 B800                  MOVW      [SP], AX           ;; 1 cycle
    342          #else
    343              p_stk_limit = p_stk_base + (stk_size - 1u) - stk_limit;
    344          #endif
    345          
    346              p_sp = OSTaskStkInit(p_task,
    347                                   p_arg,
    348                                   p_stk_base,
    349                                   p_stk_limit,
    350                                   stk_size,
    351                                   opt);
   \   000048 A820                  MOVW      AX, [SP+0x20]      ;; 1 cycle
   \   00004A C1                    PUSH      AX                 ;; 1 cycle
   \   00004B A818                  MOVW      AX, [SP+0x18]      ;; 1 cycle
   \   00004D C1                    PUSH      AX                 ;; 1 cycle
   \   00004E A804                  MOVW      AX, [SP+0x04]      ;; 1 cycle
   \   000050 C1                    PUSH      AX                 ;; 1 cycle
   \   000051 A818                  MOVW      AX, [SP+0x18]      ;; 1 cycle
   \   000053 14                    MOVW      DE, AX             ;; 1 cycle
   \   000054 A814                  MOVW      AX, [SP+0x14]      ;; 1 cycle
   \   000056 12                    MOVW      BC, AX             ;; 1 cycle
   \   000057 A80A                  MOVW      AX, [SP+0x0A]      ;; 1 cycle
   \   000059 FD....                CALL      OSTaskStkInit      ;; 3 cycles
   \   00005C 16                    MOVW      HL, AX             ;; 1 cycle
    352          
    353                                                                      /* -------------- INITIALIZE THE TCB FIELDS ------------- */
    354              p_tcb->TaskEntryAddr = p_task;                          /* Save task entry point address                          */
   \   00005D A804                  MOVW      AX, [SP+0x04]      ;; 1 cycle
   \   00005F 12                    MOVW      BC, AX             ;; 1 cycle
   \   000060 A808                  MOVW      AX, [SP+0x08]      ;; 1 cycle
   \   000062 14                    MOVW      DE, AX             ;; 1 cycle
   \   000063 13                    MOVW      AX, BC             ;; 1 cycle
   \   000064 BA14                  MOVW      [DE+0x14], AX      ;; 1 cycle
    355              p_tcb->TaskEntryArg  = p_arg;                           /* Save task entry argument                               */
   \   000066 A80E                  MOVW      AX, [SP+0x0E]      ;; 1 cycle
   \   000068 BA16                  MOVW      [DE+0x16], AX      ;; 1 cycle
    356          
    357              p_tcb->NamePtr       = p_name;                          /* Save task name                                         */
   \   00006A A806                  MOVW      AX, [SP+0x06]      ;; 1 cycle
   \   00006C BA10                  MOVW      [DE+0x10], AX      ;; 1 cycle
    358          
    359              p_tcb->Prio          = prio;                            /* Save the task's priority                               */
   \   00006E 8810                  MOV       A, [SP+0x10]       ;; 1 cycle
   \   000070 9A1D                  MOV       [DE+0x1D], A       ;; 1 cycle
    360          
    361              p_tcb->StkPtr        = p_sp;                            /* Save the new top-of-stack pointer                      */
   \   000072 17                    MOVW      AX, HL             ;; 1 cycle
   \   000073 B9                    MOVW      [DE], AX           ;; 1 cycle
    362              p_tcb->StkLimitPtr   = p_stk_limit;                     /* Save the stack limit pointer                           */
   \   000074 A800                  MOVW      AX, [SP]           ;; 1 cycle
   \   000076 BA04                  MOVW      [DE+0x04], AX      ;; 1 cycle
    363          
    364              p_tcb->TimeQuanta    = time_quanta;                     /* Save the #ticks for time slice (0 means not sliced)    */
   \   000078 A81C                  MOVW      AX, [SP+0x1C]      ;; 1 cycle
   \   00007A 12                    MOVW      BC, AX             ;; 1 cycle
   \   00007B A81A                  MOVW      AX, [SP+0x1A]      ;; 1 cycle
   \   00007D BA38                  MOVW      [DE+0x38], AX      ;; 1 cycle
   \   00007F 13                    MOVW      AX, BC             ;; 1 cycle
   \   000080 BA3A                  MOVW      [DE+0x3A], AX      ;; 1 cycle
    365          #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
    366              if (time_quanta == (OS_TICK)0) {
    367                  p_tcb->TimeQuantaCtr = OSSchedRoundRobinDfltTimeQuanta;
    368              } else {
    369                  p_tcb->TimeQuantaCtr = time_quanta;
    370              }
    371          #endif
    372              p_tcb->ExtPtr        = p_ext;                           /* Save pointer to TCB extension                          */
   \   000082 A81E                  MOVW      AX, [SP+0x1E]      ;; 1 cycle
   \   000084 BA02                  MOVW      [DE+0x02], AX      ;; 1 cycle
    373              p_tcb->StkBasePtr    = p_stk_base;                      /* Save pointer to the base address of the stack          */
   \   000086 A812                  MOVW      AX, [SP+0x12]      ;; 1 cycle
   \   000088 BA12                  MOVW      [DE+0x12], AX      ;; 1 cycle
    374              p_tcb->StkSize       = stk_size;                        /* Save the stack size (in number of CPU_STK elements)    */
   \   00008A A816                  MOVW      AX, [SP+0x16]      ;; 1 cycle
   \   00008C BA1E                  MOVW      [DE+0x1E], AX      ;; 1 cycle
    375              p_tcb->Opt           = opt;                             /* Save task options                                      */
   \   00008E A820                  MOVW      AX, [SP+0x20]      ;; 1 cycle
   \   000090 BA20                  MOVW      [DE+0x20], AX      ;; 1 cycle
    376          
    377          #if OS_CFG_TASK_REG_TBL_SIZE > 0u
    378              for (reg_nbr = 0u; reg_nbr < OS_CFG_TASK_REG_TBL_SIZE; reg_nbr++) {
    379                  p_tcb->RegTbl[reg_nbr] = (OS_REG)0;
    380              }
    381          #endif
    382          
    383          #if OS_CFG_TASK_Q_EN > 0u
    384              OS_MsgQInit(&p_tcb->MsgQ,                               /* Initialize the task's message queue                    */
    385                          q_size);
    386          #endif
    387          
    388              OSTaskCreateHook(p_tcb);                                /* Call user defined hook                                 */
   \   000092 15                    MOVW      AX, DE             ;; 1 cycle
   \   000093 FD....                CALL      OSTaskCreateHook   ;; 3 cycles
    389          
    390                                                                      /* --------------- ADD TASK TO READY LIST --------------- */
    391              OS_CRITICAL_ENTER();
   \   000096 8EFA                  MOV       A, PSW             ;; 1 cycle
   \   000098 70                    MOV       X, A               ;; 1 cycle
   \   000099 F1                    CLRB      A                  ;; 1 cycle
   \   00009A B800                  MOVW      [SP], AX           ;; 1 cycle
   \   00009C F6                    CLRW      AX                 ;; 1 cycle
   \   00009D B802                  MOVW      [SP+0x02], AX      ;; 1 cycle
   \   00009F 717BFA                DI                           ;; 2 cycles
   \   0000A2 FD....                CALL      CPU_IntDisMeasStart  ;; 3 cycles
    392              OS_PrioInsert(p_tcb->Prio);
   \   0000A5 C5                    PUSH      DE                 ;; 1 cycle
   \   0000A6 C6                    POP       HL                 ;; 1 cycle
   \   0000A7 8C1D                  MOV       A, [HL+0x1D]       ;; 1 cycle
   \   0000A9 FD....                CALL      OS_PrioInsert      ;; 3 cycles
    393              OS_RdyListInsertTail(p_tcb);
   \   0000AC 15                    MOVW      AX, DE             ;; 1 cycle
   \   0000AD FD....                CALL      OS_RdyListInsertTail  ;; 3 cycles
    394          
    395          #if OS_CFG_DBG_EN > 0u
    396              OS_TaskDbgListAdd(p_tcb);
    397          #endif
    398          
    399              OSTaskQty++;                                            /* Increment the #tasks counter                           */
   \   0000B0 A2....                INCW      N:OSTaskQty        ;; 2 cycles
    400          
    401              if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Return if multitasking has not started                 */
   \   0000B3 40......              CMP       N:OSRunning, #0x1  ;; 1 cycle
   \   0000B7 DD0A                  BZ        ??OS_TaskSemPost_4  ;; 4 cycles
   \   0000B9                       ; ------------------------------------- Block: 83 cycles
    402                  OS_CRITICAL_EXIT();
   \   0000B9 FD....                CALL      CPU_IntDisMeasStop  ;; 3 cycles
   \   0000BC 8800                  MOV       A, [SP]            ;; 1 cycle
   \   0000BE FD....                CALL      N:?Subroutine1     ;; 3 cycles
   \   0000C1                       ; ------------------------------------- Block: 7 cycles
    403                  return;
   \                     ??CrossCallReturnLabel_0:
   \   0000C1 EF0B                  BR        S:??OS_TaskSemPost_1  ;; 3 cycles
   \   0000C3                       ; ------------------------------------- Block: 3 cycles
    404              }
    405          
    406              OS_CRITICAL_EXIT_NO_SCHED();
   \                     ??OS_TaskSemPost_4:
   \   0000C3 FD....                CALL      CPU_IntDisMeasStop  ;; 3 cycles
   \   0000C6 8800                  MOV       A, [SP]            ;; 1 cycle
   \   0000C8 FD....                CALL      N:?Subroutine1     ;; 3 cycles
   \   0000CB                       ; ------------------------------------- Block: 7 cycles
    407          
    408              OSSched();
   \                     ??CrossCallReturnLabel_1:
   \   0000CB FD....                CALL      OSSched            ;; 3 cycles
    409          }
   \   0000CE                       ; ------------------------------------- Block: 3 cycles
   \                     ??OS_TaskSemPost_1:
   \   0000CE 100A                  ADDW      SP, #0xA           ;; 1 cycle
   \   0000D0 FD....                CALL      N:?FUNC_LEAVE_L06
   \   0000D3 1600                  DW        0x16               ;; 3 cycles
   \   0000D5                       ; ------------------------------------- Block: 4 cycles
   \   0000D5                       ; ------------------------------------- Total: 162 cycles
   \   0000D5                       REQUIRE ?CLRL78_V1_0_L00

   \                                 In  segment CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000 71FC                  MOV1      CY, A.7            ;; 1 cycle
   \   000002 7179FA                MOV1      PSW.7, CY          ;; 4 cycles
   \   000005 D7                    RET                          ;; 6 cycles
   \   000006                       ; ------------------------------------- Block: 11 cycles
   \   000006                       ; ------------------------------------- Total: 11 cycles
   \   000006                       REQUIRE ?CLRL78_V1_0_L00
    410          
    411          /*$PAGE*/
    412          /*
    413          ************************************************************************************************************************
    414          *                                                     DELETE A TASK
    415          *
    416          * Description: This function allows you to delete a task.  The calling task can delete itself by specifying a NULL
    417          *              pointer for 'p_tcb'.  The deleted task is returned to the dormant state and can be re-activated by
    418          *              creating the deleted task again.
    419          *
    420          * Arguments  : p_tcb      is the TCB of the tack to delete
    421          *
    422          *              p_err      is a pointer to an error code returned by this function:
    423          *
    424          *                             OS_ERR_NONE                  if the call is successful
    425          *                             OS_ERR_STATE_INVALID         if the state of the task is invalid
    426          *                             OS_ERR_TASK_DEL_IDLE         if you attempted to delete uC/OS-III's idle task
    427          *                             OS_ERR_TASK_DEL_INVALID      if you attempted to delete uC/OS-III's ISR handler task
    428          *                             OS_ERR_TASK_DEL_ISR          if you tried to delete a task from an ISR
    429          ************************************************************************************************************************
    430          */
    431          
    432          #if OS_CFG_TASK_DEL_EN > 0u
    433          void  OSTaskDel (OS_TCB  *p_tcb,
    434                           OS_ERR  *p_err)
    435          {
    436              CPU_SR_ALLOC();
    437          
    438          
    439          
    440          #ifdef OS_SAFETY_CRITICAL
    441              if (p_err == (OS_ERR *)0) {
    442                  OS_SAFETY_CRITICAL_EXCEPTION();
    443                  return;
    444              }
    445          #endif
    446          
    447          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    448              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to delete from ISR                       */
    449                 *p_err = OS_ERR_TASK_DEL_ISR;
    450                  return;
    451              }
    452          #endif
    453          
    454              if (p_tcb == &OSIdleTaskTCB) {                          /* Not allowed to delete the idle task                    */
    455                  *p_err = OS_ERR_TASK_DEL_IDLE;
    456                  return;
    457              }
    458          
    459          #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
    460              if (p_tcb == &OSIntQTaskTCB) {                          /* Cannot delete the ISR handler task                     */
    461                  *p_err = OS_ERR_TASK_DEL_INVALID;
    462                  return;
    463              }
    464          #endif
    465          
    466              if (p_tcb == (OS_TCB *)0) {                             /* Delete 'Self'?                                         */
    467                  CPU_CRITICAL_ENTER();
    468                  p_tcb  = OSTCBCurPtr;                               /* Yes.                                                   */
    469                  CPU_CRITICAL_EXIT();
    470              }
    471          
    472              OS_CRITICAL_ENTER();
    473              switch (p_tcb->TaskState) {
    474                  case OS_TASK_STATE_RDY:
    475                       OS_RdyListRemove(p_tcb);
    476                       break;
    477          
    478                  case OS_TASK_STATE_SUSPENDED:
    479                       break;
    480          
    481                  case OS_TASK_STATE_DLY:                             /* Task is only delayed, not on any wait list             */
    482                  case OS_TASK_STATE_DLY_SUSPENDED:
    483                       OS_TickListRemove(p_tcb);
    484                       break;
    485          
    486                  case OS_TASK_STATE_PEND:
    487                  case OS_TASK_STATE_PEND_SUSPENDED:
    488                  case OS_TASK_STATE_PEND_TIMEOUT:
    489                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
    490                       OS_TickListRemove(p_tcb);
    491                       switch (p_tcb->PendOn) {                       /* See what we are pending on                             */
    492                           case OS_TASK_PEND_ON_NOTHING:
    493                           case OS_TASK_PEND_ON_TASK_Q:               /* There is no wait list for these two                    */
    494                           case OS_TASK_PEND_ON_TASK_SEM:
    495                                break;
    496          
    497                           case OS_TASK_PEND_ON_FLAG:                 /* Remove from wait list                                  */
    498                           case OS_TASK_PEND_ON_MULTI:
    499                           case OS_TASK_PEND_ON_MUTEX:
    500                           case OS_TASK_PEND_ON_Q:
    501                           case OS_TASK_PEND_ON_SEM:
    502                                OS_PendListRemove(p_tcb);
    503                                break;
    504          
    505                           default:
    506                                break;
    507                       }
    508                       break;
    509          
    510                  default:
    511                      OS_CRITICAL_EXIT();
    512                      *p_err = OS_ERR_STATE_INVALID;
    513                      return;
    514              }
    515          
    516          #if OS_CFG_TASK_Q_EN > 0u
    517              (void)OS_MsgQFreeAll(&p_tcb->MsgQ);                     /* Free task's message queue messages                     */
    518          #endif
    519          
    520              OSTaskDelHook(p_tcb);                                   /* Call user defined hook                                 */
    521          
    522          #if OS_CFG_DBG_EN > 0u
    523              OS_TaskDbgListRemove(p_tcb);
    524          #endif
    525              OSTaskQty--;                                            /* One less task being managed                            */
    526          
    527              OS_TaskInitTCB(p_tcb);                                  /* Initialize the TCB to default values                   */
    528              p_tcb->TaskState = (OS_STATE)OS_TASK_STATE_DEL;         /* Indicate that the task was deleted                     */
    529          
    530              OS_CRITICAL_EXIT_NO_SCHED();
    531              OSSched();                                              /* Find new highest priority task                         */
    532          
    533              *p_err = OS_ERR_NONE;
    534          }
    535          #endif
    536          
    537          /*$PAGE*/
    538          /*
    539          ************************************************************************************************************************
    540          *                                                    FLUSH TASK's QUEUE
    541          *
    542          * Description: This function is used to flush the task's internal message queue.
    543          *
    544          * Arguments  : p_tcb       is a pointer to the task's OS_TCB.  Specifying a NULL pointer indicates that you wish to
    545          *                          flush the message queue of the calling task.
    546          *
    547          *              p_err       is a pointer to a variable that will contain an error code returned by this function.
    548          *
    549          *                              OS_ERR_NONE           upon success
    550          *                              OS_ERR_FLUSH_ISR      if you called this function from an ISR
    551          *
    552          * Returns     : The number of entries freed from the queue
    553          *
    554          * Note(s)     : 1) You should use this function with great care because, when to flush the queue, you LOOSE the
    555          *                  references to what the queue entries are pointing to and thus, you could cause 'memory leaks'.  In
    556          *                  other words, the data you are pointing to that's being referenced by the queue entries should, most
    557          *                  likely, need to be de-allocated (i.e. freed).
    558          ************************************************************************************************************************
    559          */
    560          
    561          #if OS_CFG_TASK_Q_EN > 0u
    562          OS_MSG_QTY  OSTaskQFlush (OS_TCB  *p_tcb,
    563                                    OS_ERR  *p_err)
    564          {
    565              OS_MSG_QTY  entries;
    566              CPU_SR_ALLOC();
    567          
    568          
    569          
    570          #ifdef OS_SAFETY_CRITICAL
    571              if (p_err == (OS_ERR *)0) {
    572                  OS_SAFETY_CRITICAL_EXCEPTION();
    573                  return ((OS_MSG_QTY)0);
    574              }
    575          #endif
    576          
    577          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    578              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't flush a message queue from an ISR                */
    579                 *p_err = OS_ERR_FLUSH_ISR;
    580                  return ((OS_MSG_QTY)0);
    581              }
    582          #endif
    583          
    584              if (p_tcb == (OS_TCB *)0) {                             /* Flush message queue of calling task?                   */
    585                  CPU_CRITICAL_ENTER();
    586                  p_tcb = OSTCBCurPtr;
    587                  CPU_CRITICAL_EXIT();
    588              }
    589          
    590              OS_CRITICAL_ENTER();
    591              entries = OS_MsgQFreeAll(&p_tcb->MsgQ);                 /* Return all OS_MSGs to the OS_MSG pool                  */
    592              OS_CRITICAL_EXIT();
    593              *p_err  = OS_ERR_NONE;
    594              return (entries);
    595          }
    596          #endif
    597          
    598          /*$PAGE*/
    599          /*
    600          ************************************************************************************************************************
    601          *                                                  WAIT FOR A MESSAGE
    602          *
    603          * Description: This function causes the current task to wait for a message to be posted to it.
    604          *
    605          * Arguments  : timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will wait for a
    606          *                            message to arrive up to the amount of time specified by this argument.
    607          *                            If you specify 0, however, your task will wait forever or, until a message arrives.
    608          *
    609          *              opt           determines whether the user wants to block if the task's queue is empty or not:
    610          *
    611          *                                OS_OPT_PEND_BLOCKING
    612          *                                OS_OPT_PEND_NON_BLOCKING
    613          *
    614          *              p_msg_size    is a pointer to a variable that will receive the size of the message
    615          *
    616          *              p_ts          is a pointer to a variable that will receive the timestamp of when the message was
    617          *                            received.  If you pass a NULL pointer (i.e. (CPU_TS *)0) then you will not get the
    618          *                            timestamp.  In other words, passing a NULL pointer is valid and indicates that you don't
    619          *                            need the timestamp.
    620          *
    621          *              p_err         is a pointer to where an error message will be deposited.  Possible error
    622          *                            messages are:
    623          *
    624          *                                OS_ERR_NONE               The call was successful and your task received a message.
    625          *                                OS_ERR_PEND_ABORT
    626          *                                OS_ERR_PEND_ISR           If you called this function from an ISR and the result
    627          *                                OS_ERR_PEND_WOULD_BLOCK   If you specified non-blocking but the queue was not empty
    628          *                                OS_ERR_Q_EMPTY
    629          *                                OS_ERR_SCHED_LOCKED       If the scheduler is locked
    630          *                                OS_ERR_TIMEOUT            A message was not received within the specified timeout
    631          *                                                          would lead to a suspension.
    632          *
    633          * Returns    : A pointer to the message received or a NULL pointer upon error.
    634          *
    635          * Note(s)    : 1) It is possible to receive NULL pointers when there are no errors.
    636          ************************************************************************************************************************
    637          */
    638          
    639          #if OS_CFG_TASK_Q_EN > 0u
    640          void  *OSTaskQPend (OS_TICK        timeout,
    641                              OS_OPT         opt,
    642                              OS_MSG_SIZE   *p_msg_size,
    643                              CPU_TS        *p_ts,
    644                              OS_ERR        *p_err)
    645          {
    646              OS_MSG_Q     *p_msg_q;
    647              void         *p_void;
    648              CPU_SR_ALLOC();
    649          
    650          
    651          
    652          #ifdef OS_SAFETY_CRITICAL
    653              if (p_err == (OS_ERR *)0) {
    654                  OS_SAFETY_CRITICAL_EXCEPTION();
    655                  return ((void *)0);
    656              }
    657          #endif
    658          
    659          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    660              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't Pend from an ISR                                 */
    661                 *p_err = OS_ERR_PEND_ISR;
    662                  return ((void *)0);
    663              }
    664          #endif
    665          
    666          #if OS_CFG_ARG_CHK_EN > 0u                                  /* ---------------- VALIDATE ARGUMENTS ------------------ */
    667              if (p_msg_size == (OS_MSG_SIZE *)0) {                   /* User must supply a valid destination for msg size      */
    668                  *p_err = OS_ERR_PTR_INVALID;
    669                  return ((void *)0);
    670              }
    671              switch (opt) {                                          /* User must supply a valid option                        */
    672                  case OS_OPT_PEND_BLOCKING:
    673                  case OS_OPT_PEND_NON_BLOCKING:
    674                       break;
    675          
    676                  default:
    677                       *p_err = OS_ERR_OPT_INVALID;
    678                       return ((void *)0);
    679              }
    680          #endif
    681          
    682              if (p_ts != (CPU_TS *)0) {
    683                  *p_ts = (CPU_TS  )0;                                /* Initialize the returned timestamp                      */
    684              }
    685          
    686              CPU_CRITICAL_ENTER();
    687              p_msg_q = &OSTCBCurPtr->MsgQ;                           /* Any message waiting in the message queue?              */
    688              p_void  = OS_MsgQGet(p_msg_q,
    689                                   p_msg_size,
    690                                   p_ts,
    691                                   p_err);
    692              if (*p_err == OS_ERR_NONE) {
    693          #if OS_CFG_TASK_PROFILE_EN > 0u
    694                  if (p_ts != (CPU_TS *)0) {
    695                      OSTCBCurPtr->MsgQPendTime = OS_TS_GET() - *p_ts;
    696                      if (OSTCBCurPtr->MsgQPendTime > OSTCBCurPtr->MsgQPendTimeMax) {
    697                          OSTCBCurPtr->MsgQPendTimeMax = OSTCBCurPtr->MsgQPendTime;
    698                      }
    699                  }
    700          #endif
    701                  CPU_CRITICAL_EXIT();
    702                  return (p_void);                                    /* Yes, Return oldest message received                    */
    703              }
    704          
    705              if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {    /* Caller wants to block if not available?                */
    706                  *p_err = OS_ERR_PEND_WOULD_BLOCK;                   /* No                                                     */
    707                  CPU_CRITICAL_EXIT();
    708                  return ((void *)0);
    709              } else {                                                /* Yes                                                    */
    710                  if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /*     Can't block when the scheduler is locked           */
    711                      CPU_CRITICAL_EXIT();
    712                      *p_err = OS_ERR_SCHED_LOCKED;
    713                      return ((void *)0);
    714                  }
    715              }
    716          
    717              OS_CRITICAL_ENTER_CPU_CRITICAL_EXIT();                  /* Lock the scheduler/re-enable interrupts                */
    718              OS_Pend((OS_PEND_DATA *)0,                              /* Block task pending on Message                          */
    719                      (OS_PEND_OBJ  *)0,
    720                      (OS_STATE      )OS_TASK_PEND_ON_TASK_Q,
    721                      (OS_TICK       )timeout);
    722              OS_CRITICAL_EXIT_NO_SCHED();
    723          
    724              OSSched();                                              /* Find the next highest priority task ready to run       */
    725          
    726              CPU_CRITICAL_ENTER();
    727              switch (OSTCBCurPtr->PendStatus) {
    728                  case OS_STATUS_PEND_OK:                             /* Extract message from TCB (Put there by Post)           */
    729                       p_void      = OSTCBCurPtr->MsgPtr;
    730                       *p_msg_size = OSTCBCurPtr->MsgSize;
    731                       if (p_ts != (CPU_TS *)0) {
    732                          *p_ts  = OSTCBCurPtr->TS;
    733          #if OS_CFG_TASK_PROFILE_EN > 0u
    734                          OSTCBCurPtr->MsgQPendTime = OS_TS_GET() - OSTCBCurPtr->TS;
    735                          if (OSTCBCurPtr->MsgQPendTime > OSTCBCurPtr->MsgQPendTimeMax) {
    736                              OSTCBCurPtr->MsgQPendTimeMax = OSTCBCurPtr->MsgQPendTime;
    737                          }
    738          #endif
    739                       }
    740                       *p_err = OS_ERR_NONE;
    741                       break;
    742          
    743                  case OS_STATUS_PEND_ABORT:                          /* Indicate that we aborted                               */
    744                       p_void      = (void      *)0;
    745                       *p_msg_size = (OS_MSG_SIZE)0;
    746                       if (p_ts != (CPU_TS *)0) {
    747                          *p_ts  = (CPU_TS  )0;
    748                       }
    749                       *p_err =  OS_ERR_PEND_ABORT;
    750                       break;
    751          
    752                  case OS_STATUS_PEND_TIMEOUT:                        /* Indicate that we didn't get event within TO            */
    753                  default:
    754                       p_void      = (void      *)0;
    755                       *p_msg_size = (OS_MSG_SIZE)0;
    756                       if (p_ts != (CPU_TS *)0) {
    757                          *p_ts  =  OSTCBCurPtr->TS;
    758                       }
    759                       *p_err =  OS_ERR_TIMEOUT;
    760                       break;
    761              }
    762              CPU_CRITICAL_EXIT();
    763              return (p_void);                                        /* Return received message                                */
    764          }
    765          #endif
    766          
    767          /*$PAGE*/
    768          /*
    769          ************************************************************************************************************************
    770          *                                              ABORT WAITING FOR A MESSAGE
    771          *
    772          * Description: This function aborts & readies the task specified.  This function should be used to fault-abort the wait
    773          *              for a message, rather than to normally post the message to the task via OSTaskQPost().
    774          *
    775          * Arguments  : p_tcb     is a pointer to the task to pend abort
    776          *
    777          *              opt       provides options for this function:
    778          *
    779          *                            OS_OPT_POST_NONE         No option specified
    780          *                            OS_OPT_POST_NO_SCHED     Indicates that the scheduler will not be called.
    781          *
    782          *              p_err     is a pointer to a variable that will contain an error code returned by this function.
    783          *
    784          *                            OS_ERR_NONE              If the task was readied and informed of the aborted wait
    785          *                            OS_ERR_PEND_ABORT_ISR    If you called this function from an ISR
    786          *                            OS_ERR_PEND_ABORT_NONE   If task was not pending on a message and thus there is nothing to
    787          *                                                     abort.
    788          *                            OS_ERR_PEND_ABORT_SELF   If you passed a NULL pointer for 'p_tcb'
    789          *
    790          * Returns    : == DEF_FALSE   if task was not waiting for a message, or upon error.
    791          *              == DEF_TRUE    if task was waiting for a message and was readied and informed.
    792          ************************************************************************************************************************
    793          */
    794          
    795          #if (OS_CFG_TASK_Q_EN > 0u) && (OS_CFG_TASK_Q_PEND_ABORT_EN > 0u)
    796          CPU_BOOLEAN  OSTaskQPendAbort (OS_TCB  *p_tcb,
    797                                         OS_OPT   opt,
    798                                         OS_ERR  *p_err)
    799          {
    800              CPU_TS         ts;
    801              CPU_SR_ALLOC();
    802          
    803          
    804          
    805          #ifdef OS_SAFETY_CRITICAL
    806              if (p_err == (OS_ERR *)0) {
    807                  OS_SAFETY_CRITICAL_EXCEPTION();
    808                  return (DEF_FALSE);
    809              }
    810          #endif
    811          
    812          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    813              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from ISR ...                             */
    814                 *p_err = OS_ERR_PEND_ABORT_ISR;                      /* ... can't Pend Abort from an ISR                       */
    815                  return (DEF_FALSE);
    816              }
    817          #endif
    818          
    819              CPU_CRITICAL_ENTER();
    820          #if OS_CFG_ARG_CHK_EN > 0u
    821              if ((p_tcb == (OS_TCB *)0) ||                           /* Pend abort self?                                       */
    822                  (p_tcb == OSTCBCurPtr)) {
    823                  CPU_CRITICAL_EXIT();
    824                  *p_err = OS_ERR_PEND_ABORT_SELF;                    /* ... doesn't make sense                                 */
    825                  return (DEF_FALSE);
    826              }
    827          #endif
    828          
    829              if (p_tcb->PendOn != OS_TASK_PEND_ON_TASK_Q) {          /* Is task waiting for a message?                         */
    830                  CPU_CRITICAL_EXIT();                                /* No                                                     */
    831                  *p_err = OS_ERR_PEND_ABORT_NONE;
    832                  return (DEF_FALSE);
    833              }
    834          
    835              OS_CRITICAL_ENTER_CPU_CRITICAL_EXIT();
    836              ts = OS_TS_GET();                                       /* Get timestamp of when the abort occurred               */
    837              OS_PendAbort((OS_PEND_OBJ *)0,                          /* Abort the pend                                         */
    838                           p_tcb,
    839                           ts);
    840              OS_CRITICAL_EXIT_NO_SCHED();
    841              if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
    842                  OSSched();                                          /* Run the scheduler                                      */
    843              }
    844              *p_err = OS_ERR_NONE;
    845              return (DEF_TRUE);
    846          }
    847          #endif
    848          
    849          /*$PAGE*/
    850          /*
    851          ************************************************************************************************************************
    852          *                                               POST MESSAGE TO A TASK
    853          *
    854          * Description: This function sends a message to a task
    855          *
    856          * Arguments  : p_tcb      is a pointer to the TCB of the task receiving a message.  If you specify a NULL pointer then
    857          *                         the message will be posted to the task's queue of the calling task.  In other words, you'd be
    858          *                         posting a message to yourself.
    859          *
    860          *              p_void     is a pointer to the message to send.
    861          *
    862          *              msg_size   is the size of the message sent (in #bytes)
    863          *
    864          *              opt        specifies whether the post will be FIFO or LIFO:
    865          *
    866          *                             OS_OPT_POST_FIFO       Post at the end   of the queue
    867          *                             OS_OPT_POST_LIFO       Post at the front of the queue
    868          *
    869          *                             OS_OPT_POST_NO_SCHED   Do not run the scheduler after the post
    870          *
    871          *                          Note(s): 1) OS_OPT_POST_NO_SCHED can be added with one of the other options.
    872          *
    873          *
    874          *              p_err      is a pointer to a variable that will hold the error code associated
    875          *                         with the outcome of this call.  Errors can be:
    876          *
    877          *                             OS_ERR_NONE            The call was successful and the message was sent
    878          *                             OS_ERR_Q_MAX           If the queue is full
    879          *                             OS_ERR_MSG_POOL_EMPTY  If there are no more OS_MSGs available from the pool
    880          *
    881          * Returns    : none
    882          ************************************************************************************************************************
    883          */
    884          
    885          #if OS_CFG_TASK_Q_EN > 0u
    886          void  OSTaskQPost (OS_TCB      *p_tcb,
    887                             void        *p_void,
    888                             OS_MSG_SIZE  msg_size,
    889                             OS_OPT       opt,
    890                             OS_ERR      *p_err)
    891          {
    892              CPU_TS   ts;
    893          
    894          
    895          
    896          #ifdef OS_SAFETY_CRITICAL
    897              if (p_err == (OS_ERR *)0) {
    898                  OS_SAFETY_CRITICAL_EXCEPTION();
    899                  return;
    900              }
    901          #endif
    902          
    903              ts = OS_TS_GET();                                       /* Get timestamp                                          */
    904          
    905          #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
    906              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {
    907                  OS_IntQPost((OS_OBJ_TYPE)OS_OBJ_TYPE_TASK_MSG,      /* Post to ISR queue                                      */
    908                              (void      *)p_tcb,
    909                              (void      *)p_void,
    910                              (OS_MSG_SIZE)msg_size,
    911                              (OS_FLAGS   )0,
    912                              (OS_OPT     )opt,
    913                              (CPU_TS     )ts,
    914                              (OS_ERR    *)p_err);
    915                  return;
    916              }
    917          #endif
    918          
    919              OS_TaskQPost(p_tcb,
    920                           p_void,
    921                           msg_size,
    922                           opt,
    923                           ts,
    924                           p_err);
    925          }
    926          #endif
    927          
    928          /*$PAGE*/
    929          /*
    930          ************************************************************************************************************************
    931          *                                       GET THE CURRENT VALUE OF A TASK REGISTER
    932          *
    933          * Description: This function is called to obtain the current value of a task register.  Task registers are application
    934          *              specific and can be used to store task specific values such as 'error numbers' (i.e. errno), statistics,
    935          *              etc.
    936          *
    937          * Arguments  : p_tcb     is a pointer to the OS_TCB of the task you want to read the register from.  If 'p_tcb' is a
    938          *                        NULL pointer then you will get the register of the current task.
    939          *
    940          *              id        is the 'id' of the desired task variable.  Note that the 'id' must be less than
    941          *                        OS_CFG_TASK_REG_TBL_SIZE
    942          *
    943          *              p_err     is a pointer to a variable that will hold an error code related to this call.
    944          *
    945          *                            OS_ERR_NONE            if the call was successful
    946          *                            OS_ERR_REG_ID_INVALID  if the 'id' is not between 0 and OS_CFG_TASK_REG_TBL_SIZE-1
    947          *
    948          * Returns    : The current value of the task's register or 0 if an error is detected.
    949          ************************************************************************************************************************
    950          */
    951          
    952          #if OS_CFG_TASK_REG_TBL_SIZE > 0u
    953          OS_REG  OSTaskRegGet (OS_TCB     *p_tcb,
    954                                OS_REG_ID   id,
    955                                OS_ERR     *p_err)
    956          {
    957              OS_REG     value;
    958              CPU_SR_ALLOC();
    959          
    960          
    961          
    962          #ifdef OS_SAFETY_CRITICAL
    963              if (p_err == (OS_ERR *)0) {
    964                  OS_SAFETY_CRITICAL_EXCEPTION();
    965                  return ((OS_REG)0);
    966              }
    967          #endif
    968          
    969          #if OS_CFG_ARG_CHK_EN > 0u
    970              if (id >= OS_CFG_TASK_REG_TBL_SIZE) {
    971                 *p_err = OS_ERR_REG_ID_INVALID;
    972                  return ((OS_REG)0);
    973              }
    974          #endif
    975          
    976              CPU_CRITICAL_ENTER();
    977              if (p_tcb == (OS_TCB *)0) {
    978                  p_tcb = OSTCBCurPtr;
    979              }
    980              value  = p_tcb->RegTbl[id];
    981              CPU_CRITICAL_EXIT();
    982              *p_err = OS_ERR_NONE;
    983              return ((OS_REG)value);
    984          }
    985          #endif
    986          
    987          /*$PAGE*/
    988          /*
    989          ************************************************************************************************************************
    990          *                                       SET THE CURRENT VALUE OF A TASK REGISTER
    991          *
    992          * Description: This function is called to change the current value of a task register.  Task registers are application
    993          *              specific and can be used to store task specific values such as 'error numbers' (i.e. errno), statistics,
    994          *              etc.
    995          *
    996          * Arguments  : p_tcb     is a pointer to the OS_TCB of the task you want to set the register for.  If 'p_tcb' is a NULL
    997          *                        pointer then you will change the register of the current task.
    998          *
    999          *              id        is the 'id' of the desired task register.  Note that the 'id' must be less than
   1000          *                        OS_CFG_TASK_REG_TBL_SIZE
   1001          *
   1002          *              value     is the desired value for the task register.
   1003          *
   1004          *              p_err     is a pointer to a variable that will hold an error code related to this call.
   1005          *
   1006          *                            OS_ERR_NONE            if the call was successful
   1007          *                            OS_ERR_REG_ID_INVALID  if the 'id' is not between 0 and OS_CFG_TASK_REG_TBL_SIZE-1
   1008          *
   1009          * Returns    : none
   1010          ************************************************************************************************************************
   1011          */
   1012          
   1013          #if OS_CFG_TASK_REG_TBL_SIZE > 0u
   1014          void  OSTaskRegSet (OS_TCB    *p_tcb,
   1015                              OS_REG_ID  id,
   1016                              OS_REG     value,
   1017                              OS_ERR    *p_err)
   1018          {
   1019              CPU_SR_ALLOC();
   1020          
   1021          
   1022          
   1023          #ifdef OS_SAFETY_CRITICAL
   1024              if (p_err == (OS_ERR *)0) {
   1025                  OS_SAFETY_CRITICAL_EXCEPTION();
   1026                  return;
   1027              }
   1028          #endif
   1029          
   1030          #if OS_CFG_ARG_CHK_EN > 0u
   1031              if (id >= OS_CFG_TASK_REG_TBL_SIZE) {
   1032                 *p_err = OS_ERR_REG_ID_INVALID;
   1033                  return;
   1034              }
   1035          #endif
   1036          
   1037              CPU_CRITICAL_ENTER();
   1038              if (p_tcb == (OS_TCB *)0) {
   1039                  p_tcb = OSTCBCurPtr;
   1040              }
   1041              p_tcb->RegTbl[id] = value;
   1042              CPU_CRITICAL_EXIT();
   1043              *p_err            = OS_ERR_NONE;
   1044          }
   1045          #endif
   1046          
   1047          /*$PAGE*/
   1048          /*
   1049          ************************************************************************************************************************
   1050          *                                               RESUME A SUSPENDED TASK
   1051          *
   1052          * Description: This function is called to resume a previously suspended task.  This is the only call that will remove an
   1053          *              explicit task suspension.
   1054          *
   1055          * Arguments  : p_tcb      Is a pointer to the task's OS_TCB to resume
   1056          *
   1057          *              p_err      Is a pointer to a variable that will contain an error code returned by this function
   1058          *
   1059          *                             OS_ERR_NONE                  if the requested task is resumed
   1060          *                             OS_ERR_STATE_INVALID         if the task is in an invalid state
   1061          *                             OS_ERR_TASK_RESUME_ISR       if you called this function from an ISR
   1062          *                             OS_ERR_TASK_RESUME_SELF      You cannot resume 'self'
   1063          *                             OS_ERR_TASK_NOT_SUSPENDED    if the task to resume has not been suspended
   1064          *
   1065          * Returns    : none
   1066          ************************************************************************************************************************
   1067          */
   1068          
   1069          #if OS_CFG_TASK_SUSPEND_EN > 0u
   1070          void  OSTaskResume (OS_TCB  *p_tcb,
   1071                              OS_ERR  *p_err)
   1072          {
   1073              CPU_SR_ALLOC();
   1074          
   1075          
   1076          
   1077          #ifdef OS_SAFETY_CRITICAL
   1078              if (p_err == (OS_ERR *)0) {
   1079                  OS_SAFETY_CRITICAL_EXCEPTION();
   1080                  return;
   1081              }
   1082          #endif
   1083          
   1084          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
   1085              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
   1086                 *p_err = OS_ERR_TASK_RESUME_ISR;
   1087                  return;
   1088              }
   1089          #endif
   1090          
   1091          
   1092              CPU_CRITICAL_ENTER();
   1093          #if OS_CFG_ARG_CHK_EN > 0u
   1094              if ((p_tcb == (OS_TCB *)0) ||                           /* We cannot resume 'self'                                */
   1095                  (p_tcb == OSTCBCurPtr)) {
   1096                  CPU_CRITICAL_EXIT();
   1097                  *p_err = OS_ERR_TASK_RESUME_SELF;
   1098                  return;
   1099              }
   1100          #endif
   1101          
   1102              *p_err  = OS_ERR_NONE;
   1103              switch (p_tcb->TaskState) {
   1104                  case OS_TASK_STATE_RDY:
   1105                  case OS_TASK_STATE_DLY:
   1106                  case OS_TASK_STATE_PEND:
   1107                  case OS_TASK_STATE_PEND_TIMEOUT:
   1108                       CPU_CRITICAL_EXIT();
   1109                       *p_err = OS_ERR_TASK_NOT_SUSPENDED;
   1110                       break;
   1111          
   1112                  case OS_TASK_STATE_SUSPENDED:
   1113                       OS_CRITICAL_ENTER_CPU_CRITICAL_EXIT();
   1114                       p_tcb->SuspendCtr--;
   1115                       if (p_tcb->SuspendCtr == (OS_NESTING_CTR)0) {
   1116                           p_tcb->TaskState = OS_TASK_STATE_RDY;
   1117                           OS_TaskRdy(p_tcb);
   1118                       }
   1119                       OS_CRITICAL_EXIT_NO_SCHED();
   1120                       break;
   1121          
   1122                  case OS_TASK_STATE_DLY_SUSPENDED:
   1123                       p_tcb->SuspendCtr--;
   1124                       if (p_tcb->SuspendCtr == (OS_NESTING_CTR)0) {
   1125                           p_tcb->TaskState = OS_TASK_STATE_DLY;
   1126                       }
   1127                       CPU_CRITICAL_EXIT();
   1128                       break;
   1129          
   1130                  case OS_TASK_STATE_PEND_SUSPENDED:
   1131                       p_tcb->SuspendCtr--;
   1132                       if (p_tcb->SuspendCtr == (OS_NESTING_CTR)0) {
   1133                           p_tcb->TaskState = OS_TASK_STATE_PEND;
   1134                       }
   1135                       CPU_CRITICAL_EXIT();
   1136                       break;
   1137          
   1138                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
   1139                       p_tcb->SuspendCtr--;
   1140                       if (p_tcb->SuspendCtr == (OS_NESTING_CTR)0) {
   1141                           p_tcb->TaskState = OS_TASK_STATE_PEND_TIMEOUT;
   1142                       }
   1143                       CPU_CRITICAL_EXIT();
   1144                       break;
   1145          
   1146                  default:
   1147                       CPU_CRITICAL_EXIT();
   1148                       *p_err = OS_ERR_STATE_INVALID;
   1149                       return;
   1150              }
   1151          
   1152              OSSched();
   1153          }
   1154          #endif
   1155          
   1156          /*$PAGE*/
   1157          /*
   1158          ************************************************************************************************************************
   1159          *                                              WAIT FOR A TASK SEMAPHORE
   1160          *
   1161          * Description: This function is called to block the current task until a signal is sent by another task or ISR.
   1162          *
   1163          * Arguments  : timeout       is the amount of time you are will to wait for the signal
   1164          *
   1165          *              opt           determines whether the user wants to block if a semaphore post was not received:
   1166          *
   1167          *                                OS_OPT_PEND_BLOCKING
   1168          *                                OS_OPT_PEND_NON_BLOCKING
   1169          *
   1170          *              p_ts          is a pointer to a variable that will receive the timestamp of when the semaphore was posted
   1171          *                            or pend aborted.  If you pass a NULL pointer (i.e. (CPU_TS *)0) then you will not get the
   1172          *                            timestamp.  In other words, passing a NULL pointer is valid and indicates that you don't
   1173          *                            need the timestamp.
   1174          *
   1175          *              p_err         is a pointer to an error code that will be set by this function
   1176          *
   1177          *                                OS_ERR_NONE               The call was successful and your task received a message.
   1178          *                                OS_ERR_PEND_ABORT
   1179          *                                OS_ERR_PEND_ISR           If you called this function from an ISR and the result
   1180          *                                OS_ERR_PEND_WOULD_BLOCK   If you specified non-blocking but no signal was received
   1181          *                                OS_ERR_SCHED_LOCKED       If the scheduler is locked
   1182          *                                OS_ERR_STATUS_INVALID     If the pend status is invalid
   1183          *                                OS_ERR_TIMEOUT            A message was not received within the specified timeout
   1184          *                                                          would lead to a suspension.
   1185          *
   1186          * Returns    : The current count of signals the task received, 0 if none.
   1187          ************************************************************************************************************************
   1188          */
   1189          

   \                                 In  segment CODE, align 1, keep-with-next
   1190          OS_SEM_CTR  OSTaskSemPend (OS_TICK   timeout,
   \                     OSTaskSemPend:
   1191                                     OS_OPT    opt,
   1192                                     CPU_TS   *p_ts,
   1193                                     OS_ERR   *p_err)
   1194          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 4
   \   000000 C3                    PUSH      BC                 ;; 1 cycle
   \   000001 C1                    PUSH      AX                 ;; 1 cycle
   \   000002 C5                    PUSH      DE                 ;; 1 cycle
   \   000003                       ; Auto size: 14
   \   000003 2008                  SUBW      SP, #0x8           ;; 1 cycle
   1195              OS_SEM_CTR    ctr;
   1196              CPU_SR_ALLOC();
   1197          
   1198          
   1199          
   1200          #ifdef OS_SAFETY_CRITICAL
   1201              if (p_err == (OS_ERR *)0) {
   1202                  OS_SAFETY_CRITICAL_EXCEPTION();
   1203                  return ((OS_SEM_CTR)0);
   1204              }
   1205          #endif
   1206          
   1207          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
   1208              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
   1209                 *p_err = OS_ERR_PEND_ISR;
   1210                  return ((OS_SEM_CTR)0);
   1211              }
   1212          #endif
   1213          
   1214              if (p_ts != (CPU_TS *)0) {
   \   000005 A812                  MOVW      AX, [SP+0x12]      ;; 1 cycle
   \   000007 440000                CMPW      AX, #0x0           ;; 1 cycle
   \   00000A DD05                  BZ        ??OS_TaskSemPost_5  ;; 4 cycles
   \   00000C                       ; ------------------------------------- Block: 10 cycles
   1215                 *p_ts  = (CPU_TS  )0;                                /* Initialize the returned timestamp                      */
   \   00000C 16                    MOVW      HL, AX             ;; 1 cycle
   \   00000D F6                    CLRW      AX                 ;; 1 cycle
   \   00000E BB                    MOVW      [HL], AX           ;; 1 cycle
   \   00000F BC02                  MOVW      [HL+0x02], AX      ;; 1 cycle
   \   000011                       ; ------------------------------------- Block: 4 cycles
   1216              }
   1217          
   1218              CPU_CRITICAL_ENTER();
   \                     ??OS_TaskSemPost_5:
   \   000011 8EFA                  MOV       A, PSW             ;; 1 cycle
   \   000013 70                    MOV       X, A               ;; 1 cycle
   \   000014 F1                    CLRB      A                  ;; 1 cycle
   \   000015 B800                  MOVW      [SP], AX           ;; 1 cycle
   \   000017 F6                    CLRW      AX                 ;; 1 cycle
   \   000018 B802                  MOVW      [SP+0x02], AX      ;; 1 cycle
   \   00001A 717BFA                DI                           ;; 2 cycles
   \   00001D FD....                CALL      CPU_IntDisMeasStart  ;; 3 cycles
   1219              if (OSTCBCurPtr->SemCtr > (OS_SEM_CTR)0) {              /* See if task already been signaled                      */
   \   000020 AF....                MOVW      AX, N:OSTCBCurPtr  ;; 1 cycle
   \   000023 FD....                CALL      N:?Subroutine3     ;; 3 cycles
   \   000026                       ; ------------------------------------- Block: 15 cycles
   \                     ??CrossCallReturnLabel_15:
   \   000026 33                    XCHW      AX, BC             ;; 1 cycle
   \   000027 440000                CMPW      AX, #0x0           ;; 1 cycle
   \   00002A 13                    MOVW      AX, BC             ;; 1 cycle
   \   00002B DF02                  BNZ       ??OS_TaskSemPost_6  ;; 4 cycles
   \   00002D                       ; ------------------------------------- Block: 7 cycles
   \   00002D F7                    CLRW      BC                 ;; 1 cycle
   \   00002E 43                    CMPW      AX, BC             ;; 1 cycle
   \   00002F                       ; ------------------------------------- Block: 2 cycles
   \                     ??OS_TaskSemPost_6:
   \   00002F DD3B                  BZ        ??OS_TaskSemPost_7  ;; 4 cycles
   \   000031                       ; ------------------------------------- Block: 4 cycles
   1220                  OSTCBCurPtr->SemCtr--;
   \   000031 AC02                  MOVW      AX, [HL+0x02]      ;; 1 cycle
   \   000033 12                    MOVW      BC, AX             ;; 1 cycle
   \   000034 AB                    MOVW      AX, [HL]           ;; 1 cycle
   \   000035 240100                SUBW      AX, #0x1           ;; 1 cycle
   \   000038 61D8                  SKNC
   \   00003A B3                    DECW      BC                 ;; 5 cycles
   \   00003B BB                    MOVW      [HL], AX           ;; 1 cycle
   \   00003C 13                    MOVW      AX, BC             ;; 1 cycle
   \   00003D BC02                  MOVW      [HL+0x02], AX      ;; 1 cycle
   1221                  ctr    = OSTCBCurPtr->SemCtr;
   \   00003F AB                    MOVW      AX, [HL]           ;; 1 cycle
   \   000040 B804                  MOVW      [SP+0x04], AX      ;; 1 cycle
   \   000042 13                    MOVW      AX, BC             ;; 1 cycle
   \   000043 B806                  MOVW      [SP+0x06], AX      ;; 1 cycle
   1222                  if (p_ts != (CPU_TS *)0) {
   \   000045 A812                  MOVW      AX, [SP+0x12]      ;; 1 cycle
   \   000047 440000                CMPW      AX, #0x0           ;; 1 cycle
   \   00004A DD0D                  BZ        ??OS_TaskSemPost_8  ;; 4 cycles
   \   00004C                       ; ------------------------------------- Block: 22 cycles
   1223                     *p_ts  = OSTCBCurPtr->TS;
   \   00004C FB....                MOVW      HL, N:OSTCBCurPtr  ;; 1 cycle
   \   00004F FD....                CALL      N:?Subroutine2     ;; 3 cycles
   \   000052                       ; ------------------------------------- Block: 4 cycles
   1224                  }
   \                     ??CrossCallReturnLabel_12:
   \   000052 A812                  MOVW      AX, [SP+0x12]      ;; 1 cycle
   \   000054 37                    XCHW      AX, HL             ;; 1 cycle
   \   000055 BB                    MOVW      [HL], AX           ;; 1 cycle
   \   000056 13                    MOVW      AX, BC             ;; 1 cycle
   \   000057 BC02                  MOVW      [HL+0x02], AX      ;; 1 cycle
   \   000059                       ; ------------------------------------- Block: 5 cycles
   1225          #if OS_CFG_TASK_PROFILE_EN > 0u
   1226                  OSTCBCurPtr->SemPendTime = OS_TS_GET() - OSTCBCurPtr->TS;
   1227                  if (OSTCBCurPtr->SemPendTime > OSTCBCurPtr->SemPendTimeMax) {
   1228                      OSTCBCurPtr->SemPendTimeMax = OSTCBCurPtr->SemPendTime;
   1229                  }
   1230          #endif
   1231                  CPU_CRITICAL_EXIT();
   \                     ??OS_TaskSemPost_8:
   \   000059 FD....                CALL      CPU_IntDisMeasStop  ;; 3 cycles
   \   00005C 8800                  MOV       A, [SP]            ;; 1 cycle
   \   00005E FD....                CALL      N:?Subroutine1     ;; 3 cycles
   \   000061                       ; ------------------------------------- Block: 7 cycles
   1232                  *p_err = OS_ERR_NONE;
   \                     ??CrossCallReturnLabel_2:
   \   000061 A814                  MOVW      AX, [SP+0x14]      ;; 1 cycle
   \   000063 16                    MOVW      HL, AX             ;; 1 cycle
   \   000064 F6                    CLRW      AX                 ;; 1 cycle
   \   000065 BB                    MOVW      [HL], AX           ;; 1 cycle
   1233                  return (ctr);
   \   000066 A806                  MOVW      AX, [SP+0x06]      ;; 1 cycle
   \   000068 12                    MOVW      BC, AX             ;; 1 cycle
   \   000069 ED....                BR        N:??CrossCallReturnLabel_6  ;; 3 cycles
   \   00006C                       ; ------------------------------------- Block: 9 cycles
   1234              }
   1235          
   1236              if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {    /* Caller wants to block if not available?                */
   \                     ??OS_TaskSemPost_7:
   \   00006C AEF8                  MOVW      AX, SP             ;; 1 cycle
   \   00006E 040800                ADDW      AX, #0x8           ;; 1 cycle
   \   000071 16                    MOVW      HL, AX             ;; 1 cycle
   \   000072 A7                    INCW      HL                 ;; 1 cycle
   \   000073 31F510                BF        [HL].7, ??OS_TaskSemPost_9  ;; 5 cycles
   \   000076                       ; ------------------------------------- Block: 9 cycles
   1237                  CPU_CRITICAL_EXIT();
   \   000076 FD....                CALL      CPU_IntDisMeasStop  ;; 3 cycles
   \   000079 8800                  MOV       A, [SP]            ;; 1 cycle
   \   00007B FD....                CALL      N:?Subroutine1     ;; 3 cycles
   \   00007E                       ; ------------------------------------- Block: 7 cycles
   1238                  *p_err = OS_ERR_PEND_WOULD_BLOCK;                   /* No                                                     */
   \                     ??CrossCallReturnLabel_3:
   \   00007E A814                  MOVW      AX, [SP+0x14]      ;; 1 cycle
   \   000080 16                    MOVW      HL, AX             ;; 1 cycle
   \   000081 30B061                MOVW      AX, #0x61B0        ;; 1 cycle
   \   000084 EF13                  BR        S:??OS_TaskSemPost_10  ;; 3 cycles
   \   000086                       ; ------------------------------------- Block: 6 cycles
   1239                  return ((OS_SEM_CTR)0);
   1240              } else {                                                /* Yes                                                    */
   1241                  if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /* Can't pend when the scheduler is locked                */
   \                     ??OS_TaskSemPost_9:
   \   000086 D5....                CMP0      N:OSSchedLockNestingCtr  ;; 1 cycle
   \   000089 DD14                  BZ        ??OS_TaskSemPost_11  ;; 4 cycles
   \   00008B                       ; ------------------------------------- Block: 5 cycles
   1242                      CPU_CRITICAL_EXIT();
   \   00008B FD....                CALL      CPU_IntDisMeasStop  ;; 3 cycles
   \   00008E 8800                  MOV       A, [SP]            ;; 1 cycle
   \   000090 FD....                CALL      N:?Subroutine1     ;; 3 cycles
   \   000093                       ; ------------------------------------- Block: 7 cycles
   1243                      *p_err = OS_ERR_SCHED_LOCKED;
   \                     ??CrossCallReturnLabel_4:
   \   000093 A814                  MOVW      AX, [SP+0x14]      ;; 1 cycle
   \   000095 16                    MOVW      HL, AX             ;; 1 cycle
   \   000096 30636D                MOVW      AX, #0x6D63        ;; 1 cycle
   \   000099                       ; ------------------------------------- Block: 3 cycles
   \                     ??OS_TaskSemPost_10:
   \   000099 BB                    MOVW      [HL], AX           ;; 1 cycle
   1244                      return ((OS_SEM_CTR)0);
   \   00009A F6                    CLRW      AX                 ;; 1 cycle
   \   00009B F7                    CLRW      BC                 ;; 1 cycle
   \   00009C ED....                BR        N:??OS_TaskSemPost_12  ;; 3 cycles
   \   00009F                       ; ------------------------------------- Block: 6 cycles
   1245                  }
   1246              }
   1247          
   1248              OS_CRITICAL_ENTER_CPU_CRITICAL_EXIT();                  /* Lock the scheduler/re-enable interrupts                */
   1249              OS_Pend((OS_PEND_DATA *)0,                              /* Block task pending on Signal                           */
   1250                      (OS_PEND_OBJ  *)0,
   1251                      (OS_STATE      )OS_TASK_PEND_ON_TASK_SEM,
   1252                      (OS_TICK       )timeout);
   \                     ??OS_TaskSemPost_11:
   \   00009F A80C                  MOVW      AX, [SP+0x0C]      ;; 1 cycle
   \   0000A1 12                    MOVW      BC, AX             ;; 1 cycle
   \   0000A2 A80A                  MOVW      AX, [SP+0x0A]      ;; 1 cycle
   \   0000A4 C3                    PUSH      BC                 ;; 1 cycle
   \   0000A5 C1                    PUSH      AX                 ;; 1 cycle
   \   0000A6 5507                  MOV       D, #0x7            ;; 1 cycle
   \   0000A8 F7                    CLRW      BC                 ;; 1 cycle
   \   0000A9 F6                    CLRW      AX                 ;; 1 cycle
   \   0000AA FD....                CALL      OS_Pend            ;; 3 cycles
   1253              OS_CRITICAL_EXIT_NO_SCHED();
   \   0000AD FD....                CALL      CPU_IntDisMeasStop  ;; 3 cycles
   \   0000B0 8800                  MOV       A, [SP]            ;; 1 cycle
   \   0000B2 FD....                CALL      N:?Subroutine1     ;; 3 cycles
   \   0000B5                       ; ------------------------------------- Block: 18 cycles
   1254          
   1255              OSSched();                                              /* Find next highest priority task ready to run           */
   \                     ??CrossCallReturnLabel_5:
   \   0000B5 FD....                CALL      OSSched            ;; 3 cycles
   1256          
   1257              CPU_CRITICAL_ENTER();
   \   0000B8 8EFA                  MOV       A, PSW             ;; 1 cycle
   \   0000BA 70                    MOV       X, A               ;; 1 cycle
   \   0000BB F1                    CLRB      A                  ;; 1 cycle
   \   0000BC B800                  MOVW      [SP], AX           ;; 1 cycle
   \   0000BE 717BFA                DI                           ;; 2 cycles
   \   0000C1 FD....                CALL      CPU_IntDisMeasStart  ;; 3 cycles
   1258              switch (OSTCBCurPtr->PendStatus) {                      /* See if we timed-out or aborted                         */
   \   0000C4 FB....                MOVW      HL, N:OSTCBCurPtr  ;; 1 cycle
   \   0000C7 8C1B                  MOV       A, [HL+0x1B]       ;; 1 cycle
   \   0000C9 D1                    CMP0      A                  ;; 1 cycle
   \   0000CA DD09                  BZ        ??OS_TaskSemPost_13  ;; 4 cycles
   \   0000CC                       ; ------------------------------------- Block: 19 cycles
   \   0000CC 91                    DEC       A                  ;; 1 cycle
   \   0000CD DD1D                  BZ        ??OS_TaskSemPost_14  ;; 4 cycles
   \   0000CF                       ; ------------------------------------- Block: 5 cycles
   \   0000CF 2C02                  SUB       A, #0x2            ;; 1 cycle
   \   0000D1 DD32                  BZ        ??OS_TaskSemPost_15  ;; 4 cycles
   \   0000D3                       ; ------------------------------------- Block: 5 cycles
   \   0000D3 EF44                  BR        S:??OS_TaskSemPost_16  ;; 3 cycles
   \   0000D5                       ; ------------------------------------- Block: 3 cycles
   1259                  case OS_STATUS_PEND_OK:
   1260                       if (p_ts != (CPU_TS *)0) {
   \                     ??OS_TaskSemPost_13:
   \   0000D5 A812                  MOVW      AX, [SP+0x12]      ;; 1 cycle
   \   0000D7 440000                CMPW      AX, #0x0           ;; 1 cycle
   \   0000DA DD0A                  BZ        ??OS_TaskSemPost_17  ;; 4 cycles
   \   0000DC                       ; ------------------------------------- Block: 6 cycles
   1261                          *p_ts                    =  OSTCBCurPtr->TS;
   \   0000DC FD....                CALL      N:?Subroutine2     ;; 3 cycles
   \   0000DF                       ; ------------------------------------- Block: 3 cycles
   1262          #if OS_CFG_TASK_PROFILE_EN > 0u
   1263                          OSTCBCurPtr->SemPendTime = OS_TS_GET() - OSTCBCurPtr->TS;
   1264                          if (OSTCBCurPtr->SemPendTime > OSTCBCurPtr->SemPendTimeMax) {
   1265                              OSTCBCurPtr->SemPendTimeMax = OSTCBCurPtr->SemPendTime;
   1266                          }
   1267          #endif
   1268                       }
   \                     ??CrossCallReturnLabel_13:
   \   0000DF A812                  MOVW      AX, [SP+0x12]      ;; 1 cycle
   \   0000E1 37                    XCHW      AX, HL             ;; 1 cycle
   \   0000E2 BB                    MOVW      [HL], AX           ;; 1 cycle
   \   0000E3 13                    MOVW      AX, BC             ;; 1 cycle
   \   0000E4 BC02                  MOVW      [HL+0x02], AX      ;; 1 cycle
   \   0000E6                       ; ------------------------------------- Block: 5 cycles
   1269                       *p_err = OS_ERR_NONE;
   \                     ??OS_TaskSemPost_17:
   \   0000E6 A814                  MOVW      AX, [SP+0x14]      ;; 1 cycle
   \   0000E8 16                    MOVW      HL, AX             ;; 1 cycle
   \   0000E9 F6                    CLRW      AX                 ;; 1 cycle
   \   0000EA EF33                  BR        S:??OS_TaskSemPost_18  ;; 3 cycles
   \   0000EC                       ; ------------------------------------- Block: 6 cycles
   1270                       break;
   1271          
   1272                  case OS_STATUS_PEND_ABORT:
   1273                       if (p_ts != (CPU_TS *)0) {
   \                     ??OS_TaskSemPost_14:
   \   0000EC A812                  MOVW      AX, [SP+0x12]      ;; 1 cycle
   \   0000EE 440000                CMPW      AX, #0x0           ;; 1 cycle
   \   0000F1 DD0A                  BZ        ??OS_TaskSemPost_19  ;; 4 cycles
   \   0000F3                       ; ------------------------------------- Block: 6 cycles
   1274                          *p_ts  =  OSTCBCurPtr->TS;
   \   0000F3 FD....                CALL      N:?Subroutine2     ;; 3 cycles
   \   0000F6                       ; ------------------------------------- Block: 3 cycles
   1275                       }
   \                     ??CrossCallReturnLabel_14:
   \   0000F6 A812                  MOVW      AX, [SP+0x12]      ;; 1 cycle
   \   0000F8 37                    XCHW      AX, HL             ;; 1 cycle
   \   0000F9 BB                    MOVW      [HL], AX           ;; 1 cycle
   \   0000FA 13                    MOVW      AX, BC             ;; 1 cycle
   \   0000FB BC02                  MOVW      [HL+0x02], AX      ;; 1 cycle
   \   0000FD                       ; ------------------------------------- Block: 5 cycles
   1276                       *p_err = OS_ERR_PEND_ABORT;                    /* Indicate that we aborted                               */
   \                     ??OS_TaskSemPost_19:
   \   0000FD A814                  MOVW      AX, [SP+0x14]      ;; 1 cycle
   \   0000FF 16                    MOVW      HL, AX             ;; 1 cycle
   \   000100 30A961                MOVW      AX, #0x61A9        ;; 1 cycle
   \   000103 EF1A                  BR        S:??OS_TaskSemPost_18  ;; 3 cycles
   \   000105                       ; ------------------------------------- Block: 6 cycles
   1277                       break;
   1278          
   1279                  case OS_STATUS_PEND_TIMEOUT:
   1280                       if (p_ts != (CPU_TS *)0) {
   \                     ??OS_TaskSemPost_15:
   \   000105 A812                  MOVW      AX, [SP+0x12]      ;; 1 cycle
   \   000107 440000                CMPW      AX, #0x0           ;; 1 cycle
   \   00010A DD05                  BZ        ??OS_TaskSemPost_20  ;; 4 cycles
   \   00010C                       ; ------------------------------------- Block: 6 cycles
   1281                          *p_ts  = (CPU_TS  )0;
   \   00010C 16                    MOVW      HL, AX             ;; 1 cycle
   \   00010D F6                    CLRW      AX                 ;; 1 cycle
   \   00010E BB                    MOVW      [HL], AX           ;; 1 cycle
   \   00010F BC02                  MOVW      [HL+0x02], AX      ;; 1 cycle
   \   000111                       ; ------------------------------------- Block: 4 cycles
   1282                       }
   1283                       *p_err = OS_ERR_TIMEOUT;                       /* Indicate that we didn't get event within TO            */
   \                     ??OS_TaskSemPost_20:
   \   000111 A814                  MOVW      AX, [SP+0x14]      ;; 1 cycle
   \   000113 16                    MOVW      HL, AX             ;; 1 cycle
   \   000114 30D972                MOVW      AX, #0x72D9        ;; 1 cycle
   \   000117 EF06                  BR        S:??OS_TaskSemPost_18  ;; 3 cycles
   \   000119                       ; ------------------------------------- Block: 6 cycles
   1284                       break;
   1285          
   1286                  default:
   1287                       *p_err = OS_ERR_STATUS_INVALID;
   \                     ??OS_TaskSemPost_16:
   \   000119 A814                  MOVW      AX, [SP+0x14]      ;; 1 cycle
   \   00011B 16                    MOVW      HL, AX             ;; 1 cycle
   \   00011C 302B6E                MOVW      AX, #0x6E2B        ;; 1 cycle
   \   00011F                       ; ------------------------------------- Block: 3 cycles
   \                     ??OS_TaskSemPost_18:
   \   00011F BB                    MOVW      [HL], AX           ;; 1 cycle
   1288                       break;
   1289              }
   1290              ctr = OSTCBCurPtr->SemCtr;
   \   000120 FB....                MOVW      HL, N:OSTCBCurPtr  ;; 1 cycle
   \   000123 AC2A                  MOVW      AX, [HL+0x2A]      ;; 1 cycle
   \   000125 12                    MOVW      BC, AX             ;; 1 cycle
   \   000126 AC28                  MOVW      AX, [HL+0x28]      ;; 1 cycle
   \   000128 B804                  MOVW      [SP+0x04], AX      ;; 1 cycle
   \   00012A 13                    MOVW      AX, BC             ;; 1 cycle
   \   00012B B806                  MOVW      [SP+0x06], AX      ;; 1 cycle
   1291              CPU_CRITICAL_EXIT();
   \   00012D FD....                CALL      CPU_IntDisMeasStop  ;; 3 cycles
   \   000130 8800                  MOV       A, [SP]            ;; 1 cycle
   \   000132 FD....                CALL      N:?Subroutine1     ;; 3 cycles
   1292              return (ctr);
   \   000135                       ; ------------------------------------- Block: 15 cycles
   \                     ??CrossCallReturnLabel_6:
   \   000135 A804                  MOVW      AX, [SP+0x04]      ;; 1 cycle
   \   000137                       ; ------------------------------------- Block: 1 cycles
   \                     ??OS_TaskSemPost_12:
   \   000137 100E                  ADDW      SP, #0xE           ;; 1 cycle
   \   000139                       ; ------------------------------------- Block: 1 cycles
   \   000139                       ; ------------------------------------- Total: 258 cycles
   \   000139                       REQUIRE ?CLRL78_V1_0_L00
   \   000139                       REQUIRE ?Subroutine0
   \   000139                       ; // Fall through to label ?Subroutine0
   1293          }

   \                                 In  segment CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000 FD....                CALL      N:?FUNC_LEAVE_L06
   \   000003 0400                  DW        0x4                ;; 3 cycles
   \   000005                       ; ------------------------------------- Block: 3 cycles
   \   000005                       ; ------------------------------------- Total: 3 cycles
   \   000005                       REQUIRE ?CLRL78_V1_0_L00

   \                                 In  segment CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000 AC26                  MOVW      AX, [HL+0x26]      ;; 1 cycle
   \   000002 12                    MOVW      BC, AX             ;; 1 cycle
   \   000003 AC24                  MOVW      AX, [HL+0x24]      ;; 1 cycle
   \   000005 16                    MOVW      HL, AX             ;; 1 cycle
   \   000006 D7                    RET                          ;; 6 cycles
   \   000007                       ; ------------------------------------- Block: 10 cycles
   \   000007                       ; ------------------------------------- Total: 10 cycles
   \   000007                       REQUIRE ?CLRL78_V1_0_L00

   \                                 In  segment CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000 042800                ADDW      AX, #0x28          ;; 1 cycle
   \   000003 16                    MOVW      HL, AX             ;; 1 cycle
   \   000004 AC02                  MOVW      AX, [HL+0x02]      ;; 1 cycle
   \   000006 12                    MOVW      BC, AX             ;; 1 cycle
   \   000007 AB                    MOVW      AX, [HL]           ;; 1 cycle
   \   000008 D7                    RET                          ;; 6 cycles
   \   000009                       ; ------------------------------------- Block: 11 cycles
   \   000009                       ; ------------------------------------- Total: 11 cycles
   \   000009                       REQUIRE ?CLRL78_V1_0_L00
   1294          
   1295          /*$PAGE*/
   1296          /*
   1297          ************************************************************************************************************************
   1298          *                                               ABORT WAITING FOR A SIGNAL
   1299          *
   1300          * Description: This function aborts & readies the task specified.  This function should be used to fault-abort the wait
   1301          *              for a signal, rather than to normally post the signal to the task via OSTaskSemPost().
   1302          *
   1303          * Arguments  : p_tcb     is a pointer to the task to pend abort
   1304          *
   1305          *              opt       provides options for this function:
   1306          *
   1307          *                            OS_OPT_POST_NONE         No option selected
   1308          *                            OS_OPT_POST_NO_SCHED     Indicates that the scheduler will not be called.
   1309          *
   1310          *              p_err     is a pointer to a variable that will contain an error code returned by this function.
   1311          *
   1312          *                            OS_ERR_NONE              If the task was readied and informed of the aborted wait
   1313          *                            OS_ERR_PEND_ABORT_ISR    If you tried calling this function from an ISR
   1314          *                            OS_ERR_PEND_ABORT_NONE   If the task was not waiting for a signal
   1315          *                            OS_ERR_PEND_ABORT_SELF   If you attempted to pend abort the calling task.  This is not
   1316          *                                                     possible since the calling task cannot be pending because it's
   1317          *                                                     running.
   1318          *
   1319          * Returns    : == DEF_FALSE   if task was not waiting for a message, or upon error.
   1320          *              == DEF_TRUE    if task was waiting for a message and was readied and informed.
   1321          ************************************************************************************************************************
   1322          */
   1323          
   1324          #if OS_CFG_TASK_SEM_PEND_ABORT_EN > 0u
   1325          CPU_BOOLEAN  OSTaskSemPendAbort (OS_TCB  *p_tcb,
   1326                                           OS_OPT   opt,
   1327                                           OS_ERR  *p_err)
   1328          {
   1329              CPU_TS         ts;
   1330              CPU_SR_ALLOC();
   1331          
   1332          
   1333          
   1334          #ifdef OS_SAFETY_CRITICAL
   1335              if (p_err == (OS_ERR *)0) {
   1336                  OS_SAFETY_CRITICAL_EXCEPTION();
   1337                  return (DEF_FALSE);
   1338              }
   1339          #endif
   1340          
   1341          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
   1342              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from ISR ...                             */
   1343                 *p_err = OS_ERR_PEND_ABORT_ISR;                      /* ... can't Pend Abort from an ISR                       */
   1344                  return (DEF_FALSE);
   1345              }
   1346          #endif
   1347          
   1348              CPU_CRITICAL_ENTER();
   1349              if ((p_tcb == (OS_TCB *)0) ||                           /* Pend abort self?                                       */
   1350                  (p_tcb == OSTCBCurPtr)) {
   1351                  CPU_CRITICAL_EXIT();                                /* ... doesn't make sense!                                */
   1352                  *p_err = OS_ERR_PEND_ABORT_SELF;
   1353                  return (DEF_FALSE);
   1354              }
   1355          
   1356              if (p_tcb->PendOn != OS_TASK_PEND_ON_TASK_SEM) {        /* Is task waiting for a signal?                          */
   1357                  CPU_CRITICAL_EXIT();
   1358                  *p_err = OS_ERR_PEND_ABORT_NONE;
   1359                  return (DEF_FALSE);
   1360              }
   1361              CPU_CRITICAL_EXIT();
   1362          
   1363              OS_CRITICAL_ENTER();
   1364              ts = OS_TS_GET();
   1365              OS_PendAbort((OS_PEND_OBJ *)0,
   1366                           p_tcb,
   1367                           ts);
   1368              OS_CRITICAL_EXIT_NO_SCHED();
   1369              if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
   1370                  OSSched();                                          /* Run the scheduler                                      */
   1371              }
   1372              *p_err = OS_ERR_NONE;
   1373              return (DEF_TRUE);
   1374          }
   1375          #endif
   1376          
   1377          /*$PAGE*/
   1378          /*
   1379          ************************************************************************************************************************
   1380          *                                                    SIGNAL A TASK
   1381          *
   1382          * Description: This function is called to signal a task waiting for a signal.
   1383          *
   1384          * Arguments  : p_tcb     is the pointer to the TCB of the task to signal.  A NULL pointer indicates that you are sending
   1385          *                        a signal to yourself.
   1386          *
   1387          *              opt       determines the type of POST performed:
   1388          *
   1389          *                             OS_OPT_POST_NONE         No option
   1390          *                             OS_OPT_POST_NO_SCHED     Do not call the scheduler
   1391          *
   1392          *              p_err     is a pointer to an error code returned by this function:
   1393          *
   1394          *                            OS_ERR_NONE              If the requested task is signaled
   1395          *                            OS_ERR_SEM_OVF           If the post would cause the semaphore count to overflow.
   1396          *
   1397          * Returns    : The current value of the task's signal counter or 0 if called from an ISR
   1398          ************************************************************************************************************************
   1399          */
   1400          

   \                                 In  segment CODE, align 1, keep-with-next
   1401          OS_SEM_CTR  OSTaskSemPost (OS_TCB  *p_tcb,
   \                     OSTaskSemPost:
   1402                                     OS_OPT   opt,
   1403                                     OS_ERR  *p_err)
   1404          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000                       ; Auto size: 0
   \   000000 16                    MOVW      HL, AX             ;; 1 cycle
   1405              OS_SEM_CTR  ctr;
   1406              CPU_TS      ts;
   1407          
   1408          
   1409          
   1410          #ifdef OS_SAFETY_CRITICAL
   1411              if (p_err == (OS_ERR *)0) {
   1412                  OS_SAFETY_CRITICAL_EXCEPTION();
   1413                  return ((OS_SEM_CTR)0);
   1414              }
   1415          #endif
   1416          
   1417              ts = OS_TS_GET();                                       /* Get timestamp                                          */
   1418          
   1419          #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
   1420              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from an ISR                              */
   1421                  OS_IntQPost((OS_OBJ_TYPE)OS_OBJ_TYPE_TASK_SIGNAL,   /* Post to ISR queue                                      */
   1422                              (void      *)p_tcb,
   1423                              (void      *)0,
   1424                              (OS_MSG_SIZE)0,
   1425                              (OS_FLAGS   )0,
   1426                              (OS_OPT     )0,
   1427                              (CPU_TS     )ts,
   1428                              (OS_ERR    *)p_err);
   1429                  return ((OS_SEM_CTR)0);
   1430              }
   1431          #endif
   1432          
   1433              ctr = OS_TaskSemPost(p_tcb,
   1434                                   opt,
   1435                                   ts,
   1436                                   p_err);
   1437          
   1438              return (ctr);
   \   000001 F6                    CLRW      AX                 ;; 1 cycle
   \   000002 C1                    PUSH      AX                 ;; 1 cycle
   \   000003 C1                    PUSH      AX                 ;; 1 cycle
   \   000004 17                    MOVW      AX, HL             ;; 1 cycle
   \   000005 FD....                CALL      OS_TaskSemPost     ;; 3 cycles
   \   000008 D7                    RET                          ;; 6 cycles
   \   000009                       ; ------------------------------------- Block: 14 cycles
   \   000009                       ; ------------------------------------- Total: 14 cycles
   \   000009                       REQUIRE ?CLRL78_V1_0_L00
   1439          }
   1440          
   1441          /*$PAGE*/
   1442          /*
   1443          ************************************************************************************************************************
   1444          *                                            SET THE SIGNAL COUNTER OF A TASK
   1445          *
   1446          * Description: This function is called to clear the signal counter
   1447          *
   1448          * Arguments  : p_tcb      is the pointer to the TCB of the task to clear the counter.  If you specify a NULL pointer
   1449          *                         then the signal counter of the current task will be cleared.
   1450          *
   1451          *              cnt        is the desired value of the semaphore counter
   1452          *
   1453          *              p_err      is a pointer to an error code returned by this function
   1454          *
   1455          *                             OS_ERR_NONE        if the signal counter of the requested task is cleared
   1456          *                             OS_ERR_SET_ISR     if the function was called from an ISR
   1457          *
   1458          * Returns    : none
   1459          ************************************************************************************************************************
   1460          */
   1461          

   \                                 In  segment CODE, align 1, keep-with-next
   1462          OS_SEM_CTR  OSTaskSemSet (OS_TCB      *p_tcb,
   \                     OSTaskSemSet:
   1463                                    OS_SEM_CTR   cnt,
   1464                                    OS_ERR      *p_err)
   1465          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 4
   \   000000 C5                    PUSH      DE                 ;; 1 cycle
   \   000001 C3                    PUSH      BC                 ;; 1 cycle
   \   000002                       ; Auto size: 10
   \   000002 2008                  SUBW      SP, #0x8           ;; 1 cycle
   \   000004 14                    MOVW      DE, AX             ;; 1 cycle
   1466              OS_SEM_CTR  ctr;
   1467              CPU_SR_ALLOC();
   1468          
   1469          
   1470          
   1471          #ifdef OS_SAFETY_CRITICAL
   1472              if (p_err == (OS_ERR *)0) {
   1473                  OS_SAFETY_CRITICAL_EXCEPTION();
   1474                  return ((OS_SEM_CTR)0);
   1475              }
   1476          #endif
   1477          
   1478          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
   1479              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
   1480                 *p_err = OS_ERR_SET_ISR;
   1481                  return ((OS_SEM_CTR)0);
   1482              }
   1483          #endif
   1484          
   1485              CPU_CRITICAL_ENTER();
   \   000005 8EFA                  MOV       A, PSW             ;; 1 cycle
   \   000007 70                    MOV       X, A               ;; 1 cycle
   \   000008 F1                    CLRB      A                  ;; 1 cycle
   \   000009 B804                  MOVW      [SP+0x04], AX      ;; 1 cycle
   \   00000B F6                    CLRW      AX                 ;; 1 cycle
   \   00000C B806                  MOVW      [SP+0x06], AX      ;; 1 cycle
   \   00000E 717BFA                DI                           ;; 2 cycles
   \   000011 FD....                CALL      CPU_IntDisMeasStart  ;; 3 cycles
   1486              if (p_tcb == (OS_TCB *)0) {
   \   000014 15                    MOVW      AX, DE             ;; 1 cycle
   \   000015 440000                CMPW      AX, #0x0           ;; 1 cycle
   \   000018 61F8                  SKNZ                         ;; 4 cycles
   \   00001A                       ; ------------------------------------- Block: 21 cycles
   1487                  p_tcb = OSTCBCurPtr;
   \   00001A EB....                MOVW      DE, N:OSTCBCurPtr  ;; 1 cycle
   \   00001D                       ; ------------------------------------- Block: 1 cycles
   1488              }
   1489              ctr           = p_tcb->SemCtr;
   \                     ??OSTaskSemSet_0:
   \   00001D AA2A                  MOVW      AX, [DE+0x2A]      ;; 1 cycle
   \   00001F 12                    MOVW      BC, AX             ;; 1 cycle
   \   000020 AA28                  MOVW      AX, [DE+0x28]      ;; 1 cycle
   \   000022 B800                  MOVW      [SP], AX           ;; 1 cycle
   \   000024 13                    MOVW      AX, BC             ;; 1 cycle
   \   000025 B802                  MOVW      [SP+0x02], AX      ;; 1 cycle
   1490              p_tcb->SemCtr = (OS_SEM_CTR)cnt;
   \   000027 A812                  MOVW      AX, [SP+0x12]      ;; 1 cycle
   \   000029 12                    MOVW      BC, AX             ;; 1 cycle
   \   00002A A810                  MOVW      AX, [SP+0x10]      ;; 1 cycle
   \   00002C BA28                  MOVW      [DE+0x28], AX      ;; 1 cycle
   \   00002E 13                    MOVW      AX, BC             ;; 1 cycle
   \   00002F BA2A                  MOVW      [DE+0x2A], AX      ;; 1 cycle
   1491              CPU_CRITICAL_EXIT();
   \   000031 FD....                CALL      CPU_IntDisMeasStop  ;; 3 cycles
   \   000034 8804                  MOV       A, [SP+0x04]       ;; 1 cycle
   \   000036 FD....                CALL      N:?Subroutine1     ;; 3 cycles
   \   000039                       ; ------------------------------------- Block: 19 cycles
   1492              *p_err        =  OS_ERR_NONE;
   \                     ??CrossCallReturnLabel_7:
   \   000039 A808                  MOVW      AX, [SP+0x08]      ;; 1 cycle
   \   00003B 16                    MOVW      HL, AX             ;; 1 cycle
   \   00003C F6                    CLRW      AX                 ;; 1 cycle
   \   00003D BB                    MOVW      [HL], AX           ;; 1 cycle
   1493              return (ctr);
   \   00003E A802                  MOVW      AX, [SP+0x02]      ;; 1 cycle
   \   000040 12                    MOVW      BC, AX             ;; 1 cycle
   \   000041 A800                  MOVW      AX, [SP]           ;; 1 cycle
   \   000043 100A                  ADDW      SP, #0xA           ;; 1 cycle
   \   000045 C4                    POP       DE                 ;; 1 cycle
   \   000046 ED....                BR        N:?Subroutine0     ;; 3 cycles
   \   000049                       ; ------------------------------------- Block: 12 cycles
   \   000049                       ; ------------------------------------- Total: 53 cycles
   \   000049                       REQUIRE ?CLRL78_V1_0_L00
   1494          }
   1495          
   1496          /*$PAGE*/
   1497          /*
   1498          ************************************************************************************************************************
   1499          *                                                    STACK CHECKING
   1500          *
   1501          * Description: This function is called to calculate the amount of free memory left on the specified task's stack.
   1502          *
   1503          * Arguments  : p_tcb       is a pointer to the TCB of the task to check.  If you specify a NULL pointer then
   1504          *                          you are specifying that you want to check the stack of the current task.
   1505          *
   1506          *              p_free      is a pointer to a variable that will receive the number of free 'entries' on the task's stack.
   1507          *
   1508          *              p_used      is a pointer to a variable that will receive the number of used 'entries' on the task's stack.
   1509          *
   1510          *              p_err       is a pointer to a variable that will contain an error code.
   1511          *
   1512          *                              OS_ERR_NONE               upon success
   1513          *                              OS_ERR_PTR_INVALID        if either 'p_free' or 'p_used' are NULL pointers
   1514          *                              OS_ERR_TASK_NOT_EXIST     if the stack pointer of the task is a NULL pointer
   1515          *                              OS_ERR_TASK_OPT           if you did NOT specified OS_OPT_TASK_STK_CHK when the task
   1516          *                                                        was created
   1517          *                              OS_ERR_TASK_STK_CHK_ISR   you called this function from an ISR
   1518          ************************************************************************************************************************
   1519          */
   1520          
   1521          #if OS_CFG_STAT_TASK_STK_CHK_EN > 0u
   1522          void  OSTaskStkChk (OS_TCB       *p_tcb,
   1523                              CPU_STK_SIZE *p_free,
   1524                              CPU_STK_SIZE *p_used,
   1525                              OS_ERR       *p_err)
   1526          {
   1527              CPU_STK_SIZE  free_stk;
   1528              CPU_STK      *p_stk;
   1529              CPU_SR_ALLOC();
   1530          
   1531          
   1532          
   1533          #ifdef OS_SAFETY_CRITICAL
   1534              if (p_err == (OS_ERR *)0) {
   1535                  OS_SAFETY_CRITICAL_EXCEPTION();
   1536                  return;
   1537              }
   1538          #endif
   1539          
   1540          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
   1541              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to check stack from ISR                  */
   1542                 *p_err = OS_ERR_TASK_STK_CHK_ISR;
   1543                  return;
   1544              }
   1545          #endif
   1546          
   1547          #if OS_CFG_ARG_CHK_EN > 0u
   1548              if (p_free == (CPU_STK_SIZE*)0) {                       /* User must specify valid destinations for the sizes     */
   1549                  *p_err = OS_ERR_PTR_INVALID;
   1550                  return;
   1551              }
   1552          
   1553              if (p_used == (CPU_STK_SIZE*)0) {
   1554                  *p_err = OS_ERR_PTR_INVALID;
   1555                  return;
   1556              }
   1557          #endif
   1558          
   1559              CPU_CRITICAL_ENTER();
   1560              if (p_tcb == (OS_TCB *)0) {                             /* Check the stack of the current task?                   */
   1561                  p_tcb = OSTCBCurPtr;                                /* Yes                                                    */
   1562              }
   1563          
   1564              if (p_tcb->StkPtr == (CPU_STK*)0) {                     /* Make sure task exist                                   */
   1565                  CPU_CRITICAL_EXIT();
   1566                  *p_free = (CPU_STK_SIZE)0;
   1567                  *p_used = (CPU_STK_SIZE)0;
   1568                  *p_err  =  OS_ERR_TASK_NOT_EXIST;
   1569                  return;
   1570              }
   1571          
   1572              if ((p_tcb->Opt & OS_OPT_TASK_STK_CHK) == (OS_OPT)0) {  /* Make sure stack checking option is set                 */
   1573                  CPU_CRITICAL_EXIT();
   1574                  *p_free = (CPU_STK_SIZE)0;
   1575                  *p_used = (CPU_STK_SIZE)0;
   1576                  *p_err  =  OS_ERR_TASK_OPT;
   1577                  return;
   1578              }
   1579              CPU_CRITICAL_EXIT();
   1580          
   1581              free_stk  = 0u;
   1582          #if CPU_CFG_STK_GROWTH == CPU_STK_GROWTH_HI_TO_LO
   1583              p_stk = p_tcb->StkBasePtr;                              /* Start at the lowest memory and go up                   */
   1584              while (*p_stk == (CPU_STK)0) {                          /* Compute the number of zero entries on the stk          */
   1585                  p_stk++;
   1586                  free_stk++;
   1587              }
   1588          #else
   1589              p_stk = p_tcb->StkBasePtr + p_tcb->StkSize - 1u;        /* Start at the highest memory and go down                */
   1590              while (*p_stk == (CPU_STK)0) {
   1591                  free_stk++;
   1592                  p_stk--;
   1593              }
   1594          #endif
   1595              *p_free = free_stk;
   1596              *p_used = (p_tcb->StkSize - free_stk);                  /* Compute number of entries used on the stack            */
   1597              *p_err  = OS_ERR_NONE;
   1598          }
   1599          #endif
   1600          
   1601          /*$PAGE*/
   1602          /*
   1603          ************************************************************************************************************************
   1604          *                                                   SUSPEND A TASK
   1605          *
   1606          * Description: This function is called to suspend a task.  The task can be the calling task if 'p_tcb' is a NULL pointer
   1607          *              or the pointer to the TCB of the calling task.
   1608          *
   1609          * Arguments  : p_tcb    is a pointer to the TCB to suspend.
   1610          *                       If p_tcb is a NULL pointer then, suspend the current task.
   1611          *
   1612          *              p_err    is a pointer to a variable that will receive an error code from this function.
   1613          *
   1614          *                           OS_ERR_NONE                      if the requested task is suspended
   1615          *                           OS_ERR_SCHED_LOCKED              you can't suspend the current task is the scheduler is
   1616          *                                                            locked
   1617          *                           OS_ERR_TASK_SUSPEND_ISR          if you called this function from an ISR
   1618          *                           OS_ERR_TASK_SUSPEND_IDLE         if you attempted to suspend the idle task which is not
   1619          *                                                            allowed.
   1620          *                           OS_ERR_TASK_SUSPEND_INT_HANDLER  if you attempted to suspend the idle task which is not
   1621          *                                                            allowed.
   1622          *
   1623          * Note(s)    : 1) You should use this function with great care.  If you suspend a task that is waiting for an event
   1624          *                 (i.e. a message, a semaphore, a queue ...) you will prevent this task from running when the event
   1625          *                 arrives.
   1626          ************************************************************************************************************************
   1627          */
   1628          
   1629          #if OS_CFG_TASK_SUSPEND_EN > 0u
   1630          void   OSTaskSuspend (OS_TCB  *p_tcb,
   1631                                OS_ERR  *p_err)
   1632          {
   1633              CPU_SR_ALLOC();
   1634          
   1635          
   1636          
   1637          #ifdef OS_SAFETY_CRITICAL
   1638              if (p_err == (OS_ERR *)0) {
   1639                  OS_SAFETY_CRITICAL_EXCEPTION();
   1640                  return;
   1641              }
   1642          #endif
   1643          
   1644          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
   1645              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
   1646                 *p_err = OS_ERR_TASK_SUSPEND_ISR;
   1647                  return;
   1648              }
   1649          #endif
   1650          
   1651              if (p_tcb == &OSIdleTaskTCB) {                          /* Make sure not suspending the idle task                 */
   1652                  *p_err = OS_ERR_TASK_SUSPEND_IDLE;
   1653                  return;
   1654              }
   1655          
   1656          #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
   1657              if (p_tcb == &OSIntQTaskTCB) {                          /* Not allowed to suspend the ISR handler task            */
   1658                  *p_err = OS_ERR_TASK_SUSPEND_INT_HANDLER;
   1659                  return;
   1660              }
   1661          #endif
   1662          
   1663              CPU_CRITICAL_ENTER();
   1664              if (p_tcb == (OS_TCB *)0) {                             /* See if specified to suspend self                       */
   1665                  p_tcb = OSTCBCurPtr;
   1666              }
   1667          
   1668              if (p_tcb == OSTCBCurPtr) {
   1669                  if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /* Can't suspend when the scheduler is locked             */
   1670                      CPU_CRITICAL_EXIT();
   1671                      *p_err = OS_ERR_SCHED_LOCKED;
   1672                      return;
   1673                  }
   1674              }
   1675          
   1676              *p_err = OS_ERR_NONE;
   1677              switch (p_tcb->TaskState) {
   1678                  case OS_TASK_STATE_RDY:
   1679                       OS_CRITICAL_ENTER_CPU_CRITICAL_EXIT();
   1680                       p_tcb->TaskState  =  OS_TASK_STATE_SUSPENDED;
   1681                       p_tcb->SuspendCtr = (OS_NESTING_CTR)1;
   1682                       OS_RdyListRemove(p_tcb);
   1683                       OS_CRITICAL_EXIT_NO_SCHED();
   1684                       break;
   1685          
   1686                  case OS_TASK_STATE_DLY:
   1687                       p_tcb->TaskState  = OS_TASK_STATE_DLY_SUSPENDED;
   1688                       p_tcb->SuspendCtr = (OS_NESTING_CTR)1;
   1689                       CPU_CRITICAL_EXIT();
   1690                       break;
   1691          
   1692                  case OS_TASK_STATE_PEND:
   1693                       p_tcb->TaskState  = OS_TASK_STATE_PEND_SUSPENDED;
   1694                       p_tcb->SuspendCtr = (OS_NESTING_CTR)1;
   1695                       CPU_CRITICAL_EXIT();
   1696                       break;
   1697          
   1698                  case OS_TASK_STATE_PEND_TIMEOUT:
   1699                       p_tcb->TaskState  = OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED;
   1700                       p_tcb->SuspendCtr = (OS_NESTING_CTR)1;
   1701                       CPU_CRITICAL_EXIT();
   1702                       break;
   1703          
   1704                  case OS_TASK_STATE_SUSPENDED:
   1705                  case OS_TASK_STATE_DLY_SUSPENDED:
   1706                  case OS_TASK_STATE_PEND_SUSPENDED:
   1707                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
   1708                       p_tcb->SuspendCtr++;
   1709                       CPU_CRITICAL_EXIT();
   1710                       break;
   1711          
   1712                  default:
   1713                       CPU_CRITICAL_EXIT();
   1714                       *p_err = OS_ERR_STATE_INVALID;
   1715                       return;
   1716              }
   1717          
   1718              OSSched();
   1719          }
   1720          #endif
   1721          
   1722          /*$PAGE*/
   1723          /*
   1724          ************************************************************************************************************************
   1725          *                                                CHANGE A TASK'S TIME SLICE
   1726          *
   1727          * Description: This function is called to change the value of the task's specific time slice.
   1728          *
   1729          * Arguments  : p_tcb        is the pointer to the TCB of the task to change. If you specify an NULL pointer, the current
   1730          *                           task is assumed.
   1731          *
   1732          *              time_quanta  is the number of ticks before the CPU is taken away when round-robin scheduling is enabled.
   1733          *
   1734          *              p_err        is a pointer to an error code returned by this function:
   1735          *
   1736          *                               OS_ERR_NONE       upon success
   1737          *                               OS_ERR_SET_ISR    if you called this function from an ISR
   1738          *
   1739          * Returns    : none
   1740          ************************************************************************************************************************
   1741          */
   1742          
   1743          #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
   1744          void  OSTaskTimeQuantaSet (OS_TCB   *p_tcb,
   1745                                     OS_TICK   time_quanta,
   1746                                     OS_ERR   *p_err)
   1747          {
   1748              CPU_SR_ALLOC();
   1749          
   1750          
   1751          
   1752          #ifdef OS_SAFETY_CRITICAL
   1753              if (p_err == (OS_ERR *)0) {
   1754                  OS_SAFETY_CRITICAL_EXCEPTION();
   1755                  return;
   1756              }
   1757          #endif
   1758          
   1759          #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
   1760              if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't call this function from an ISR                   */
   1761                 *p_err = OS_ERR_SET_ISR;
   1762                  return;
   1763              }
   1764          #endif
   1765          
   1766              CPU_CRITICAL_ENTER();
   1767              if (p_tcb == (OS_TCB *)0) {
   1768                  p_tcb = OSTCBCurPtr;
   1769              }
   1770          
   1771              if (time_quanta == 0u) {
   1772                  p_tcb->TimeQuanta    = OSSchedRoundRobinDfltTimeQuanta;
   1773              } else {
   1774                  p_tcb->TimeQuanta    = time_quanta;
   1775              }
   1776              if (p_tcb->TimeQuanta > p_tcb->TimeQuantaCtr) {
   1777                  p_tcb->TimeQuantaCtr = p_tcb->TimeQuanta;
   1778              }
   1779              CPU_CRITICAL_EXIT();
   1780              *p_err = OS_ERR_NONE;
   1781          }
   1782          #endif
   1783          
   1784          /*$PAGE*/
   1785          /*
   1786          ************************************************************************************************************************
   1787          *                                            ADD/REMOVE TASK TO/FROM DEBUG LIST
   1788          *
   1789          * Description: These functions are called by uC/OS-III to add or remove an OS_TCB from the debug list.
   1790          *
   1791          * Arguments  : p_tcb     is a pointer to the OS_TCB to add/remove
   1792          *
   1793          * Returns    : none
   1794          *
   1795          * Note(s)    : These functions are INTERNAL to uC/OS-III and your application should not call it.
   1796          ************************************************************************************************************************
   1797          */
   1798          
   1799          #if OS_CFG_DBG_EN > 0u
   1800          void  OS_TaskDbgListAdd (OS_TCB  *p_tcb)
   1801          {
   1802              p_tcb->DbgPrevPtr                = (OS_TCB *)0;
   1803              if (OSTaskDbgListPtr == (OS_TCB *)0) {
   1804                  p_tcb->DbgNextPtr            = (OS_TCB *)0;
   1805              } else {
   1806                  p_tcb->DbgNextPtr            =  OSTaskDbgListPtr;
   1807                  OSTaskDbgListPtr->DbgPrevPtr =  p_tcb;
   1808              }
   1809              OSTaskDbgListPtr                 =  p_tcb;
   1810          }
   1811          
   1812          
   1813          
   1814          void  OS_TaskDbgListRemove (OS_TCB  *p_tcb)
   1815          {
   1816              OS_TCB  *p_tcb_next;
   1817              OS_TCB  *p_tcb_prev;
   1818          
   1819          
   1820              p_tcb_prev = p_tcb->DbgPrevPtr;
   1821              p_tcb_next = p_tcb->DbgNextPtr;
   1822          
   1823              if (p_tcb_prev == (OS_TCB *)0) {
   1824                  OSTaskDbgListPtr = p_tcb_next;
   1825                  if (p_tcb_next != (OS_TCB *)0) {
   1826                      p_tcb_next->DbgPrevPtr = (OS_TCB *)0;
   1827                  }
   1828                  p_tcb->DbgNextPtr = (OS_TCB *)0;
   1829          
   1830              } else if (p_tcb_next == (OS_TCB *)0) {
   1831                  p_tcb_prev->DbgNextPtr = (OS_TCB *)0;
   1832                  p_tcb->DbgPrevPtr      = (OS_TCB *)0;
   1833          
   1834              } else {
   1835                  p_tcb_prev->DbgNextPtr =  p_tcb_next;
   1836                  p_tcb_next->DbgPrevPtr =  p_tcb_prev;
   1837                  p_tcb->DbgNextPtr      = (OS_TCB *)0;
   1838                  p_tcb->DbgPrevPtr      = (OS_TCB *)0;
   1839              }
   1840          }
   1841          #endif
   1842          
   1843          /*$PAGE*/
   1844          /*
   1845          ************************************************************************************************************************
   1846          *                                             TASK MANAGER INITIALIZATION
   1847          *
   1848          * Description: This function is called by OSInit() to initialize the task management.
   1849          *
   1850          
   1851          * Argument(s): p_err        is a pointer to a variable that will contain an error code returned by this function.
   1852          *
   1853          *                                OS_ERR_NONE     the call was successful
   1854          *
   1855          * Returns    : none
   1856          *
   1857          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   1858          ************************************************************************************************************************
   1859          */
   1860          

   \                                 In  segment CODE, align 1, keep-with-next
   1861          void  OS_TaskInit (OS_ERR  *p_err)
   \                     OS_TaskInit:
   1862          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000 C5                    PUSH      DE                 ;; 1 cycle
   \   000001                       ; Auto size: 0
   \   000001 16                    MOVW      HL, AX             ;; 1 cycle
   1863          #ifdef OS_SAFETY_CRITICAL
   1864              if (p_err == (OS_ERR *)0) {
   1865                  OS_SAFETY_CRITICAL_EXCEPTION();
   1866                  return;
   1867              }
   1868          #endif
   1869          
   1870          #if OS_CFG_DBG_EN > 0u
   1871              OSTaskDbgListPtr = (OS_TCB      *)0;
   1872          #endif
   1873          
   1874              OSTaskQty        = (OS_OBJ_QTY   )0;                    /* Clear the number of tasks                              */
   \   000002 F6                    CLRW      AX                 ;; 1 cycle
   \   000003 BF....                MOVW      N:OSTaskQty, AX    ;; 1 cycle
   1875              OSTaskCtxSwCtr   = (OS_CTX_SW_CTR)0;                    /* Clear the context switch counter                       */
   \   000006 34....                MOVW      DE, #OSTaskCtxSwCtr  ;; 1 cycle
   \   000009 B9                    MOVW      [DE], AX           ;; 1 cycle
   \   00000A BA02                  MOVW      [DE+0x02], AX      ;; 1 cycle
   1876          
   1877             *p_err            = OS_ERR_NONE;
   \   00000C BB                    MOVW      [HL], AX           ;; 1 cycle
   1878          }
   \   00000D C4                    POP       DE                 ;; 1 cycle
   \   00000E D7                    RET                          ;; 6 cycles
   \   00000F                       ; ------------------------------------- Block: 15 cycles
   \   00000F                       ; ------------------------------------- Total: 15 cycles
   \   00000F                       REQUIRE ?CLRL78_V1_0_L00
   1879          
   1880          /*$PAGE*/
   1881          /*
   1882          ************************************************************************************************************************
   1883          *                                               INITIALIZE TCB FIELDS
   1884          *
   1885          * Description: This function is called to initialize a TCB to default values
   1886          *
   1887          * Arguments  : p_tcb    is a pointer to the TCB to initialize
   1888          *
   1889          * Returns    : none
   1890          *
   1891          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   1892          ************************************************************************************************************************
   1893          */
   1894          

   \                                 In  segment CODE, align 1, keep-with-next
   1895          void  OS_TaskInitTCB (OS_TCB *p_tcb)
   \                     OS_TaskInitTCB:
   1896          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000                       ; Auto size: 0
   \   000000 16                    MOVW      HL, AX             ;; 1 cycle
   1897          #if OS_CFG_TASK_REG_TBL_SIZE > 0u
   1898              OS_REG_ID   id;
   1899          #endif
   1900          #if OS_CFG_TASK_PROFILE_EN > 0u
   1901              CPU_TS      ts;
   1902          #endif
   1903          
   1904          
   1905              p_tcb->StkPtr             = (CPU_STK       *)0;
   \   000001 F6                    CLRW      AX                 ;; 1 cycle
   \   000002 BB                    MOVW      [HL], AX           ;; 1 cycle
   1906              p_tcb->StkLimitPtr        = (CPU_STK       *)0;
   \   000003 BC04                  MOVW      [HL+0x04], AX      ;; 1 cycle
   1907          
   1908              p_tcb->ExtPtr             = (void          *)0;
   \   000005 BC02                  MOVW      [HL+0x02], AX      ;; 1 cycle
   1909          
   1910              p_tcb->NextPtr            = (OS_TCB        *)0;
   \   000007 BC06                  MOVW      [HL+0x06], AX      ;; 1 cycle
   1911              p_tcb->PrevPtr            = (OS_TCB        *)0;
   \   000009 BC08                  MOVW      [HL+0x08], AX      ;; 1 cycle
   1912          
   1913              p_tcb->TickNextPtr        = (OS_TCB        *)0;
   \   00000B BC0A                  MOVW      [HL+0x0A], AX      ;; 1 cycle
   1914              p_tcb->TickPrevPtr        = (OS_TCB        *)0;
   \   00000D BC0C                  MOVW      [HL+0x0C], AX      ;; 1 cycle
   1915              p_tcb->TickSpokePtr       = (OS_TICK_SPOKE *)0;
   \   00000F BC0E                  MOVW      [HL+0x0E], AX      ;; 1 cycle
   1916          
   1917              p_tcb->NamePtr            = (CPU_CHAR      *)((void *)"?Task");
   \   000011 30....                MOVW      AX, #`?<Constant "?Task">`  ;; 1 cycle
   \   000014 BC10                  MOVW      [HL+0x10], AX      ;; 1 cycle
   1918          
   1919              p_tcb->StkBasePtr         = (CPU_STK       *)0;
   \   000016 F6                    CLRW      AX                 ;; 1 cycle
   \   000017 BC12                  MOVW      [HL+0x12], AX      ;; 1 cycle
   1920          
   1921              p_tcb->TaskEntryAddr      = (OS_TASK_PTR    )0;
   \   000019 BC14                  MOVW      [HL+0x14], AX      ;; 1 cycle
   1922              p_tcb->TaskEntryArg       = (void          *)0;
   \   00001B BC16                  MOVW      [HL+0x16], AX      ;; 1 cycle
   1923          
   1924          #if (OS_CFG_PEND_MULTI_EN > 0u)
   1925              p_tcb->PendDataTblPtr     = (OS_PEND_DATA  *)0;
   1926              p_tcb->PendDataTblEntries = (OS_OBJ_QTY     )0u;
   1927          #endif
   1928          
   1929              p_tcb->TS                 = (CPU_TS         )0u;
   \   00001D BC24                  MOVW      [HL+0x24], AX      ;; 1 cycle
   \   00001F BC26                  MOVW      [HL+0x26], AX      ;; 1 cycle
   1930          
   1931          #if (OS_MSG_EN > 0u)
   1932              p_tcb->MsgPtr             = (void          *)0;
   \   000021 BC40                  MOVW      [HL+0x40], AX      ;; 1 cycle
   1933              p_tcb->MsgSize            = (OS_MSG_SIZE    )0u;
   \   000023 BC42                  MOVW      [HL+0x42], AX      ;; 1 cycle
   1934          #endif
   1935          
   1936          #if OS_CFG_TASK_Q_EN > 0u
   1937              OS_MsgQInit(&p_tcb->MsgQ,
   1938                          (OS_MSG_QTY)0u);
   1939          #if OS_CFG_TASK_PROFILE_EN > 0u
   1940              p_tcb->MsgQPendTime       = (CPU_TS         )0u;
   1941              p_tcb->MsgQPendTimeMax    = (CPU_TS         )0u;
   1942          #endif
   1943          #endif
   1944          
   1945          #if OS_CFG_FLAG_EN > 0u
   1946              p_tcb->FlagsPend          = (OS_FLAGS       )0u;
   1947              p_tcb->FlagsOpt           = (OS_OPT         )0u;
   1948              p_tcb->FlagsRdy           = (OS_FLAGS       )0u;
   1949          #endif
   1950          
   1951          #if OS_CFG_TASK_REG_TBL_SIZE > 0u
   1952              for (id = 0u; id < OS_CFG_TASK_REG_TBL_SIZE; id++) {
   1953                  p_tcb->RegTbl[id] = (OS_REG)0u;
   1954              }
   1955          #endif
   1956          
   1957              p_tcb->SemCtr             = (OS_SEM_CTR     )0u;
   \   000025 BC28                  MOVW      [HL+0x28], AX      ;; 1 cycle
   \   000027 BC2A                  MOVW      [HL+0x2A], AX      ;; 1 cycle
   1958          #if OS_CFG_TASK_PROFILE_EN > 0u
   1959              p_tcb->SemPendTime        = (CPU_TS         )0u;
   1960              p_tcb->SemPendTimeMax     = (CPU_TS         )0u;
   1961          #endif
   1962          
   1963              p_tcb->StkSize            = (CPU_STK_SIZE   )0u;
   \   000029 BC1E                  MOVW      [HL+0x1E], AX      ;; 1 cycle
   1964          
   1965          
   1966          #if OS_CFG_TASK_SUSPEND_EN > 0u
   1967              p_tcb->SuspendCtr         = (OS_NESTING_CTR )0u;
   1968          #endif
   1969          
   1970          #if OS_CFG_STAT_TASK_STK_CHK_EN > 0u
   1971              p_tcb->StkFree            = (CPU_STK_SIZE   )0u;
   1972              p_tcb->StkUsed            = (CPU_STK_SIZE   )0u;
   1973          #endif
   1974          
   1975              p_tcb->Opt                = (OS_OPT         )0u;
   \   00002B BC20                  MOVW      [HL+0x20], AX      ;; 1 cycle
   1976          
   1977              p_tcb->TickCtrPrev        = (OS_TICK        )OS_TICK_TH_INIT;
   \   00002D BC2C                  MOVW      [HL+0x2C], AX      ;; 1 cycle
   \   00002F 5180                  MOV       A, #0x80           ;; 1 cycle
   \   000031 BC2E                  MOVW      [HL+0x2E], AX      ;; 1 cycle
   1978              p_tcb->TickCtrMatch       = (OS_TICK        )0u;
   \   000033 F6                    CLRW      AX                 ;; 1 cycle
   \   000034 BC30                  MOVW      [HL+0x30], AX      ;; 1 cycle
   \   000036 BC32                  MOVW      [HL+0x32], AX      ;; 1 cycle
   1979              p_tcb->TickRemain         = (OS_TICK        )0u;
   \   000038 BC34                  MOVW      [HL+0x34], AX      ;; 1 cycle
   \   00003A BC36                  MOVW      [HL+0x36], AX      ;; 1 cycle
   1980          
   1981              p_tcb->TimeQuanta         = (OS_TICK        )0u;
   \   00003C BC38                  MOVW      [HL+0x38], AX      ;; 1 cycle
   \   00003E BC3A                  MOVW      [HL+0x3A], AX      ;; 1 cycle
   1982              p_tcb->TimeQuantaCtr      = (OS_TICK        )0u;
   \   000040 BC3C                  MOVW      [HL+0x3C], AX      ;; 1 cycle
   \   000042 BC3E                  MOVW      [HL+0x3E], AX      ;; 1 cycle
   1983          
   1984          #if OS_CFG_TASK_PROFILE_EN > 0u
   1985              p_tcb->CPUUsage           = (OS_CPU_USAGE   )0u;
   1986              p_tcb->CtxSwCtr           = (OS_CTX_SW_CTR  )0u;
   1987              p_tcb->CyclesDelta        = (CPU_TS         )0u;
   1988              ts                        = OS_TS_GET();                /* Read the current timestamp and save                    */
   1989              p_tcb->CyclesStart        = ts;
   1990              p_tcb->CyclesTotal        = (OS_CYCLES      )0u;
   1991          #endif
   1992          #ifdef CPU_CFG_INT_DIS_MEAS_EN
   1993              p_tcb->IntDisTimeMax      = (CPU_TS         )0u;
   \   000044 BC44                  MOVW      [HL+0x44], AX      ;; 1 cycle
   \   000046 BC46                  MOVW      [HL+0x46], AX      ;; 1 cycle
   1994          #endif
   1995          #if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
   1996              p_tcb->SchedLockTimeMax   = (CPU_TS         )0u;
   1997          #endif
   1998          
   1999              p_tcb->PendOn             = (OS_STATE       )OS_TASK_PEND_ON_NOTHING;
   \   000048 9C1A                  MOV       [HL+0x1A], A       ;; 1 cycle
   2000              p_tcb->PendStatus         = (OS_STATUS      )OS_STATUS_PEND_OK;
   \   00004A 9C1B                  MOV       [HL+0x1B], A       ;; 1 cycle
   2001              p_tcb->TaskState          = (OS_STATE       )OS_TASK_STATE_RDY;
   \   00004C 9C1C                  MOV       [HL+0x1C], A       ;; 1 cycle
   2002          
   2003              p_tcb->Prio               = (OS_PRIO        )OS_PRIO_INIT;
   \   00004E 5108                  MOV       A, #0x8            ;; 1 cycle
   \   000050 9C1D                  MOV       [HL+0x1D], A       ;; 1 cycle
   2004          
   2005          #if OS_CFG_DBG_EN > 0u
   2006              p_tcb->DbgPrevPtr         = (OS_TCB        *)0;
   2007              p_tcb->DbgNextPtr         = (OS_TCB        *)0;
   2008              p_tcb->DbgNamePtr         = (CPU_CHAR      *)((void *)" ");
   2009          #endif
   2010          }
   \   000052 D7                    RET                          ;; 6 cycles
   \   000053                       ; ------------------------------------- Block: 49 cycles
   \   000053                       ; ------------------------------------- Total: 49 cycles
   \   000053                       REQUIRE ?CLRL78_V1_0_L00
   2011          
   2012          /*$PAGE*/
   2013          /*
   2014          ************************************************************************************************************************
   2015          *                                               POST MESSAGE TO A TASK
   2016          *
   2017          * Description: This function sends a message to a task
   2018          *
   2019          * Arguments  : p_tcb      is a pointer to the TCB of the task receiving a message.  If you specify a NULL pointer then
   2020          *                         the message will be posted to the task's queue of the calling task.  In other words, you'd be
   2021          *                         posting a message to yourself.
   2022          *
   2023          *              p_void     is a pointer to the message to send.
   2024          *
   2025          *              msg_size   is the size of the message sent (in #bytes)
   2026          *
   2027          *              opt        specifies whether the post will be FIFO or LIFO:
   2028          *
   2029          *                             OS_OPT_POST_FIFO       Post at the end   of the queue
   2030          *                             OS_OPT_POST_LIFO       Post at the front of the queue
   2031          *
   2032          *                             OS_OPT_POST_NO_SCHED   Do not run the scheduler after the post
   2033          *
   2034          *                          Note(s): 1) OS_OPT_POST_NO_SCHED can be added with one of the other options.
   2035          *
   2036          *
   2037          *              ts         is a timestamp indicating when the post occurred.
   2038          *
   2039          *              p_err      is a pointer to a variable that will hold the error code associated
   2040          *                         with the outcome of this call.  Errors can be:
   2041          *
   2042          *                             OS_ERR_NONE            The call was successful and the message was sent
   2043          *                             OS_ERR_MSG_POOL_EMPTY  If there are no more OS_MSGs available from the pool
   2044          *                             OS_ERR_Q_MAX           If the queue is full
   2045          *                             OS_ERR_STATE_INVALID   If the task is in an invalid state.  This should never happen
   2046          *                                                    and if it does, would be considered a system failure.
   2047          *
   2048          * Returns    : none
   2049          *
   2050          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   2051          ************************************************************************************************************************
   2052          */
   2053          
   2054          #if OS_CFG_TASK_Q_EN > 0u
   2055          void  OS_TaskQPost (OS_TCB      *p_tcb,
   2056                              void        *p_void,
   2057                              OS_MSG_SIZE  msg_size,
   2058                              OS_OPT       opt,
   2059                              CPU_TS       ts,
   2060                              OS_ERR      *p_err)
   2061          {
   2062              CPU_SR_ALLOC();
   2063          
   2064          
   2065          
   2066              OS_CRITICAL_ENTER();
   2067              if (p_tcb == (OS_TCB *)0) {                             /* Post msg to 'self'?                                    */
   2068                  p_tcb = OSTCBCurPtr;
   2069              }
   2070              *p_err  = OS_ERR_NONE;                                  /* Assume we won't have any errors                        */
   2071              switch (p_tcb->TaskState) {
   2072                  case OS_TASK_STATE_RDY:
   2073                  case OS_TASK_STATE_DLY:
   2074                  case OS_TASK_STATE_SUSPENDED:
   2075                  case OS_TASK_STATE_DLY_SUSPENDED:
   2076                       OS_MsgQPut(&p_tcb->MsgQ,                       /* Deposit the message in the queue                       */
   2077                                  p_void,
   2078                                  msg_size,
   2079                                  opt,
   2080                                  ts,
   2081                                  p_err);
   2082                       OS_CRITICAL_EXIT();
   2083                       break;
   2084          
   2085                  case OS_TASK_STATE_PEND:
   2086                  case OS_TASK_STATE_PEND_TIMEOUT:
   2087                  case OS_TASK_STATE_PEND_SUSPENDED:
   2088                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
   2089                       if (p_tcb->PendOn == OS_TASK_PEND_ON_TASK_Q) { /* Is task waiting for a message to be sent to it?        */
   2090                           OS_Post((OS_PEND_OBJ *)0,
   2091                                   p_tcb,
   2092                                   p_void,
   2093                                   msg_size,
   2094                                   ts);
   2095                           OS_CRITICAL_EXIT_NO_SCHED();
   2096                           if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0u) {
   2097                               OSSched();                             /* Run the scheduler                                      */
   2098                           }
   2099                       } else {
   2100                           OS_MsgQPut(&p_tcb->MsgQ,                   /* No,  Task is pending on something else ...             */
   2101                                      p_void,                         /*      ... Deposit the message in the task's queue       */
   2102                                      msg_size,
   2103                                      opt,
   2104                                      ts,
   2105                                      p_err);
   2106                           OS_CRITICAL_EXIT();
   2107                       }
   2108                       break;
   2109          
   2110                  default:
   2111                       OS_CRITICAL_EXIT();
   2112                       *p_err = OS_ERR_STATE_INVALID;
   2113                       break;
   2114              }
   2115          }
   2116          #endif
   2117          
   2118          /*$PAGE*/
   2119          /*
   2120          ************************************************************************************************************************
   2121          *                                              CATCH ACCIDENTAL TASK RETURN
   2122          *
   2123          * Description: This function is called if a task accidentally returns without deleting itself.  In other words, a task
   2124          *              should either be an infinite loop or delete itself if it's done.
   2125          *
   2126          * Arguments  : none
   2127          *
   2128          * Returns    : none
   2129          *
   2130          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   2131          ************************************************************************************************************************
   2132          */
   2133          

   \                                 In  segment CODE, align 1, keep-with-next
   2134          void  OS_TaskReturn (void)
   \                     OS_TaskReturn:
   2135          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000 C3                    PUSH      BC                 ;; 1 cycle
   \   000001 C5                    PUSH      DE                 ;; 1 cycle
   \   000002                       ; Auto size: 2
   \   000002 C1                    PUSH      AX                 ;; 1 cycle
   2136              OS_ERR  err;
   2137          
   2138          
   2139          
   2140              OSTaskReturnHook(OSTCBCurPtr);                          /* Call hook to let user decide on what to do             */
   \   000003 AF....                MOVW      AX, N:OSTCBCurPtr  ;; 1 cycle
   \   000006 FD....                CALL      OSTaskReturnHook   ;; 3 cycles
   \   000009                       ; ------------------------------------- Block: 7 cycles
   2141          #if OS_CFG_TASK_DEL_EN > 0u
   2142              OSTaskDel((OS_TCB *)0,                                  /* Delete task if it accidentally returns!                */
   2143                        (OS_ERR *)&err);
   2144          #else
   2145              for (;;) {
   2146                  OSTimeDly((OS_TICK )OSCfg_TickRate_Hz,
   2147                            (OS_OPT  )OS_OPT_TIME_DLY,
   2148                            (OS_ERR *)&err);
   \                     ??OS_TaskReturn_0:
   \   000009 AEF8                  MOVW      AX, SP             ;; 1 cycle
   \   00000B C1                    PUSH      AX                 ;; 1 cycle
   \   00000C F6                    CLRW      AX                 ;; 1 cycle
   \   00000D 14                    MOVW      DE, AX             ;; 1 cycle
   \   00000E DB....                MOVW      BC, N:OSCfg_TickRate_Hz+2  ;; 1 cycle
   \   000011 AF....                MOVW      AX, N:OSCfg_TickRate_Hz  ;; 1 cycle
   \   000014 FD....                CALL      OSTimeDly          ;; 3 cycles
   \   000017 EFF0                  BR        S:??OS_TaskReturn_0  ;; 3 cycles
   \   000019                       ; ------------------------------------- Block: 12 cycles
   \   000019                       ; ------------------------------------- Total: 19 cycles
   \   000019                       REQUIRE ?CLRL78_V1_0_L00
   2149              }
   2150          #endif
   2151          }
   2152          
   2153          /*$PAGE*/
   2154          /*
   2155          ************************************************************************************************************************
   2156          *                                                    SIGNAL A TASK
   2157          *
   2158          * Description: This function is called to signal a task waiting for a signal.
   2159          *
   2160          * Arguments  : p_tcb     is the pointer to the TCB of the task to signal.  A NULL pointer indicates that you are sending
   2161          *                        a signal to yourself.
   2162          *
   2163          *              opt       determines the type of POST performed:
   2164          *
   2165          *                             OS_OPT_POST_NONE         No option
   2166          *
   2167          *                             OS_OPT_POST_NO_SCHED     Do not call the scheduler
   2168          *
   2169          *              ts        is a timestamp indicating when the post occurred.
   2170          *
   2171          *              p_err     is a pointer to an error code returned by this function:
   2172          *
   2173          *                            OS_ERR_NONE           If the requested task is signaled
   2174          *                            OS_ERR_SEM_OVF        If the post would cause the semaphore count to overflow.
   2175          *                            OS_ERR_STATE_INVALID  If the task is in an invalid state.  This should never happen
   2176          *                                                  and if it does, would be considered a system failure.
   2177          *
   2178          * Returns    : The current value of the task's signal counter or 0 if called from an ISR
   2179          *
   2180          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   2181          ************************************************************************************************************************
   2182          */
   2183          

   \                                 In  segment CODE, align 1, keep-with-next
   2184          OS_SEM_CTR  OS_TaskSemPost (OS_TCB  *p_tcb,
   \                     OS_TaskSemPost:
   2185                                      OS_OPT   opt,
   2186                                      CPU_TS   ts,
   2187                                      OS_ERR  *p_err)
   2188          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 4
   \   000000 C1                    PUSH      AX                 ;; 1 cycle
   \   000001 C3                    PUSH      BC                 ;; 1 cycle
   \   000002                       ; Auto size: 12
   \   000002 2008                  SUBW      SP, #0x8           ;; 1 cycle
   2189              OS_SEM_CTR  ctr;
   2190              CPU_SR_ALLOC();
   2191          
   2192          
   2193          
   2194              OS_CRITICAL_ENTER();
   \   000004 8EFA                  MOV       A, PSW             ;; 1 cycle
   \   000006 70                    MOV       X, A               ;; 1 cycle
   \   000007 F1                    CLRB      A                  ;; 1 cycle
   \   000008 B800                  MOVW      [SP], AX           ;; 1 cycle
   \   00000A F6                    CLRW      AX                 ;; 1 cycle
   \   00000B B802                  MOVW      [SP+0x02], AX      ;; 1 cycle
   \   00000D 717BFA                DI                           ;; 2 cycles
   \   000010 FD....                CALL      CPU_IntDisMeasStart  ;; 3 cycles
   2195              if (p_tcb == (OS_TCB *)0) {                             /* Post signal to 'self'?                                 */
   \   000013 A80A                  MOVW      AX, [SP+0x0A]      ;; 1 cycle
   \   000015 440000                CMPW      AX, #0x0           ;; 1 cycle
   \   000018 DF05                  BNZ       ??OS_TaskSemPost_21  ;; 4 cycles
   \   00001A                       ; ------------------------------------- Block: 20 cycles
   2196                  p_tcb = OSTCBCurPtr;
   \   00001A AF....                MOVW      AX, N:OSTCBCurPtr  ;; 1 cycle
   \   00001D B80A                  MOVW      [SP+0x0A], AX      ;; 1 cycle
   \   00001F                       ; ------------------------------------- Block: 2 cycles
   2197              }
   2198              p_tcb->TS = ts;
   \                     ??OS_TaskSemPost_21:
   \   00001F A812                  MOVW      AX, [SP+0x12]      ;; 1 cycle
   \   000021 12                    MOVW      BC, AX             ;; 1 cycle
   \   000022 A810                  MOVW      AX, [SP+0x10]      ;; 1 cycle
   \   000024 16                    MOVW      HL, AX             ;; 1 cycle
   \   000025 A80A                  MOVW      AX, [SP+0x0A]      ;; 1 cycle
   \   000027 37                    XCHW      AX, HL             ;; 1 cycle
   \   000028 BC24                  MOVW      [HL+0x24], AX      ;; 1 cycle
   \   00002A 13                    MOVW      AX, BC             ;; 1 cycle
   \   00002B BC26                  MOVW      [HL+0x26], AX      ;; 1 cycle
   2199              *p_err    = OS_ERR_NONE;                                /* Assume we won't have any errors                        */
   \   00002D F6                    CLRW      AX                 ;; 1 cycle
   \   00002E B9                    MOVW      [DE], AX           ;; 1 cycle
   2200              switch (p_tcb->TaskState) {
   \   00002F 8C1C                  MOV       A, [HL+0x1C]       ;; 1 cycle
   \   000031 4C02                  CMP       A, #0x2            ;; 1 cycle
   \   000033 DC14                  BC        ??OS_TaskSemPost_22  ;; 4 cycles
   \   000035                       ; ------------------------------------- Block: 17 cycles
   \   000035 2C02                  SUB       A, #0x2            ;; 1 cycle
   \   000037 4C02                  CMP       A, #0x2            ;; 1 cycle
   \   000039 DC2F                  BC        ??OS_TaskSemPost_23  ;; 4 cycles
   \   00003B                       ; ------------------------------------- Block: 6 cycles
   \   00003B 2C02                  SUB       A, #0x2            ;; 1 cycle
   \   00003D 4C02                  CMP       A, #0x2            ;; 1 cycle
   \   00003F DC08                  BC        ??OS_TaskSemPost_22  ;; 4 cycles
   \   000041                       ; ------------------------------------- Block: 6 cycles
   \   000041 2C02                  SUB       A, #0x2            ;; 1 cycle
   \   000043 4C02                  CMP       A, #0x2            ;; 1 cycle
   \   000045 DC23                  BC        ??OS_TaskSemPost_23  ;; 4 cycles
   \   000047                       ; ------------------------------------- Block: 6 cycles
   \   000047 EF75                  BR        S:??OS_TaskSemPost_24  ;; 3 cycles
   \   000049                       ; ------------------------------------- Block: 3 cycles
   2201                  case OS_TASK_STATE_RDY:
   2202                  case OS_TASK_STATE_DLY:
   2203                  case OS_TASK_STATE_SUSPENDED:
   2204                  case OS_TASK_STATE_DLY_SUSPENDED:
   2205                       switch (sizeof(OS_SEM_CTR)) {
   2206                           case 1u:
   2207                                if (p_tcb->SemCtr == DEF_INT_08U_MAX_VAL) {
   2208                                    OS_CRITICAL_EXIT();
   2209                                    *p_err = OS_ERR_SEM_OVF;
   2210                                    return ((OS_SEM_CTR)0);
   2211                                }
   2212                                break;
   2213          
   2214                           case 2u:
   2215                                if (p_tcb->SemCtr == DEF_INT_16U_MAX_VAL) {
   2216                                    OS_CRITICAL_EXIT();
   2217                                    *p_err = OS_ERR_SEM_OVF;
   2218                                    return ((OS_SEM_CTR)0);
   2219                                }
   2220                                break;
   2221          
   2222                           case 4u:
   2223                                if (p_tcb->SemCtr == DEF_INT_32U_MAX_VAL) {
   \                     ??OS_TaskSemPost_22:
   \   000049 AC2A                  MOVW      AX, [HL+0x2A]      ;; 1 cycle
   \   00004B 12                    MOVW      BC, AX             ;; 1 cycle
   \   00004C AC28                  MOVW      AX, [HL+0x28]      ;; 1 cycle
   \   00004E 33                    XCHW      AX, BC             ;; 1 cycle
   \   00004F 44FFFF                CMPW      AX, #0xFFFF        ;; 1 cycle
   \   000052 13                    MOVW      AX, BC             ;; 1 cycle
   \   000053 61F8                  SKNZ                         ;; 4 cycles
   \   000055                       ; ------------------------------------- Block: 10 cycles
   \   000055 44FFFF                CMPW      AX, #0xFFFF        ;; 1 cycle
   \   000058                       ; ------------------------------------- Block: 1 cycles
   \                     ??OS_TaskSemPost_25:
   \   000058 DF46                  BNZ       ??OS_TaskSemPost_26  ;; 4 cycles
   \   00005A                       ; ------------------------------------- Block: 4 cycles
   2224                                    OS_CRITICAL_EXIT();
   \   00005A FD....                CALL      CPU_IntDisMeasStop  ;; 3 cycles
   \   00005D 8800                  MOV       A, [SP]            ;; 1 cycle
   \   00005F FD....                CALL      N:?Subroutine1     ;; 3 cycles
   \   000062                       ; ------------------------------------- Block: 7 cycles
   2225                                    *p_err = OS_ERR_SEM_OVF;
   \                     ??CrossCallReturnLabel_8:
   \   000062 30C56D                MOVW      AX, #0x6DC5        ;; 1 cycle
   \   000065 B9                    MOVW      [DE], AX           ;; 1 cycle
   2226                                    return ((OS_SEM_CTR)0);
   \   000066 F6                    CLRW      AX                 ;; 1 cycle
   \   000067 F7                    CLRW      BC                 ;; 1 cycle
   \   000068 EF6A                  BR        S:??OS_TaskSemPost_27  ;; 3 cycles
   \   00006A                       ; ------------------------------------- Block: 7 cycles
   2227                                }
   2228                                break;
   2229          
   2230                           default:
   2231                                break;
   2232                       }
   2233                       p_tcb->SemCtr++;                               /* Task signaled is not pending on anything               */
   2234                       ctr = p_tcb->SemCtr;
   2235                       OS_CRITICAL_EXIT();
   2236                       break;
   2237          
   2238                  case OS_TASK_STATE_PEND:
   2239                  case OS_TASK_STATE_PEND_TIMEOUT:
   2240                  case OS_TASK_STATE_PEND_SUSPENDED:
   2241                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
   2242                       if (p_tcb->PendOn == OS_TASK_PEND_ON_TASK_SEM) {   /* Is task signaled waiting for a signal?             */
   \                     ??OS_TaskSemPost_23:
   \   00006A 8C1A                  MOV       A, [HL+0x1A]       ;; 1 cycle
   \   00006C 4C07                  CMP       A, #0x7            ;; 1 cycle
   \   00006E DF30                  BNZ       ??OS_TaskSemPost_26  ;; 4 cycles
   \   000070                       ; ------------------------------------- Block: 6 cycles
   2243                           OS_Post((OS_PEND_OBJ *)0,                      /*      Task is pending on signal                     */
   2244                                   (OS_TCB      *)p_tcb,
   2245                                   (void        *)0,
   2246                                   (OS_MSG_SIZE  )0u,
   2247                                   (CPU_TS       )ts);
   \   000070 A810                  MOVW      AX, [SP+0x10]      ;; 1 cycle
   \   000072 C3                    PUSH      BC                 ;; 1 cycle
   \   000073 C1                    PUSH      AX                 ;; 1 cycle
   \   000074 F6                    CLRW      AX                 ;; 1 cycle
   \   000075 C1                    PUSH      AX                 ;; 1 cycle
   \   000076 14                    MOVW      DE, AX             ;; 1 cycle
   \   000077 C7                    PUSH      HL                 ;; 1 cycle
   \   000078 C2                    POP       BC                 ;; 1 cycle
   \   000079 FD....                CALL      OS_Post            ;; 3 cycles
   2248                           ctr = p_tcb->SemCtr;
   \   00007C A80A                  MOVW      AX, [SP+0x0A]      ;; 1 cycle
   \   00007E 16                    MOVW      HL, AX             ;; 1 cycle
   \   00007F AC2A                  MOVW      AX, [HL+0x2A]      ;; 1 cycle
   \   000081 12                    MOVW      BC, AX             ;; 1 cycle
   \   000082 AC28                  MOVW      AX, [HL+0x28]      ;; 1 cycle
   \   000084 B804                  MOVW      [SP+0x04], AX      ;; 1 cycle
   \   000086 13                    MOVW      AX, BC             ;; 1 cycle
   \   000087 B806                  MOVW      [SP+0x06], AX      ;; 1 cycle
   2249                           OS_CRITICAL_EXIT_NO_SCHED();
   \   000089 FD....                CALL      CPU_IntDisMeasStop  ;; 3 cycles
   \   00008C 8800                  MOV       A, [SP]            ;; 1 cycle
   \   00008E FD....                CALL      N:?Subroutine1     ;; 3 cycles
   \   000091                       ; ------------------------------------- Block: 26 cycles
   2250                           if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
   \                     ??CrossCallReturnLabel_9:
   \   000091 AEF8                  MOVW      AX, SP             ;; 1 cycle
   \   000093 040800                ADDW      AX, #0x8           ;; 1 cycle
   \   000096 16                    MOVW      HL, AX             ;; 1 cycle
   \   000097 A7                    INCW      HL                 ;; 1 cycle
   \   000098 31F334                BT        [HL].7, ??OS_TaskSemPost_28  ;; 5 cycles
   \   00009B                       ; ------------------------------------- Block: 9 cycles
   2251                               OSSched();                                 /* Run the scheduler                                  */
   \   00009B FD....                CALL      OSSched            ;; 3 cycles
   \   00009E EF2F                  BR        S:??OS_TaskSemPost_28  ;; 3 cycles
   \   0000A0                       ; ------------------------------------- Block: 6 cycles
   2252                           }
   2253                       } else {
   2254                           p_tcb->SemCtr++;                           /* No,  Task signaled is NOT pending on semaphore ...     */
   \                     ??OS_TaskSemPost_26:
   \   0000A0 17                    MOVW      AX, HL             ;; 1 cycle
   \   0000A1 FD....                CALL      N:?Subroutine3     ;; 3 cycles
   \   0000A4                       ; ------------------------------------- Block: 4 cycles
   \                     ??CrossCallReturnLabel_16:
   \   0000A4 040100                ADDW      AX, #0x1           ;; 1 cycle
   \   0000A7 61D8                  SKNC
   \   0000A9 A3                    INCW      BC                 ;; 5 cycles
   \   0000AA BB                    MOVW      [HL], AX           ;; 1 cycle
   \   0000AB 13                    MOVW      AX, BC             ;; 1 cycle
   \   0000AC BC02                  MOVW      [HL+0x02], AX      ;; 1 cycle
   2255                           ctr = p_tcb->SemCtr;                       /*      ... it must be waiting on something else          */
   \   0000AE AB                    MOVW      AX, [HL]           ;; 1 cycle
   \   0000AF B804                  MOVW      [SP+0x04], AX      ;; 1 cycle
   \   0000B1 13                    MOVW      AX, BC             ;; 1 cycle
   \   0000B2 B806                  MOVW      [SP+0x06], AX      ;; 1 cycle
   2256                           OS_CRITICAL_EXIT();
   \   0000B4 FD....                CALL      CPU_IntDisMeasStop  ;; 3 cycles
   \   0000B7 8800                  MOV       A, [SP]            ;; 1 cycle
   \   0000B9 FD....                CALL      N:?Subroutine1     ;; 3 cycles
   \   0000BC                       ; ------------------------------------- Block: 20 cycles
   \                     ??CrossCallReturnLabel_10:
   \   0000BC EF11                  BR        S:??OS_TaskSemPost_28  ;; 3 cycles
   \   0000BE                       ; ------------------------------------- Block: 3 cycles
   2257                       }
   2258                       break;
   2259          
   2260                  default:
   2261                       OS_CRITICAL_EXIT();
   \                     ??OS_TaskSemPost_24:
   \   0000BE FD....                CALL      CPU_IntDisMeasStop  ;; 3 cycles
   \   0000C1 8800                  MOV       A, [SP]            ;; 1 cycle
   \   0000C3 FD....                CALL      N:?Subroutine1     ;; 3 cycles
   \   0000C6                       ; ------------------------------------- Block: 7 cycles
   2262                       *p_err = OS_ERR_STATE_INVALID;
   \                     ??CrossCallReturnLabel_11:
   \   0000C6 302A6E                MOVW      AX, #0x6E2A        ;; 1 cycle
   \   0000C9 B9                    MOVW      [DE], AX           ;; 1 cycle
   2263                       ctr = (OS_SEM_CTR)0;
   \   0000CA F6                    CLRW      AX                 ;; 1 cycle
   \   0000CB B804                  MOVW      [SP+0x04], AX      ;; 1 cycle
   \   0000CD B806                  MOVW      [SP+0x06], AX      ;; 1 cycle
   2264                       break;
   \   0000CF                       ; ------------------------------------- Block: 5 cycles
   2265              }
   2266              return (ctr);
   \                     ??OS_TaskSemPost_28:
   \   0000CF A806                  MOVW      AX, [SP+0x06]      ;; 1 cycle
   \   0000D1 12                    MOVW      BC, AX             ;; 1 cycle
   \   0000D2 A804                  MOVW      AX, [SP+0x04]      ;; 1 cycle
   \   0000D4                       ; ------------------------------------- Block: 3 cycles
   \                     ??OS_TaskSemPost_27:
   \   0000D4 100C                  ADDW      SP, #0xC           ;; 1 cycle
   \   0000D6 ED....                BR        N:?Subroutine0     ;; 3 cycles
   \   0000D9                       ; ------------------------------------- Block: 4 cycles
   \   0000D9                       ; ------------------------------------- Total: 182 cycles
   \   0000D9                       REQUIRE ?CLRL78_V1_0_L00
   2267          }

   \                                 In  segment NEAR_CONST, align 2
   \                     `?<Constant "?Task">`:
   \   000000 3F5461736B00          DB "?Task"

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
     38   OSTaskCreate
       10   -> CPU_IntDisMeasStart
       10   -> CPU_IntDisMeasStop
       10   -> OSSched
       10   -> OSTaskCreateHook
       16   -> OSTaskStkInit
       10   -> OS_PrioInsert
       10   -> OS_RdyListInsertTail
       10   -> OS_TaskInitTCB
     22   OSTaskSemPend
       14   -> CPU_IntDisMeasStart
       14   -> CPU_IntDisMeasStop
       14   -> OSSched
       18   -> OS_Pend
      4   OSTaskSemPost
        4   -> OS_TaskSemPost
     16   OSTaskSemSet
       12   -> CPU_IntDisMeasStart
       12   -> CPU_IntDisMeasStop
      2   OS_TaskInit
      0   OS_TaskInitTCB
      8   OS_TaskReturn
        6   -> OSTaskReturnHook
        8   -> OSTimeDly
     22   OS_TaskSemPost
       12   -> CPU_IntDisMeasStart
       12   -> CPU_IntDisMeasStop
       12   -> OSSched
       18   -> OS_Post


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       6  ?<Constant "?Task">
       5  ?Subroutine0
       6  ?Subroutine1
       7  ?Subroutine2
       9  ?Subroutine3
     213  OSTaskCreate
     313  OSTaskSemPend
       9  OSTaskSemPost
      73  OSTaskSemSet
      15  OS_TaskInit
      83  OS_TaskInitTCB
      25  OS_TaskReturn
     217  OS_TaskSemPost

 
 975 bytes in segment CODE
   6 bytes in segment NEAR_CONST
 
 975 bytes of CODE  memory
   6 bytes of CONST memory

Errors: none
Warnings: none

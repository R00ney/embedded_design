###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.30.5.50715 for RL78             20/Feb/2014  23:13:14 #
# Copyright 2011-2013 IAR Systems AB.                                         #
# Network license: ece-lic-19.ece.ncsu.edu (STD)                              #
#                                                                             #
#    Core         =  rl78_2                                                   #
#    Code model   =  Near                                                     #
#    Data model   =  Near                                                     #
#                 =                                                           #
#    Source file  =  C:\Users\Suddenlink\Dropbox\git_files\embedded_design\pr #
#                    oject1\modified_RTCSched-G14\applilet3_src\r_cg_serial_u #
#                    ser.c                                                    #
#    Command line =  C:\Users\Suddenlink\Dropbox\git_files\embedded_design\pr #
#                    oject1\modified_RTCSched-G14\applilet3_src\r_cg_serial_u #
#                    ser.c --core rl78_2 --code_model near --data_model near  #
#                    --near_const_location rom0 -o                            #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\pr #
#                    oject1\modified_RTCSched-G14\Debug\Obj\ --dlib_config    #
#                    "C:\Program Files\IAR Systems\Embedded Workbench         #
#                    6.5\rl78\LIB\dlrl78nn2n.h" -e -Ohz --no_scheduling       #
#                    --debug -lCN C:\Users\Suddenlink\Dropbox\git_files\embed #
#                    ded_design\project1\modified_RTCSched-G14\Debug\List\    #
#                    -I C:\Users\Suddenlink\Dropbox\git_files\embedded_design #
#                    \project1\modified_RTCSched-G14/applilet3_src/\ -I       #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\pr #
#                    oject1\modified_RTCSched-G14/Glyph/\ -I                  #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\pr #
#                    oject1\modified_RTCSched-G14/Glyph/Drivers/\ -I          #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\pr #
#                    oject1\modified_RTCSched-G14/user_include/\ -I           #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\pr #
#                    oject1\modified_RTCSched-G14/RTC/\ -I                    #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\pr #
#                    oject1\modified_RTCSched-G14/Queu/\                      #
#    List file    =  C:\Users\Suddenlink\Dropbox\git_files\embedded_design\pr #
#                    oject1\modified_RTCSched-G14\Debug\List\r_cg_serial_user #
#                    .lst                                                     #
#    Object file  =  C:\Users\Suddenlink\Dropbox\git_files\embedded_design\pr #
#                    oject1\modified_RTCSched-G14\Debug\Obj\r_cg_serial_user. #
#                    r87                                                      #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\Suddenlink\Dropbox\git_files\embedded_design\project1\modified_RTCSched-G14\applilet3_src\r_cg_serial_user.c
      1          /***********************************************************************************************************************
      2          * DISCLAIMER
      3          * This software is supplied by Renesas Electronics Corporation and is only 
      4          * intended for use with Renesas products. No other uses are authorized. This 
      5          * software is owned by Renesas Electronics Corporation and is protected under 
      6          * all applicable laws, including copyright laws.
      7          * THIS SOFTWARE IS PROVIDED "AS IS" AND RENESAS MAKES NO WARRANTIES REGARDING 
      8          * THIS SOFTWARE, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT 
      9          * LIMITED TO WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE 
     10          * AND NON-INFRINGEMENT.  ALL SUCH WARRANTIES ARE EXPRESSLY DISCLAIMED.
     11          * TO THE MAXIMUM EXTENT PERMITTED NOT PROHIBITED BY LAW, NEITHER RENESAS 
     12          * ELECTRONICS CORPORATION NOR ANY OF ITS AFFILIATED COMPANIES SHALL BE LIABLE 
     13          * FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES FOR 
     14          * ANY REASON RELATED TO THIS SOFTWARE, EVEN IF RENESAS OR ITS AFFILIATES HAVE 
     15          * BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
     16          * Renesas reserves the right, without notice, to make changes to this software 
     17          * and to discontinue the availability of this software.  By using this software, 
     18          * you agree to the additional terms and conditions found by accessing the 
     19          * following link:
     20          * http://www.renesas.com/disclaimer
     21          *
     22          * Copyright (C) 2011, 2013 Renesas Electronics Corporation. All rights reserved.
     23          ***********************************************************************************************************************/
     24          
     25          /***********************************************************************************************************************
     26          * File Name    : r_cg_serial_user.c
     27          * Version      : Applilet3 for RL78/G14 V2.01.00.02 [09 Aug 2013]
     28          * Device(s)    : R5F104PJ
     29          * Tool-Chain   : IAR Systems iccrl78
     30          * Description  : This file implements device driver for Serial module.
     31          * Creation Date: 2/19/2014
     32          ***********************************************************************************************************************/
     33          
     34          /***********************************************************************************************************************
     35          Includes
     36          ***********************************************************************************************************************/
     37          #include "r_cg_macrodriver.h"

   \                                 In  segment NEAR_A, at 0xfff4a
   \   union <unnamed> volatile __sfr __no_bit_access _A_SDR11
   \                     _A_SDR11:
   \   000000                       DS 2

   \                                 In  segment NEAR_A, at 0xf0142
   \   union <unnamed> const volatile __no_bit_access _A_SSR11
   \                     _A_SSR11:
   \   000000                       DS 2

   \                                 In  segment NEAR_A, at 0xf014a
   \   union <unnamed> volatile __no_bit_access _A_SIR11
   \                     _A_SIR11:
   \   000000                       DS 2
     38          #include "r_cg_serial.h"
     39          /* Start user code for include. Do not edit comment generated here */
     40          /* End user code. Do not edit comment generated here */
     41          #include "r_cg_userdefine.h"
     42          
     43          /***********************************************************************************************************************
     44          Global variables and functions
     45          ***********************************************************************************************************************/
     46          extern uint8_t * gp_uart1_tx_address;         /* uart1 send buffer address */
     47          extern uint16_t  g_uart1_tx_count;            /* uart1 send data number */
     48          extern uint8_t * gp_uart1_rx_address;         /* uart1 receive buffer address */
     49          extern uint16_t  g_uart1_rx_count;            /* uart1 receive data number */
     50          extern uint16_t  g_uart1_rx_length;           /* uart1 receive data length */
     51          extern uint8_t * gp_csi21_rx_address;         /* csi21 receive buffer address */
     52          extern uint16_t  g_csi21_rx_length;           /* csi21 receive data length */
     53          extern uint16_t  g_csi21_rx_count;            /* csi21 receive data count */
     54          extern uint8_t * gp_csi21_tx_address;         /* csi21 send buffer address */
     55          extern uint16_t  g_csi21_send_length;         /* csi21 send data length */
     56          extern uint16_t  g_csi21_tx_count;            /* csi21 send data count */
     57          /* Start user code for global. Do not edit comment generated here */

   \                                 In  segment NEAR_Z, align 1, align-sorted
     58          volatile uint8_t G_UART_SendingData = 0;
   \                     G_UART_SendingData:
   \   000000                       DS 1
   \   000001                       REQUIRE __INIT_NEAR_Z

   \                                 In  segment NEAR_Z, align 1, align-sorted
     59          volatile uint8_t G_UART_ReceivingData = 0;
   \                     G_UART_ReceivingData:
   \   000000                       DS 1
   \   000001                       REQUIRE __INIT_NEAR_Z

   \                                 In  segment NEAR_Z, align 1, align-sorted
     60          volatile uint8_t G_SPI_SendingData = 0;
   \                     G_SPI_SendingData:
   \   000000                       DS 1
   \   000001                       REQUIRE __INIT_NEAR_Z

   \                                 In  segment NEAR_Z, align 1, align-sorted
     61          volatile uint8_t G_SPI_ReceivingData = 0;
   \                     G_SPI_ReceivingData:
   \   000000                       DS 1
   \   000001                       REQUIRE __INIT_NEAR_Z

   \                                 In  segment NEAR_Z, align 1, align-sorted
     62          volatile uint8_t G_IIC_SendingData = 0;
   \                     G_IIC_SendingData:
   \   000000                       DS 1
   \   000001                       REQUIRE __INIT_NEAR_Z

   \                                 In  segment NEAR_Z, align 1, align-sorted
     63          volatile uint8_t G_IIC_ReceivingData = 0;
   \                     G_IIC_ReceivingData:
   \   000000                       DS 1
   \   000001                       REQUIRE __INIT_NEAR_Z
     64          /* End user code. Do not edit comment generated here */
     65          
     66          /***********************************************************************************************************************
     67          * Function Name: r_uart1_interrupt_receive
     68          * Description  : This function is INTSR1 interrupt service routine.
     69          * Arguments    : None
     70          * Return Value : None
     71          ***********************************************************************************************************************/
     72          /*
     73          #pragma vector = INTSR1_vect
     74          __interrupt static void r_uart1_interrupt_receive(void)
     75          {
     76              uint8_t rx_data;
     77              uint8_t err_type;
     78              
     79              err_type = (uint8_t)(SSR03 & 0x0007U);
     80              SIR03 = (uint16_t)err_type;
     81          
     82              if (err_type != 0U)
     83              {
     84                  r_uart1_callback_error(err_type);
     85              }
     86              
     87              rx_data = RXD1;
     88          
     89              if (g_uart1_rx_length > g_uart1_rx_count)
     90              {
     91                  *gp_uart1_rx_address = rx_data;
     92                  gp_uart1_rx_address++;
     93                  g_uart1_rx_count++;
     94          
     95                  if (g_uart1_rx_length == g_uart1_rx_count)
     96                  {
     97                      r_uart1_callback_receiveend();
     98                  }
     99              }
    100              else
    101              {
    102                  r_uart1_callback_softwareoverrun(rx_data);
    103              }
    104          }*/
    105          
    106          /***********************************************************************************************************************
    107          * Function Name: r_uart1_callback_receiveend
    108          * Description  : This function is a callback function when UART1 finishes reception.
    109          * Arguments    : None
    110          * Return Value : None
    111          ***********************************************************************************************************************/
    112          //static void r_uart1_callback_receiveend(void)
    113          //{
    114              /* Start user code. Do not edit comment generated here */
    115              /* End user code. Do not edit comment generated here */
    116          //}
    117          
    118          /***********************************************************************************************************************
    119          * Function Name: r_uart1_callback_softwareoverrun
    120          * Description  : This function is a callback function when UART1 receives an overflow data.
    121          * Arguments    : rx_data -
    122          *                    receive data
    123          * Return Value : None
    124          ***********************************************************************************************************************/
    125          //static void r_uart1_callback_softwareoverrun(uint16_t rx_data)
    126          //{
    127              /* Start user code. Do not edit comment generated here */
    128              /* End user code. Do not edit comment generated here */
    129          //}
    130          
    131          /***********************************************************************************************************************
    132          * Function Name: r_uart1_callback_error
    133          * Description  : This function is a callback function when UART1 reception error occurs.
    134          * Arguments    : err_type -
    135          *                    error type value
    136          * Return Value : None
    137          ***********************************************************************************************************************/
    138          //static void r_uart1_callback_error(uint8_t err_type)
    139          //{
    140              /* Start user code. Do not edit comment generated here */
    141              /* End user code. Do not edit comment generated here */
    142          //}
    143          
    144          /***********************************************************************************************************************
    145          * Function Name: r_csi21_interrupt
    146          * Description  : This function is INTCSI21 interrupt service routine.
    147          * Arguments    : None
    148          * Return Value : None
    149          ***********************************************************************************************************************/
    150          #pragma vector = INTCSI21_vect

   \                                 In  segment CODE, align 1, keep-with-next
    151          __interrupt static void r_csi21_interrupt(void)
   \                     r_csi21_interrupt:
    152          {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000 C1                    PUSH      AX                 ;; 1 cycle
   \   000001 C7                    PUSH      HL                 ;; 1 cycle
   \   000002                       ; Auto size: 2
   \   000002 C1                    PUSH      AX                 ;; 1 cycle
    153              uint8_t err_type;
    154              uint8_t sio_dummy;
    155          
    156              err_type = (uint8_t)(SSR11 & _0001_SAU_OVERRUN_ERROR);
   \   000003 AF4201                MOVW      AX, 0x142          ;; 1 cycle
   \   000006 60                    MOV       A, X               ;; 1 cycle
   \   000007 5C01                  AND       A, #0x1            ;; 1 cycle
   \   000009 9800                  MOV       [SP], A            ;; 1 cycle
    157              SIR11 = (uint16_t)err_type;
   \   00000B 70                    MOV       X, A               ;; 1 cycle
   \   00000C F1                    CLRB      A                  ;; 1 cycle
   \   00000D BF4A01                MOVW      0x14A, AX          ;; 1 cycle
    158          
    159              if (1U == err_type)
   \   000010 AEF8                  MOVW      AX, SP             ;; 1 cycle
   \   000012 16                    MOVW      HL, AX             ;; 1 cycle
   \   000013 318344                BT        [HL].0, ??r_csi21_interrupt_0  ;; 5 cycles
   \   000016                       ; ------------------------------------- Block: 17 cycles
    160              {
    161                  r_csi21_callback_error(err_type);    /* overrun error occurs */
    162              }
    163              else
    164              {
    165                  if (g_csi21_tx_count > 0U)
   \   000016 F6                    CLRW      AX                 ;; 1 cycle
   \   000017 42....                CMPW      AX, N:g_csi21_tx_count  ;; 1 cycle
   \   00001A DD2D                  BZ        ??r_csi21_interrupt_1  ;; 4 cycles
   \   00001C                       ; ------------------------------------- Block: 6 cycles
    166                  {
    167                      if (0U != gp_csi21_rx_address)
   \   00001C 42....                CMPW      AX, N:gp_csi21_rx_address  ;; 1 cycle
   \   00001F 8E4A                  MOV       A, 0xFFF4A         ;; 1 cycle
   \   000021 DD0B                  BZ        ??r_csi21_interrupt_2  ;; 4 cycles
   \   000023                       ; ------------------------------------- Block: 6 cycles
    168                      {
    169                          *gp_csi21_rx_address = SIO21;
   \   000023 FB....                MOVW      HL, N:gp_csi21_rx_address  ;; 1 cycle
   \   000026 9B                    MOV       [HL], A            ;; 1 cycle
    170                          gp_csi21_rx_address++;
   \   000027 AF....                MOVW      AX, N:gp_csi21_rx_address  ;; 1 cycle
   \   00002A A1                    INCW      AX                 ;; 1 cycle
   \   00002B BF....                MOVW      N:gp_csi21_rx_address, AX  ;; 1 cycle
   \   00002E                       ; ------------------------------------- Block: 5 cycles
    171                      }
    172                      else
    173                      {
    174                          sio_dummy = SIO21;
    175                      }
    176          
    177                      if (0U != gp_csi21_tx_address)
   \                     ??r_csi21_interrupt_2:
   \   00002E F6                    CLRW      AX                 ;; 1 cycle
   \   00002F 42....                CMPW      AX, N:gp_csi21_tx_address  ;; 1 cycle
   \   000032 DD0D                  BZ        ??r_csi21_interrupt_3  ;; 4 cycles
   \   000034                       ; ------------------------------------- Block: 6 cycles
    178                      {
    179                          SIO21 = *gp_csi21_tx_address;
   \   000034 FB....                MOVW      HL, N:gp_csi21_tx_address  ;; 1 cycle
   \   000037 8B                    MOV       A, [HL]            ;; 1 cycle
   \   000038 9E4A                  MOV       0xFFF4A, A         ;; 1 cycle
    180                          gp_csi21_tx_address++;
   \   00003A 17                    MOVW      AX, HL             ;; 1 cycle
   \   00003B A1                    INCW      AX                 ;; 1 cycle
   \   00003C BF....                MOVW      N:gp_csi21_tx_address, AX  ;; 1 cycle
   \   00003F EF03                  BR        S:??r_csi21_interrupt_4  ;; 3 cycles
   \   000041                       ; ------------------------------------- Block: 9 cycles
    181                      }
    182                      else
    183                      {
    184                          SIO21 = 0xFFU;
   \                     ??r_csi21_interrupt_3:
   \   000041 CE4AFF                MOV       0xFFF4A, #0xFF     ;; 1 cycle
   \   000044                       ; ------------------------------------- Block: 1 cycles
    185                      }
    186          
    187                      g_csi21_tx_count--;
   \                     ??r_csi21_interrupt_4:
   \   000044 B2....                DECW      N:g_csi21_tx_count  ;; 2 cycles
   \   000047 EF11                  BR        S:??r_csi21_interrupt_0  ;; 3 cycles
   \   000049                       ; ------------------------------------- Block: 5 cycles
    188                  }
    189                  else 
    190                  {
    191                      if (0U == g_csi21_tx_count)
    192                      {
    193                          if (0U != gp_csi21_rx_address)
   \                     ??r_csi21_interrupt_1:
   \   000049 42....                CMPW      AX, N:gp_csi21_rx_address  ;; 1 cycle
   \   00004C 8E4A                  MOV       A, 0xFFF4A         ;; 1 cycle
   \   00004E DD04                  BZ        ??r_csi21_interrupt_5  ;; 4 cycles
   \   000050                       ; ------------------------------------- Block: 6 cycles
    194                          {
    195                              *gp_csi21_rx_address = SIO21;
   \   000050 FB....                MOVW      HL, N:gp_csi21_rx_address  ;; 1 cycle
   \   000053 9B                    MOV       [HL], A            ;; 1 cycle
   \   000054                       ; ------------------------------------- Block: 2 cycles
    196                          }
    197                          else
    198                          {
    199                              sio_dummy = SIO21;
    200                          }
    201                      }
    202          
    203                      r_csi21_callback_sendend();    /* complete send */
   \                     ??r_csi21_interrupt_5:
   \   000054 F5....                CLRB      N:G_SPI_SendingData  ;; 1 cycle
    204                      r_csi21_callback_receiveend();    /* complete receive */
   \   000057 F5....                CLRB      N:G_SPI_ReceivingData  ;; 1 cycle
    205                  }
    206              }
   \   00005A                       ; ------------------------------------- Block: 2 cycles
    207          }
   \                     ??r_csi21_interrupt_0:
   \   00005A 1002                  ADDW      SP, #0x2           ;; 1 cycle
   \   00005C C6                    POP       HL                 ;; 1 cycle
   \   00005D C0                    POP       AX                 ;; 1 cycle
   \   00005E 61FC                  RETI                         ;; 6 cycles
   \   000060                       ; ------------------------------------- Block: 9 cycles
   \   000060                       ; ------------------------------------- Total: 74 cycles
   \   000060                       REQUIRE ?CLRL78_V1_0_L00
   \   000060                       REQUIRE _A_SSR11
   \   000060                       REQUIRE _A_SIR11
   \   000060                       REQUIRE _A_SDR11

   \                                 In  segment INTVEC, offset 0x16, root
   \   000016 ....                  DW r_csi21_interrupt
    208          
    209          /***********************************************************************************************************************
    210          * Function Name: r_csi21_callback_receiveend
    211          * Description  : This function is a callback function when CSI21 finishes reception.
    212          * Arguments    : None
    213          * Return Value : None
    214          ***********************************************************************************************************************/
    215          static void r_csi21_callback_receiveend(void)
    216          {
    217              /* Start user code. Do not edit comment generated here */
    218          	   G_SPI_ReceivingData = 0;
    219              /* End user code. Do not edit comment generated here */
    220          }
    221          
    222          /***********************************************************************************************************************
    223          * Function Name: r_csi21_callback_error
    224          * Description  : This function is a callback function when CSI21 reception error occurs.
    225          * Arguments    : err_type -
    226          *                    error type value
    227          * Return Value : None
    228          ***********************************************************************************************************************/
    229          static void r_csi21_callback_error(uint8_t err_type)
    230          {
    231              /* Start user code. Do not edit comment generated here */
    232              /* End user code. Do not edit comment generated here */
    233          }
    234          
    235          /***********************************************************************************************************************
    236          * Function Name: r_csi21_callback_sendend
    237          * Description  : This function is a callback function when CSI21 finishes transmission.
    238          * Arguments    : None
    239          * Return Value : None
    240          ***********************************************************************************************************************/
    241          static void r_csi21_callback_sendend(void)
    242          {
    243              /* Start user code. Do not edit comment generated here */
    244          	  G_SPI_SendingData = 0;
    245          		/* End user code. Do not edit comment generated here */
    246          }
    247          
    248          /* Start user code for adding. Do not edit comment generated here */
    249          /* End user code. Do not edit comment generated here */

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      6   r_csi21_interrupt


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       2  ??r_csi21_interrupt??INTVEC 22
       1  G_IIC_ReceivingData
       1  G_IIC_SendingData
       1  G_SPI_ReceivingData
       1  G_SPI_SendingData
       1  G_UART_ReceivingData
       1  G_UART_SendingData
       2  _A_SDR11
       2  _A_SIR11
       2  _A_SSR11
      96  r_csi21_interrupt

 
 96 bytes in segment CODE
  2 bytes in segment INTVEC
  6 bytes in segment NEAR_A
  6 bytes in segment NEAR_Z
 
 96 bytes of CODE memory (+ 2 bytes shared)
  6 bytes of DATA memory (+ 6 bytes shared)

Errors: none
Warnings: 1

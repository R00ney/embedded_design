###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.30.5.50715 for RL78             22/Feb/2014  21:58:26 #
# Copyright 2011-2013 IAR Systems AB.                                         #
# Network license: ece-lic-19.ece.ncsu.edu (STD)                              #
#                                                                             #
#    Core         =  rl78_2                                                   #
#    Code model   =  Near                                                     #
#    Data model   =  Near                                                     #
#                 =                                                           #
#    Source file  =  C:\Users\Suddenlink\Dropbox\git_files\embedded_design\pr #
#                    oject1\modified_RTCSched-G14\Queu\queu.c                 #
#    Command line =  C:\Users\Suddenlink\Dropbox\git_files\embedded_design\pr #
#                    oject1\modified_RTCSched-G14\Queu\queu.c --core rl78_2   #
#                    --code_model near --data_model near                      #
#                    --near_const_location rom0 -o                            #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\pr #
#                    oject1\modified_RTCSched-G14\Debug\Obj\ --dlib_config    #
#                    "C:\Program Files\IAR Systems\Embedded Workbench         #
#                    6.5\rl78\LIB\dlrl78nn2n.h" -e -Ohz --no_scheduling       #
#                    --debug -lCN C:\Users\Suddenlink\Dropbox\git_files\embed #
#                    ded_design\project1\modified_RTCSched-G14\Debug\List\    #
#                    -I C:\Users\Suddenlink\Dropbox\git_files\embedded_design #
#                    \project1\modified_RTCSched-G14/applilet3_src/\ -I       #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\pr #
#                    oject1\modified_RTCSched-G14/Glyph/\ -I                  #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\pr #
#                    oject1\modified_RTCSched-G14/Glyph/Drivers/\ -I          #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\pr #
#                    oject1\modified_RTCSched-G14/user_include/\ -I           #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\pr #
#                    oject1\modified_RTCSched-G14/RTC/\ -I                    #
#                    C:\Users\Suddenlink\Dropbox\git_files\embedded_design\pr #
#                    oject1\modified_RTCSched-G14/Queu/\                      #
#    List file    =  C:\Users\Suddenlink\Dropbox\git_files\embedded_design\pr #
#                    oject1\modified_RTCSched-G14\Debug\List\queu.lst         #
#    Object file  =  C:\Users\Suddenlink\Dropbox\git_files\embedded_design\pr #
#                    oject1\modified_RTCSched-G14\Debug\Obj\queu.r87          #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\Suddenlink\Dropbox\git_files\embedded_design\project1\modified_RTCSched-G14\Queu\queu.c
      1          #include "r_cg_macrodriver.h"

   \                                 In  segment SADDR_A, at 0xfff04
   \   union <unnamed> volatile __saddr _A_P4
   \                     _A_P4:
   \   000000                       DS 1

   \                                 In  segment NEAR_A, at 0xfff46
   \   union <unnamed> volatile __sfr __no_bit_access _A_SDR03
   \                     _A_SDR03:
   \   000000                       DS 2

   \                                 In  segment NEAR_A, at 0xf0106
   \   union <unnamed> const volatile __no_bit_access _A_SSR03
   \                     _A_SSR03:
   \   000000                       DS 2

   \                                 In  segment NEAR_A, at 0xf010e
   \   union <unnamed> volatile __no_bit_access _A_SIR03
   \                     _A_SIR03:
   \   000000                       DS 2
      2          #include "r_cg_userdefine.h"
      3          #include "queu.h"
      4          #include "r_cg_serial.h"
      5          #include "rtc_sched.h"
      6          #include "tasks.h"
      7          
      8          
      9          /* =================== Global variables ======================= */

   \                                 In  segment NEAR_Z, align 2, align-sorted
     10          Q_T  rx_q;      //recieve queu
   \                     rx_q:
   \   000000                       DS 106
   \   00006A                       REQUIRE __INIT_NEAR_Z
     11          
     12          extern uint8_t * gp_uart1_tx_address;         /* uart1 send buffer address */
     13          extern uint16_t  g_uart1_tx_count;            /* uart1 send data number */
     14          extern uint8_t * gp_uart1_rx_address;         /* uart1 receive buffer address */
     15          extern uint16_t  g_uart1_rx_count;            /* uart1 receive data number */
     16          extern uint16_t  g_uart1_rx_length;           /* uart1 receive data length */
     17          
     18          /* ========================================== */
     19          
     20          
     21          /*#pragma vector = INTST1_vect
     22          __interrupt static void r_uart1_interrupt_send(void)
     23          	if more data to send {
     24          		dequeue data from tx_q
     25          		send it out transmitter
     26          	}
     27          }*/
     28          
     29          #pragma vector = INTSR1_vect

   \                                 In  segment CODE, align 1, keep-with-next
     30          __interrupt static void r_uart1_interrupt_receive(void)
   \                     r_uart1_interrupt_receive:
     31            {
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000 C1                    PUSH      AX                 ;; 1 cycle
   \   000001 C3                    PUSH      BC                 ;; 1 cycle
   \   000002 C7                    PUSH      HL                 ;; 1 cycle
   \   000003 AEFC                  MOVW      AX, 0xFFFFC        ;; 1 cycle
   \   000005 C1                    PUSH      AX                 ;; 1 cycle
   \   000006                       ; Auto size: 0
     32              static char led_state = 0;	
     33              LED_8_G = led_state;
   \   000006 36....                MOVW      HL, #??led_state   ;; 1 cycle
   \   000009 7184                  MOV1      CY, [HL].0         ;; 1 cycle
   \   00000B 714104                MOV1      S:0xFFF04.4, CY    ;; 2 cycles
     34              led_state ^= 1;
   \   00000E E1                    ONEB      A                  ;; 1 cycle
   \   00000F 7D                    XOR       A, [HL]            ;; 1 cycle
   \   000010 9B                    MOV       [HL], A            ;; 1 cycle
     35              
     36              
     37              uint8_t rx_data;
     38              uint8_t err_type;
     39              
     40              err_type = (uint8_t)(SSR03 & 0x0007U);
     41              SIR03 = (uint16_t)err_type;
   \   000011 AF0601                MOVW      AX, 0x106          ;; 1 cycle
   \   000014 60                    MOV       A, X               ;; 1 cycle
   \   000015 5C07                  AND       A, #0x7            ;; 1 cycle
   \   000017 70                    MOV       X, A               ;; 1 cycle
   \   000018 F1                    CLRB      A                  ;; 1 cycle
   \   000019 BF0E01                MOVW      0x10E, AX          ;; 1 cycle
     42          
     43              ///if error occurred	handle communication error
     44              if (err_type != 0U)
     45              {
     46                  r_uart1_callback_error(err_type);
     47              }
     48              //else {                get data from receiver
     49              rx_data = RXD1; 
   \   00001C 8E46                  MOV       A, 0xFFF46         ;; 1 cycle
   \   00001E 73                    MOV       B, A               ;; 1 cycle
     50              
     51              //if space is available in rx_q		enqueue data in rx_q
     52               if(Q_Enqueue(&rx_q , (char)rx_data) );
   \   00001F 30....                MOVW      AX, #rx_q          ;; 1 cycle
   \   000022 FD....                CALL      Q_Enqueue          ;; 3 cycles
     53                 //if true, enqueue suceeded
     54                 
     55              //else		handle buffer overflow error
     56               else {
     57                  r_uart1_callback_softwareoverrun( rx_data); //currently does nothing,
     58                  //and loses char
     59               }
     60                r_uart1_callback_receiveend();
   \   000025 300200                MOVW      AX, #0x2           ;; 1 cycle
   \   000028 FD....                CALL      Run_TaskN          ;; 3 cycles
     61               
     62                  /*
     63               //handle expected number of bytes, and call recieveend for Decode task
     64              if(g_uart1_rx_length > g_uart1_rx_count)
     65              {
     66                  *gp_uart1_rx_address = rx_data;
     67                  gp_uart1_rx_address++;
     68                  g_uart1_rx_count++;
     69          
     70                  if (g_uart1_rx_length == g_uart1_rx_count)
     71                  {
     72                      r_uart1_callback_receiveend();
     73                  }
     74              }
     75              else
     76              {
     77                  r_uart1_callback_softwareoverrun(rx_data);
     78              }
     79              */
     80          
     81          }
   \   00002B C0                    POP       AX                 ;; 1 cycle
   \   00002C BEFC                  MOVW      0xFFFFC, AX        ;; 1 cycle
   \   00002E C6                    POP       HL                 ;; 1 cycle
   \   00002F C2                    POP       BC                 ;; 1 cycle
   \   000030 C0                    POP       AX                 ;; 1 cycle
   \   000031 61FC                  RETI                         ;; 6 cycles
   \   000033                       ; ------------------------------------- Block: 39 cycles
   \   000033                       ; ------------------------------------- Total: 39 cycles
   \   000033                       REQUIRE ?CLRL78_V1_0_L00
   \   000033                       REQUIRE _A_P4
   \   000033                       REQUIRE _A_SSR03
   \   000033                       REQUIRE _A_SIR03
   \   000033                       REQUIRE _A_SDR03

   \                                 In  segment NEAR_Z, align 1, align-sorted
   \                     ??led_state:
   \   000000                       DS 1
   \   000001                       REQUIRE __INIT_NEAR_Z
     82          
     83          
     84          
     85          
     86          
     87          

   \                                 In  segment CODE, align 1, keep-with-next
     88          void Q_Init(Q_T * q) {
   \                     Q_Init:
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000 C3                    PUSH      BC                 ;; 1 cycle
   \   000001 C5                    PUSH      DE                 ;; 1 cycle
   \   000002                       ; Auto size: 0
   \   000002 14                    MOVW      DE, AX             ;; 1 cycle
     89            unsigned int i;
     90            for (i=0; i<Q_SIZE; i++) 
   \   000003 F7                    CLRW      BC                 ;; 1 cycle
   \   000004                       ; ------------------------------------- Block: 4 cycles
     91            q->Data[i] = 0; // to simplify our lives when debugging
   \                     ??Q_Init_0:
   \   000004 C5                    PUSH      DE                 ;; 1 cycle
   \   000005 C6                    POP       HL                 ;; 1 cycle
   \   000006 37                    XCHW      AX, HL             ;; 1 cycle
   \   000007 03                    ADDW      AX, BC             ;; 1 cycle
   \   000008 37                    XCHW      AX, HL             ;; 1 cycle
   \   000009 F1                    CLRB      A                  ;; 1 cycle
   \   00000A 9B                    MOV       [HL], A            ;; 1 cycle
   \   00000B A3                    INCW      BC                 ;; 1 cycle
   \   00000C 33                    XCHW      AX, BC             ;; 1 cycle
   \   00000D 446400                CMPW      AX, #0x64          ;; 1 cycle
   \   000010 33                    XCHW      AX, BC             ;; 1 cycle
   \   000011 DCF1                  BC        ??Q_Init_0         ;; 4 cycles
   \   000013                       ; ------------------------------------- Block: 15 cycles
     92            q->Head = 0;
   \   000013 F6                    CLRW      AX                 ;; 1 cycle
   \   000014 BA64                  MOVW      [DE+0x64], AX      ;; 1 cycle
     93            q->Tail = 0;
   \   000016 BA66                  MOVW      [DE+0x66], AX      ;; 1 cycle
     94            q->Size = 0;
   \   000018 BA68                  MOVW      [DE+0x68], AX      ;; 1 cycle
     95            }
   \   00001A C4                    POP       DE                 ;; 1 cycle
   \   00001B C2                    POP       BC                 ;; 1 cycle
   \   00001C D7                    RET                          ;; 6 cycles
   \   00001D                       ; ------------------------------------- Block: 12 cycles
   \   00001D                       ; ------------------------------------- Total: 31 cycles
   \   00001D                       REQUIRE ?CLRL78_V1_0_L00

   \                                 In  segment CODE, align 1, keep-with-next
     96            int Q_Empty(Q_T * q) {
   \                     Q_Empty:
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000                       ; Auto size: 0
   \   000000 16                    MOVW      HL, AX             ;; 1 cycle
     97            return q->Size == 0;
   \   000001 AC68                  MOVW      AX, [HL+0x68]      ;; 1 cycle
   \   000003 440000                CMPW      AX, #0x0           ;; 1 cycle
   \   000006 E1                    ONEB      A                  ;; 1 cycle
   \   000007 61E8                  SKZ                          ;; 4 cycles
   \   000009                       ; ------------------------------------- Block: 8 cycles
   \   000009 F1                    CLRB      A                  ;; 1 cycle
   \   00000A                       ; ------------------------------------- Block: 1 cycles
   \                     ??Q_Empty_0:
   \   00000A 70                    MOV       X, A               ;; 1 cycle
   \   00000B F1                    CLRB      A                  ;; 1 cycle
   \   00000C D7                    RET                          ;; 6 cycles
   \   00000D                       ; ------------------------------------- Block: 8 cycles
   \   00000D                       ; ------------------------------------- Total: 17 cycles
   \   00000D                       REQUIRE ?CLRL78_V1_0_L00
     98            }

   \                                 In  segment CODE, align 1, keep-with-next
     99            int Q_Full(Q_T * q) {
   \                     Q_Full:
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000                       ; Auto size: 0
   \   000000 16                    MOVW      HL, AX             ;; 1 cycle
    100            return q->Size >= Q_SIZE;
   \   000001 AC68                  MOVW      AX, [HL+0x68]      ;; 1 cycle
   \   000003 446400                CMPW      AX, #0x64          ;; 1 cycle
   \   000006 E1                    ONEB      A                  ;; 1 cycle
   \   000007 61D8                  SKNC                         ;; 4 cycles
   \   000009                       ; ------------------------------------- Block: 8 cycles
   \   000009 F1                    CLRB      A                  ;; 1 cycle
   \   00000A                       ; ------------------------------------- Block: 1 cycles
   \                     ??Q_Full_0:
   \   00000A 70                    MOV       X, A               ;; 1 cycle
   \   00000B F1                    CLRB      A                  ;; 1 cycle
   \   00000C D7                    RET                          ;; 6 cycles
   \   00000D                       ; ------------------------------------- Block: 8 cycles
   \   00000D                       ; ------------------------------------- Total: 17 cycles
   \   00000D                       REQUIRE ?CLRL78_V1_0_L00
    101          }
    102          
    103          

   \                                 In  segment CODE, align 1, keep-with-next
    104          int Q_Enqueue(Q_T * q, unsigned char d) {
   \                     Q_Enqueue:
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000 C5                    PUSH      DE                 ;; 1 cycle
   \   000001 C1                    PUSH      AX                 ;; 1 cycle
   \   000002                       ; Auto size: 2
    105            // What if queue is full?
    106            if (!Q_Full(q)) {
   \   000002 FD....                CALL      Q_Full             ;; 3 cycles
   \   000005 440000                CMPW      AX, #0x0           ;; 1 cycle
   \   000008 DF24                  BNZ       ??Q_Dequeue_0      ;; 4 cycles
   \   00000A                       ; ------------------------------------- Block: 10 cycles
    107            q->Data[q->Tail++] = d;
   \   00000A A800                  MOVW      AX, [SP]           ;; 1 cycle
   \   00000C 046600                ADDW      AX, #0x66          ;; 1 cycle
   \   00000F 16                    MOVW      HL, AX             ;; 1 cycle
   \   000010 AB                    MOVW      AX, [HL]           ;; 1 cycle
   \   000011 14                    MOVW      DE, AX             ;; 1 cycle
   \   000012 A800                  MOVW      AX, [SP]           ;; 1 cycle
   \   000014 05                    ADDW      AX, DE             ;; 1 cycle
   \   000015 14                    MOVW      DE, AX             ;; 1 cycle
   \   000016 63                    MOV       A, B               ;; 1 cycle
   \   000017 99                    MOV       [DE], A            ;; 1 cycle
   \   000018 AB                    MOVW      AX, [HL]           ;; 1 cycle
   \   000019 A1                    INCW      AX                 ;; 1 cycle
   \   00001A BB                    MOVW      [HL], AX           ;; 1 cycle
    108            q->Tail %= Q_SIZE;
   \   00001B 346400                MOVW      DE, #0x64          ;; 1 cycle
   \   00001E CEFB03                DIVHU                        ;; 9 cycles
   \   000021 15                    MOVW      AX, DE             ;; 1 cycle
   \   000022 BB                    MOVW      [HL], AX           ;; 1 cycle
    109            q->Size++;
   \   000023 A800                  MOVW      AX, [SP]           ;; 1 cycle
   \   000025 14                    MOVW      DE, AX             ;; 1 cycle
   \   000026 AA68                  MOVW      AX, [DE+0x68]      ;; 1 cycle
   \   000028 A1                    INCW      AX                 ;; 1 cycle
   \   000029 BA68                  MOVW      [DE+0x68], AX      ;; 1 cycle
    110            return 1; // success
   \   00002B E6                    ONEW      AX                 ;; 1 cycle
   \   00002C EF01                  BR        S:??Q_Dequeue_1    ;; 3 cycles
   \   00002E                       ; ------------------------------------- Block: 34 cycles
    111            } else 
    112            return 0; // failure
   \                     ??Q_Dequeue_0:
   \   00002E F6                    CLRW      AX                 ;; 1 cycle
   \   00002F                       ; ------------------------------------- Block: 1 cycles
   \                     ??Q_Dequeue_1:
   \   00002F 1002                  ADDW      SP, #0x2           ;; 1 cycle
   \   000031 C4                    POP       DE                 ;; 1 cycle
   \   000032 D7                    RET                          ;; 6 cycles
   \   000033                       ; ------------------------------------- Block: 8 cycles
   \   000033                       ; ------------------------------------- Total: 53 cycles
   \   000033                       REQUIRE ?CLRL78_V1_0_L00
    113          }

   \                                 In  segment CODE, align 1, keep-with-next
    114          unsigned char Q_Dequeue(Q_T * q) {
   \                     Q_Dequeue:
   \   000000                       ; * Stack frame (at entry) *
   \   000000                       ; Param size: 0
   \   000000 C3                    PUSH      BC                 ;; 1 cycle
   \   000001 C5                    PUSH      DE                 ;; 1 cycle
   \   000002 C1                    PUSH      AX                 ;; 1 cycle
   \   000003                       ; Auto size: 4
   \   000003 C1                    PUSH      AX                 ;; 1 cycle
    115            // Must check to see if queue is empty before dequeueing
    116            unsigned char t=0;
   \   000004 F3                    CLRB      B                  ;; 1 cycle
    117            if (!Q_Empty(q)) {
   \   000005 FD....                CALL      Q_Empty            ;; 3 cycles
   \   000008 440000                CMPW      AX, #0x0           ;; 1 cycle
   \   00000B DF28                  BNZ       ??Q_Dequeue_2      ;; 4 cycles
   \   00000D                       ; ------------------------------------- Block: 13 cycles
    118            t = q->Data[q->Head];
   \   00000D A802                  MOVW      AX, [SP+0x02]      ;; 1 cycle
   \   00000F 046400                ADDW      AX, #0x64          ;; 1 cycle
   \   000012 B800                  MOVW      [SP], AX           ;; 1 cycle
   \   000014 16                    MOVW      HL, AX             ;; 1 cycle
   \   000015 AB                    MOVW      AX, [HL]           ;; 1 cycle
   \   000016 14                    MOVW      DE, AX             ;; 1 cycle
   \   000017 A802                  MOVW      AX, [SP+0x02]      ;; 1 cycle
   \   000019 05                    ADDW      AX, DE             ;; 1 cycle
   \   00001A 16                    MOVW      HL, AX             ;; 1 cycle
   \   00001B 8B                    MOV       A, [HL]            ;; 1 cycle
   \   00001C 73                    MOV       B, A               ;; 1 cycle
    119            q->Data[q->Head++] = 0; // to simplify debugging
   \   00001D F1                    CLRB      A                  ;; 1 cycle
   \   00001E 9B                    MOV       [HL], A            ;; 1 cycle
   \   00001F A800                  MOVW      AX, [SP]           ;; 1 cycle
   \   000021 16                    MOVW      HL, AX             ;; 1 cycle
   \   000022 AB                    MOVW      AX, [HL]           ;; 1 cycle
   \   000023 A1                    INCW      AX                 ;; 1 cycle
   \   000024 BB                    MOVW      [HL], AX           ;; 1 cycle
    120            q->Head %= Q_SIZE;
   \   000025 346400                MOVW      DE, #0x64          ;; 1 cycle
   \   000028 CEFB03                DIVHU                        ;; 9 cycles
   \   00002B 15                    MOVW      AX, DE             ;; 1 cycle
   \   00002C BB                    MOVW      [HL], AX           ;; 1 cycle
    121            q->Size--;
   \   00002D A802                  MOVW      AX, [SP+0x02]      ;; 1 cycle
   \   00002F 16                    MOVW      HL, AX             ;; 1 cycle
   \   000030 AC68                  MOVW      AX, [HL+0x68]      ;; 1 cycle
   \   000032 B1                    DECW      AX                 ;; 1 cycle
   \   000033 BC68                  MOVW      [HL+0x68], AX      ;; 1 cycle
   \   000035                       ; ------------------------------------- Block: 35 cycles
    122            }
    123            return t;
   \                     ??Q_Dequeue_2:
   \   000035 63                    MOV       A, B               ;; 1 cycle
   \   000036 1004                  ADDW      SP, #0x4           ;; 1 cycle
   \   000038 C4                    POP       DE                 ;; 1 cycle
   \   000039 C2                    POP       BC                 ;; 1 cycle
   \   00003A D7                    RET                          ;; 6 cycles
   \   00003B                       ; ------------------------------------- Block: 10 cycles
   \   00003B                       ; ------------------------------------- Total: 58 cycles
   \   00003B                       REQUIRE ?CLRL78_V1_0_L00
    124          }

   \                                 In  segment INTVEC, offset 0x26, root
   \   000026 ....                  DW r_uart1_interrupt_receive
    125          
    126          
    127          
    128          
    129          
    130          
    131          /***********************************************************************************************************************
    132          * Function Name: r_uart1_callback_error
    133          * Description  : This function is a callback function when UART1 reception error occurs.
    134          * Arguments    : err_type -
    135          *                    error type value
    136          * Return Value : None
    137          ***********************************************************************************************************************/
    138          static void r_uart1_callback_error(uint8_t err_type)
    139          {
    140              /* Start user code. Do not edit comment generated here */
    141              /* End user code. Do not edit comment generated here */
    142          }
    143          /***********************************************************************************************************************
    144          * Function Name: r_uart1_callback_receiveend
    145          * Description  : This function is a callback function when UART1 finishes reception.
    146          * Arguments    : None
    147          * Return Value : None
    148          ***********************************************************************************************************************/
    149          static void r_uart1_callback_receiveend(void)
    150          {
    151              /* Start user code. Do not edit comment generated here */
    152                 
    153                  Run_TaskN(2); //decode task
    154                 
    155              /* End user code. Do not edit comment generated here */
    156          }
    157          
    158          /***********************************************************************************************************************
    159          * Function Name: r_uart1_callback_softwareoverrun
    160          * Description  : This function is a callback function when UART1 receives an overflow data.
    161          * Arguments    : rx_data -
    162          *                    receive data
    163          * Return Value : None
    164          ***********************************************************************************************************************/
    165          static void r_uart1_callback_softwareoverrun(uint16_t rx_data)
    166          {
    167              /* Start user code. Do not edit comment generated here */
    168              /* End user code. Do not edit comment generated here */
    169          }
    170          
    171          
    172          

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      8   Q_Dequeue
        8   -> Q_Empty
      0   Q_Empty
      4   Q_Enqueue
        4   -> Q_Full
      0   Q_Full
      4   Q_Init
      8   r_uart1_interrupt_receive
        8   -> Q_Enqueue
        8   -> Run_TaskN


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       2  ??r_uart1_interrupt_receive??INTVEC 38
      59  Q_Dequeue
      13  Q_Empty
      51  Q_Enqueue
      13  Q_Full
      29  Q_Init
       1  _A_P4
       2  _A_SDR03
       2  _A_SIR03
       2  _A_SSR03
       1  led_state
      51  r_uart1_interrupt_receive
     106  rx_q

 
 216 bytes in segment CODE
   2 bytes in segment INTVEC
   6 bytes in segment NEAR_A
 107 bytes in segment NEAR_Z
   1 byte  in segment SADDR_A
 
 216 bytes of CODE memory (+ 2 bytes shared)
 107 bytes of DATA memory (+ 7 bytes shared)

Errors: none
Warnings: none
